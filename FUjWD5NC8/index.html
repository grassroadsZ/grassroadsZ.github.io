<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Django知识点 | grassroadsZ</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://grassroadsz.github.io/favicon.ico?v=1654822266035">
<link rel="stylesheet" href="https://grassroadsz.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、创建Django
1. 创建Django项目
1）利用命令创建

	执行：django-admin.py startproject 项目名称

 2）利用pycharm创建

	打开pycharm，点击File =&gt; New Pr..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://grassroadsz.github.io">
        <img src="https://grassroadsz.github.io/images/avatar.png?v=1654822266035" class="site-logo">
        <h1 class="site-title">grassroadsZ</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://grassroadsz.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Django知识点</h2>
            <div class="post-date">2022-05-31</div>
            
            <div class="post-content" v-pre>
              <h2 id="一-创建django">一、创建Django</h2>
<h4 id="1-创建django项目">1. 创建Django项目</h4>
<pre><code>1）利用命令创建
</code></pre>
<pre><code>	执行：django-admin.py startproject 项目名称

 2）利用pycharm创建

	打开pycharm，点击File =&gt; New Project =&gt; Django
</code></pre>
<h4 id="2-django工程目录结构">2. Django工程目录结构</h4>
<pre><code>	** init **.py：当前project为一个包

	asgi.py：存放ASGI异步请求的入口配置信息

	settings.py：存放项目全局配置信息

	urls.py：存放项目的路由信息

	wsgi.py：存放WSGI协议服务的入口配置信息（一般在部署时使用）

	sqlite3：默认的关系型文本数据库

	templates：存放模板

	manage.py：命令行管理工具，用于开发阶段的项目启动、数据迁移、静态文件收集等
</code></pre>
<h4 id="3-配置初始设置">3. 配置初始设置</h4>
<pre><code>	settings.py：指定简体中文、指定时区、定义子应用等
</code></pre>
<pre><code class="language-python"># 指定简体中文
LANGUAGE_CODE = 'zh-hans'
# 指定时区
TIME_ZONE = 'Asia/ShangHai'
</code></pre>
<h4 id="4-运行项目">4. 运行项目</h4>
<pre><code>	python manage.py runserver 127.0.0.1:8000
</code></pre>
<h2 id="二-子应用">二、子应用</h2>
<h4 id="1-子应用的作用">1. 子应用的作用</h4>
<pre><code>· 实现业务功能模块的复用

· 将工程项目拆分为不同的子功能模块，以子应用的形式存在

· 各功能模块之间可以保持相对的独立

· 实现路由的分发，便于管理各模块的url，减少代码维护成本
</code></pre>
<h4 id="2-创建">2. 创建</h4>
<pre><code>1）python manage.py startapp projects

2）注册

	在全局配置文件settings中的INSTALLED_APPS列表，添加子应用
</code></pre>
<pre><code># 子应用名.apps.子应用名首字母大写Config
'projects.apps.ProjectsConfig',
</code></pre>
<pre><code>3）在views.py中创建视图函数

4）在urls.py中配置路由信息

	子路由表：将url和需要调用的视图函数之间进行映射

	全局路由表：使用include加载子路由
</code></pre>
<h4 id="3-目录结构">3. 目录结构</h4>
<pre><code>migrations 存放数据库迁移脚本历史记录等信息

admin.py：admin后台站点的相关配置

apps.py：app label的相关配置

models.py：存放数据库模型相关信息

test.py：对当前子应用进行自测，单元测试

views.py：子应用视图
</code></pre>
<h2 id="三-路由">三、路由</h2>
<h4 id="1-定义">1. 定义</h4>
<pre><code>路由表：url与后端视图函数的一个映射关系表

web应用调用后端服务：前端访问url获取页面 --&gt; 后端调用指定函数func(a, b, ...)
</code></pre>
<h4 id="2-路由匹配规则">2. 路由匹配规则</h4>
<pre><code>①urlpatterns自上而下开始匹配

②一旦匹配成功，将调用path第二个参数所指定的视图函数，并且不会再向下匹配

③若url匹配不成功，则页面返回404

④路由信息一般以'/'结尾

⑤在子应用下定义子路由，主路由中使用include('子应用名.urls')来加载子路由，若url第一部分匹配，则剩下部分会被拿到子路由中匹配。
</code></pre>
<h4 id="3-路由分发">3. 路由分发</h4>
<pre><code>	在子路由中，将url和需要调用的视图函数之间进行映射，全局路由对各个应用进行绑定，利用include加载子路由，从而实现路由的分发，便于根据不同的应用来管理各自的url，减少代码维护成本
</code></pre>
<h2 id="四-视图">四、视图</h2>
<h3 id="1-函数视图">1. 函数视图</h3>
<pre><code class="language-python"># 第一个参数为HttpRequest对象或者HttpRequest子类对象，无需手动传递，一般参数名为request
# 一定要返回HttpResponse对象或者HttpResponse子类对象

def index01_page(request):
    return HttpResponse('&lt;h2&gt;Hello World&lt;/h2&gt;')
</code></pre>
<h3 id="2-类视图">2. 类视图</h3>
<pre><code class="language-python"># 一定要继承View的父类或子类
# 可定义get、put、post、delete等方法，实现多种方式的请求
# 方法名称固定小写
# 实例方法的第二个参数为HttpRequest对象

class IndexPage(View):
    def get(self, request):
        &quot;&quot;&quot;
        可使用url后面?的参数，称为query string查询字符串参数
        request.GET去获取参数字符串参数
        request.GET返回QueryDict对象，类似字典，支持字典中的所有操作
        request.GET[key]、request.GET.get(key)、request.GET.getlist()去获取参数值
        &quot;&quot;&quot;
        return HttpResponse('&lt;h2&gt;get请求&lt;/h2&gt;')
    
    def put(self, request):
        &quot;&quot;&quot;
        HttpResponse对象，第一个参数为字符串类型或字节型参数，会将字符串内容返回到前端
        可以使用content_type来传递内容类型
        可以使用status参数来指定响应状态码
        &quot;&quot;&quot;
        data = &quot;{'name': 'ergui', 'age': 18}&quot;
        return HttpResponse(data, content_type='application/json', status=201)
    
    def post(self, request, pk, username):
        &quot;&quot;&quot;
        可以使用request.POST方法，获取application/x-www-urlencoded类型的参数
        可以使用request.body方法，获取application/json类型的参数
        可以使用request.META方法，获取请求头参数，key为HTTP_请求头key的大写
        &quot;&quot;&quot;
        data_dict = json.loads(request.body, encoding='utf-8')
        return HttpResponse(f'&lt;h2&gt;post请求{data_dict[&quot;name&quot;]}&lt;/h2&gt;')
</code></pre>
<h2 id="五-请求与响应">五、请求与响应</h2>
<h4 id="1-请求参数类型">1. 请求参数类型</h4>
<p>利用HTTP协议向服务器传参的几种途径</p>
<h6 id="1查询字符串传参">1）查询字符串传参</h6>
<pre><code>如：ip:port/index/?name=ergui&amp;age=18

url后面的?参数，可以使用request.GET获取，返回QueryDict对象，可通过request.GET[key]、request.GET.get(key)、request.GET.getlist()获取参数值
</code></pre>
<h6 id="2请求体参数">2）请求体参数</h6>
<pre><code>form表单传参

		使用request.POST方法，获取application/x-www-form-urlencoded类型的参数

json格式参数

		使用request.body方法，获取application/json类型的参数

上传文件

		使用request.body方法，获取到文件的二进制格式数据
</code></pre>
<h6 id="3路径参数">3）路径参数</h6>
<pre><code>如：ip:port/index/10/

把参数伪装成路径，传递到后端

在路由中配置路径：&lt; url类型转换器:路径参数名 &gt;；请求函数中配置请求参数：def post(self, request, n)
</code></pre>
<pre><code>path('index04/&lt;int:pk&gt;/&lt;username&gt;/', views.IndexPage.as_view())
</code></pre>
<h4 id="2-响应">2. 响应</h4>
<p>视图中必须返回HTTPResponse对象或子对象</p>
<p>HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)</p>
<p>jsonResponse</p>
<pre><code class="language-python">class IndexPage(View):
    def get(self, request):
        data = [
            {
                'project_name': '王者项目',
                'leader': 'ergui',
                'app_name': '王者农药'
            },
            {
                'project_name': '活到最后项目',
                'leader': 'star',
                'app_name': '吃鸡'
            }
        ]
        
        # render()主要用于渲染模板，生成一个html页面，第一个参数为request，第二个参数为在templates目录下的模板名，第三个参数为context，只能传字典
        # return render(request, 'demo.html')
        # locals()，获取当前命名空间中的所有变量值，存放在一个字典中
        # return render(request, 'demo.html', locals())
        
        # JsonResponse是HttpResponse的子类，第一个参数为字典或者嵌套字典的列表，如果使用非字典格式，需设置safe为False
        return JsonResponse(data, safe=False)
</code></pre>
<h2 id="六-mvt模式和两种开发模式">六、MVT模式和两种开发模式</h2>
<h3 id="1mvt">1.MVT</h3>
<p>M：Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理</p>
<p>V：View，与MVC中的C功能相同，接收请求，进行业务处理，返回响应</p>
<p>T：Template，与MVC中的V功能相同，负责构造要返回的html页面</p>
<h3 id="2-两种开发模型">2. 两种开发模型</h3>
<h4 id="1前后不分离">1）前后不分离</h4>
<pre><code>前端数据的展示由后端来控制，后端渲染或重定向页面

耦合严重

返回的为html页面，实用性差，拓展性差，只能用于浏览器，与其他终端不适配
</code></pre>
<h4 id="2前后分离">2）前后分离</h4>
<pre><code>前后端独立，后端只需对数据进行处理，向前端提供数据，由前端负责页面的展示

解耦合

前后端可同时进行开发，缩小业务上线周期

大部分情况下，前端发送json格式参数，后端同样以json格式数据返回

扩展性、适应性好，可多终端运行同一套接口，如PC、APP、小程序等
</code></pre>
<h2 id="七-orm">七、ORM</h2>
<h4 id="1-概念">1. 概念</h4>
<p>· 将类和数据表进行映射</p>
<p>· 通过类和对象就能操作它所对应表格中的数据（CRUD）</p>
<p>· ORM中可以创建模型类，通过模型类，自动创建数据库表</p>
<h4 id="2-步骤">2. 步骤</h4>
<p>①在全局settings.py -- DATABASES中，配置数据库连接信息</p>
<p>②在子应用的models.py中，定义数据模型</p>
<pre><code>一个数据模型类对应一个数据表

数据模型类，需要继承Model父类或者Model子类

在数据模型类中，添加的类属性（Field对象）来对应数据表中的字段

在模型类下定义子类，子类名称固定为Meta，可使用db_table属性，指定表名
</code></pre>
<pre><code class="language-python">class Projects(models.Model):
    project_id = models.AutoField(primary_key=True)
    
    # 约束项目名称 name 字段，最大长度为200，值唯一
    name = models.CharField(max_length=200, verbose_name='项目名称', help_text='项目名称', unique=True)
	
    # 项目简介 desc 字段，参数可以为空，为空时使用 default 默认值
	desc = models.TextField(verbose_name='项目简介', help_text='项目简介', blank=True, default='项目简介', null=True)
	
    # 数据创建时，添加当前时间
	create_time = models.DateTimeField(auto_now_add=True, verbose_name='创建时间', help_text='创建时间')

	# 数据更新时，update_time更新，update_time只有在调用save方法的时候才会自动更新
	update_time = models.DateTimeField(auto_now=True, verbose_name='更新时间', help_text='更新时间')
    
    class Meta:
   		 db_table = 'tb_projects'
   		 verbose_name = '项目表'
</code></pre>
<p>③创建完数据库模型类后，需要迁移才能生成数据表</p>
<pre><code>生成迁移脚本，放在projects/migrations目录中：python manage.py makemigrations (子应用名)（如果不加子应用名，则会将所有子应用进行迁移）

执行迁移脚本：python manage.py migrate

会自动创建一个自增id，若存在一个自动primary_key=True，则不会自动创建id
</code></pre>
<p>在执行迁移脚本后，生成的数据表名默认为子应用名_模型类名</p>
<h6 id="模型类字段的定义">模型类字段的定义</h6>
<table>
<thead>
<tr>
<th>verbose_name</th>
<th>个性化信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>help_text</td>
<td>帮助文本信息，在api接口文档平台和admin后端站点中会用于提示，一般和verbose_name一致</td>
</tr>
<tr>
<td>unique</td>
<td>字段值唯一</td>
</tr>
<tr>
<td>null</td>
<td>指定数据在保存时是否可以为空，默认必填，如果null为True，则可以为空</td>
</tr>
<tr>
<td>blank</td>
<td>指定前端用户在创建数据时，是否需要传递，默认需要，如不传递，则blank为True</td>
</tr>
<tr>
<td>defalut</td>
<td>为某一个字段指定默认值，往往会和blank一起使用</td>
</tr>
<tr>
<td>auto_now_add</td>
<td>自动添加记录创建的时间（数据的create_time）</td>
</tr>
<tr>
<td>auto_now</td>
<td>记录更新的时间（数据的update_time）</td>
</tr>
</tbody>
</table>
<p>只有使用form表单时，blank和null才会起作用</p>
<h4 id="3curd">3.CURD</h4>
<p>直接使用sql语句：objects.raw('sql')</p>
<h5 id="1c-创建create">1）C-创建create</h5>
<p>方法一：使用模型类对象创建</p>
<pre><code>①创建一个projects模型类对象

②调用模型对象的save()，提交
</code></pre>
<pre><code class="language-python">proj_obj = Projects(name='飞向月球计划', leader='ergui', tester='测试1', programmer='研发1')
proj_obj.save()
</code></pre>
<p>方法二：使用查询集的create方法</p>
<pre><code>objects是manager对象，用于对数据进行操作

使用模型类.objects.create()方法，无需再save
</code></pre>
<pre><code class="language-python">Projects.objects.create(name='占领火星计划', leader='ergui', tester='测试2', programmer='研发2')
</code></pre>
<h5 id="2u-更新update">2）U-更新update</h5>
<p>方法一：先获取模型类对象，然后修改某些字段，再调用save</p>
<pre><code class="language-python">proj_obj = Projects.objects.get(name='飞向月球计划')
proj_obj.name = '驻扎广寒宫计划'
proj_obj.save()
</code></pre>
<p>方法二：使用模型类.objects.filter(字段名=值).update(字段名=修改的值)</p>
<p>ps: 只有调用了save()，记录的updatetime才会更新</p>
<pre><code class="language-python">Projects.objects.filter(name='Django学习计划').update(name='Django从入门到放弃')
</code></pre>
<h5 id="3r-查询retrieve">3）R-查询retrieve</h5>
<p>使用objects管理器来查询</p>
<h6 id="获取一条记录get">获取一条记录：get()</h6>
<p>一般只能使用主键或唯一键作为查询条件，如果返回结果为空或多条记录，则会抛出异常</p>
<p>返回的模型类对象，会自动提交</p>
<pre><code class="language-python">res = Projects.objects.get(project_id=17)
</code></pre>
<h6 id="获取表中的所有记录all">获取表中的所有记录：all()</h6>
<p>返回QuertSet查询集对象，类似列表，支持列表中的某些操作</p>
<pre><code>· 支持数字索引取值（负索引不支持，返回模型类对象，一条记录）、切片（返回查询集对象）

· 支持for循环迭代，每次迭代取出一个模型类对象

· QuertSet查询集对象.first()获取第一个记录、last()获取最后一条记录

· count()获取查询集中的记录条数

· 惰性查询，只有真正使用数据时，才会去数据库中执行sql语句，为了性能要求

· 链式调用
</code></pre>
<pre><code class="language-python">res = Projects.objects.all()
</code></pre>
<h6 id="过滤出部分记录filter">过滤出部分记录：filter()</h6>
<p>支持多个过滤表达式，字段名__过滤表达式，如果查询结果为空，则返回 一个空查询集</p>
<pre><code>· ** startswith=' '、 ** isstartswith（忽略大小写）：过滤以xxx开头的字符串

· ** endswith=' '、 ** iendswith（忽略大小写）：过滤以xxx结尾的字符串

· __ in=[]：过滤出在条件列表中的数据

· ** gt=' '：大于、** gte=' '：大于等于、** lt=' '：小于、** lte=' '：小于等于、__ exact=' '：等于（等同于 字段名=值 ）

. __ isnull=True：查询字段为空/不为空的数据

. ** contains=‘ ’、 ** icontains=‘ ’：过滤包含xxx的数据

. __ regex=‘ ’：正则过滤
</code></pre>
<p>在ORM中有一个内置的变量pk，为数据库模型类的主键别名</p>
<pre><code class="language-python">Projects.objects.filter()   # 等同于all()
Projects.objects.filter(name='占领火星计划')
Projects.objects.filter(name__startswith='占领')
Projects.objects.filter(id__in=[1, 20])
</code></pre>
<h6 id="反向查询exclude">反向查询：exclude()</h6>
<p>使用方法等同于filter()，查询结果相反</p>
<pre><code class="language-python">Projects.objects.exclude(name='Django学习计划')
</code></pre>
<h6 id="关联查询">关联查询</h6>
<p>通过从表的信息获取父表的记录，从表模型类名(小写)** 从表字段名 **查询表达式</p>
<p>惰性：查询集对象，只有去使用的时候，才会执行sql语句</p>
<pre><code class="language-python">qs = Projects.objects.filter(interfaces__name__regex='^[0-9]]')
</code></pre>
<h6 id="逻辑关系查询">逻辑关系查询</h6>
<p>查询集支持链式调用，可以使用filter方法过滤。</p>
<p>· “与”查询：filter(查询条件1, 查询条件2)</p>
<pre><code>qs = Projects.objects.filter(name__startswith='x').filter(programmer__contains='4')

qs = Projects.objects.filter(name__startswith='x', programmer__contains='4')
</code></pre>
<p>· “或”查询： filter(Q(查询条件1) | Q(查询条件2))</p>
<pre><code>qs = Projects.objects.filter(Q(leader__contains='1') | Q(programmer__contains='4'))
</code></pre>
<p>· 聚合查询</p>
<pre><code>qs = Projects.objects.annotate(Count('name'))
</code></pre>
<h6 id="特殊操作">特殊操作</h6>
<p>使用order_by排序，默认升序。使用 ' - '标识降序</p>
<pre><code>Projects.objects.all().order_by('-id', 'name')
</code></pre>
<p>表与表之间的关系：</p>
<pre><code>一对一：models.OneToOneField

一对多：models.ForeignKey，“一”：父表；“多”：子表

	如：项目表、接口表，一个接口属于一个项目，一个项目拥有多个接口，因此，项目表（一） -- &gt; 接口表（多）

多对多：models.ManyToManyField
</code></pre>
<h5 id="4d-删除delete">4）D-删除delete</h5>
<p>使用模型对象.delete()</p>
<pre><code class="language-python">proj_obj = Projects.objects.get(name='占领火星计划')
proj_obj.delete()
</code></pre>
<h4 id="4-痛点">4. 痛点</h4>
<pre><code>代码冗余大

数据校验麻烦

获取列表数据，没有分页、过滤、排序操作

不支持以表单提交参数

无法自动生成接口文档
</code></pre>
<h2 id="八-restful">八、RESTful</h2>
<h3 id="1-基本概念">1. 基本概念</h3>
<p>1）restful是一种开发风格而非标准</p>
<p>2）Representational State Transfer，具象状态传输</p>
<p>3）每一个url代表一种资源：json格式数据、text文本、图片视频等</p>
<p>4）客户端与服务器之间，传递这种资源的某种表现形式</p>
<pre><code>· 通过请求头中Content-Type来指明传给服务端的参数类型
</code></pre>
<p>&quot;text/plain&quot;、&quot;application/xml&quot;、&quot;text/html&quot;、&quot;application/json&quot;、&quot;image/gif&quot;、&quot;image/jpeg&quot;、&quot;application/x-www-form-urlencoded&quot;</p>
<pre><code>· 通过请求头中Accept来指明希望接受服务端的数据类型
</code></pre>
<p>Accept: application/json,application/xml;q=0.9,_/ _;q=0.8</p>
<p>5）客户端通过HTTP动词，指明对服务器端资源要进行的操作</p>
<table>
<thead>
<tr>
<th>HTTP METHOD</th>
<th>CRUD</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>Create</td>
</tr>
<tr>
<td>GET</td>
<td>Search</td>
</tr>
<tr>
<td>PUT</td>
<td>Update/Replace</td>
</tr>
<tr>
<td>PATCH</td>
<td>Partial Update/Modify</td>
</tr>
<tr>
<td>DELETE</td>
<td>Delete</td>
</tr>
</tbody>
</table>
<h3 id="2-rest常用设计规则">2. REST常用设计规则</h3>
<h4 id="协议">协议</h4>
<p>一般使用Https协议</p>
<h4 id="路径命名">路径命名</h4>
<pre><code>尽量用名词复数形式

往往与数据库表明对应

如：/getProjects、/users、/testcaseById?Id=6
</code></pre>
<h4 id="过滤信息">过滤信息</h4>
<p>若记录数量很多，服务器不可能将所有数据都返回给前端</p>
<p>?limit=10：指定返回记录的数量</p>
<p>?offset=10：指定返回记录的开始位置</p>
<p>?page=2&amp;size=10：指定第几页和每页的数据条数</p>
<p>?sort=name：指定返回结果按照哪个属性排序，以及排序顺序</p>
<h4 id="域名">域名</h4>
<pre><code>尽量使用专用域名：[http://api.ergui.site](http://api.ergui.site)
</code></pre>
<h4 id="版本">版本</h4>
<pre><code>在URL中呈现版本号：[http://api.ergui.site/app/0.1/](http://api.ergui.site/app/0.1/)

在请求头中呈现版本号：Accept：application/vnd.example+json;version=1.1
</code></pre>
<h4 id="http请求动词">Http请求动词</h4>
<p>含义</p>
<table>
<thead>
<tr>
<th>GET</th>
<th>从服务器获取资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>服务器中新建资源</td>
</tr>
<tr>
<td>PUT</td>
<td>在服务器更新资源</td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器删除资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>在服务器部分更新资源</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取资源的元数据</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>获取关于资源的哪些属性是客户端可以改变的信息</td>
</tr>
</tbody>
</table>
<p>例</p>
<table>
<thead>
<tr>
<th>GET　/projects</th>
<th>获取所有项目信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST　/projects</td>
<td>创建一个新项目</td>
</tr>
<tr>
<td>GET　/projects/6</td>
<td>获取ID为6的项目信息</td>
</tr>
<tr>
<td>PUT　/projects/6</td>
<td>更新ID为6的项目信息（全更新）</td>
</tr>
<tr>
<td>PATCH　/projects/6</td>
<td>更新ID为6的项目信息（部分更新）</td>
</tr>
<tr>
<td>DELETE　/projects/6</td>
<td>删除ID为６的项目</td>
</tr>
<tr>
<td>GET　/projects/6/interfaces</td>
<td>获取ID为6的项目信息中所有的接口信息</td>
</tr>
<tr>
<td>GET　/projects/6/interfaces/1</td>
<td>获取ID为6的所有项目信息中ID为1的接口信息</td>
</tr>
</tbody>
</table>
<h4 id="状态码">状态码</h4>
<p>200	ok - [GET]：服务器返回用户请求的数据</p>
<p>201	CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功</p>
<p>204	No Content - [DELETE]：用户删除数据成功</p>
<p>400	INVAILD REQUEST - [POST/PUT/PATCH]：用户请求有误（请求参数有误）</p>
<p>401	Unauthorized - [*]：表示用户没有权限</p>
<p>403	Forbidden - [*]：表示用户得到授权，但是访问被禁止</p>
<p>404	Not Found - [*]：用户请求的路径不存在</p>
<p>406	用户请求的格式错误</p>
<p>500	Internal Server Error - [*]：服务器发生错误</p>
<h4 id="返回结果">返回结果</h4>
<table>
<thead>
<tr>
<th>GET　/projects</th>
<th>返回所有项目列表（json数组</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST　/projects</td>
<td>返回新创建的项目信息（单个json</td>
</tr>
<tr>
<td>GET　/projects/6</td>
<td>返回单个项目信息 (单个json</td>
</tr>
<tr>
<td>PUT　/projects/6</td>
<td>返回更新之后，完整的项目信息（单个json</td>
</tr>
<tr>
<td>PATCH　/projects/6</td>
<td>返回更新之后，完整的项目信息（单个json</td>
</tr>
<tr>
<td>DELETE　/projects/6</td>
<td>返回空</td>
</tr>
<tr>
<td>GET　/projects/6/interfaces/1</td>
<td>返回单个接口信息（单个json</td>
</tr>
</tbody>
</table>
<h4 id="错误处理">错误处理</h4>
<p>当请求有误时，需将错误信息以json格式返回</p>
<p>{&quot;error&quot;:&quot;xxx错误&quot;,&quot;status_code&quot;:401}</p>
<h4 id="hypermedia-api">Hypermedia API</h4>
<p>超链接API，返回结果中提供链接</p>
<pre><code class="language-javascript">{&quot;link&quot;: {
  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,
  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,
  &quot;title&quot;: &quot;List of zoos&quot;,
  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;
}}
</code></pre>
<h2 id="九-rest-framework框架">九、REST framework框架</h2>
<p>在Django框架基础上，进行二次开发，用于构建Restful API，简称DRF框架或REST framework框架</p>
<h3 id="特性">特性</h3>
<p>提供了强大的Serializer序列化器，可以高效地进行序列化与反序列化操作</p>
<p>提供了丰富的类视图、Mixin扩展类、ViewSet视图集</p>
<p>提供了直观的Web API界面</p>
<p>实现了多种身份认证和权限认证</p>
<p>实现了排序、过滤、分页、搜索、限流等功能</p>
<p>可扩展性强，插件丰富</p>
<h3 id="安装与配置">安装与配置</h3>
<h6 id="安装">安装</h6>
<pre><code class="language-python">pip install djangorestframework
pip install markdown
</code></pre>
<h6 id="配置">配置</h6>
<p>在全局settings.py中添加子应用，'rest_framework'</p>
<pre><code class="language-python">INSTALLED_APPS = [
    'rest_framework',
]
</code></pre>
<h3 id="序列化器">序列化器</h3>
<p>将变量从内存中取出变成可存储或传输的过程称之为序列化</p>
<p>将变量内容从序列化的对象写到内存里的过程为反序列化</p>
<h4 id="一作用">（一）作用</h4>
<h5 id="1-数据校验">1. 数据校验</h5>
<pre><code>	判断用户输入的数据是否合法
</code></pre>
<h5 id="2-数据转换">2. 数据转换</h5>
<pre><code>	反序列化输入 —— 前端字段请求入库

				数据格式(json、xml、text)  =&gt; 程序中的数据类型（保存、更新数据）

	序列化输出 —— 数据库字段返回给前端

				程序中的数据类型  =&gt; 数据格式（前端可处理的数据，如json）
</code></pre>
<h4 id="二使用">（二）使用</h4>
<h5 id="1-定义序列化器类">1. 定义序列化器类</h5>
<ul>
<li></li>
</ul>
<p>继承Serializer</p>
<ul>
<li></li>
</ul>
<p>序列化器类字段名要与模型类中的字段名相同</p>
<ul>
<li></li>
</ul>
<p>序列化器类中定义的字段，如无特殊约束，必须传参，同时也都会返回</p>
<ul>
<li></li>
</ul>
<p>序列化器类的字段类型：CharField、BooleanField、IntegerField等要与模型类中的字段对应</p>
<pre><code class="language-python">from rest_framework import serializers

class ProjectModelSerializer(serializers.Serializer):
    name = serializers.CharField(max_length=200, label='项目名称', help_text='项目名称', read_only=True)
	desc = serializers.CharField(max_length=200, label='项目简介', help_text='项目简介', allow_null=True, allow_blank=True, default='项目简介')
  update_time = serializers.DateTimeField(label='更新时间', help_text='更新时间', required=False)
</code></pre>
<p>字段参数设置：</p>
<p>选项参数</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">max_length</td>
<td>最大长度</td>
</tr>
<tr>
<td style="text-align:left">min_length</td>
<td>最小长度</td>
</tr>
<tr>
<td style="text-align:left">allow_blank</td>
<td>是否允许为空（字段不传）</td>
</tr>
<tr>
<td style="text-align:left">trim_whitespace</td>
<td>是否截断空白字符</td>
</tr>
<tr>
<td style="text-align:left">max_value</td>
<td>最大值</td>
</tr>
<tr>
<td style="text-align:left">min_value</td>
<td>最小值</td>
</tr>
</tbody>
</table>
<pre><code>	通用参数
</code></pre>
<table>
<thead>
<tr>
<th>参数名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>required</td>
<td style="text-align:left">默认为None，指定前端必须传该字段，如果为False，则参数可以为空（与read_only不可同时设置）</td>
</tr>
<tr>
<td>read_only</td>
<td style="text-align:left">仅用于序列化输出，默认为False，若为True，则该字段在反序列化输入时可不用传，若传入字段也不做校验</td>
</tr>
<tr>
<td>write_only</td>
<td style="text-align:left">仅用于反序列化输入，默认为False，若为True，则该字段必传，但不会输出（与read_only不可同时设置）</td>
</tr>
<tr>
<td>default</td>
<td style="text-align:left">前端不传参，则使用默认值</td>
</tr>
<tr>
<td>allow_null</td>
<td style="text-align:left">指定传参时参数可以为空值，默认为False</td>
</tr>
<tr>
<td>validators</td>
<td style="text-align:left">字段指定校验器</td>
</tr>
<tr>
<td>error_messages</td>
<td style="text-align:left">设置错误信息，key为校验的参数名，value为校验失败后的返回信息，如：error_messages={&quot;required&quot;: &quot;该字段必填&quot;}</td>
</tr>
<tr>
<td>label</td>
<td style="text-align:left">与模型类中的verbose_name作用相同，HTML展示API页面时显示的字段名称</td>
</tr>
<tr>
<td>help_text</td>
<td style="text-align:left">与模型类中的help_text作用相同，HTML展示API页面时显示的字段帮助提示信息</td>
</tr>
</tbody>
</table>
<h5 id="2-序列化器操作">2. 序列化器操作</h5>
<h6 id="创建序列化器对象">· 创建序列化器对象</h6>
<pre><code>	①传递数据：序列化器类(dict_data)

				传入字典，将模型类对象转化为python中的数据类型，进行数据校验，生成数据模型，作用是反序列化输入
</code></pre>
<pre><code class="language-python">serializer_obj = InterfacesModelSerializer(data=request.data)
</code></pre>
<pre><code>	②获取数据：序列化器类(instance=模型类对象/查询集, many=True)

				传入模型类对象或查询集，作用是序列化输出
</code></pre>
<pre><code class="language-python">serializer_obj = InterfacesModelSerializer(instance=inter_obj, data=request.data, partial=True)
</code></pre>
<pre><code>				如果未传递many=True，则序列化器对象返回字典，否则返回嵌套字典的列表
</code></pre>
<pre><code class="language-python">serializer_obj = InterfacesModelSerializer(instance=qs, many=True)
</code></pre>
<h6 id="数据校验">· 数据校验</h6>
<pre><code>1）校验器的使用

		在定义序列化器字段时，使用参数validators=[ ]，添加一个或多个校验器，指定校验规则

		validators列表中的校验规则会全部执行，即使其中有校验失败项

2）校验器的种类

    ① 定义在filed中的参数，如：max_length,、min_length、required...

    ② drf自带校验规则，如：UniqueValidator(查询集, message='xxx不能重复')

    ```python
    from rest_framework import validators

    # 校验名称是否已存在
    name = serializers.CharField(max_length=10, label='接口名称', help_text='接口名称', validators=[
        validators.UniqueValidator(queryset=Interfaces.objects.all(), message='接口名称已存在')])
    ```

    ③ 自定义校验器

    在序列化器类外部定义校验器
</code></pre>
<pre><code class="language-python"># 校验名称中是否包含‘x’
# 如果校验失败，一定要抛出ValidationError，并给出报错信息
def is_name_contain_x(value):
    if 'x' in value:
        raise serializers.ValidationError(&quot;接口名称中不能包含'X'&quot;)
</code></pre>
<pre><code>		④ 单字段校验

		在序列化器类中对单字段进行校验
</code></pre>
<pre><code class="language-python"># 校验器名称必须为validate_字段名
# 必须返回校验后的值
def validate_name(self, value):
    if '-' in value:
        raise serializers.ValidationError(&quot;接口名称中不能包含'-'&quot;)
    return value
</code></pre>
<pre><code>    ⑤ 多字段联合校验

    在序列化器类中对多字段进行校验
</code></pre>
<pre><code class="language-python"># 函数名固定为
# 必须返回attrs
def validate(self, attrs):
    if attrs['password'] != attrs['confirm_password']:
        raise serializers.ValidationError('输入密码与确认密码不一致')
    return attrs
</code></pre>
<pre><code>			联合校验失败时，默认会将 &quot;non_field_error&quot;作为key，返回报错信息

			可在全局settings.py中的REST_FRAMEWORK修改DRF的配置
</code></pre>
<pre><code class="language-python"># 校验失败时，以'error_message'作为key
REST_FRAMEWORK = {
    # 'NON_FIELD_ERRORS_KEY': 'non_field_errors',
    'NON_FIELD_ERRORS_KEY': 'error_message',
}
</code></pre>
<pre><code>	3）序列化器的校验顺序

		字段定义时的校验（校验参数 —&gt; validators参数校验列表） —&gt; 单字段校验 —&gt; 多字段校验

		检验不通过，则不会继续之后的校验

	4）数据的校验

	开始校验：serializer_obj.is_valid()

	.is_valid(raise_exception=True)：若验证错误，则抛出 serializers.ValidationError

	.data：最原始的没有经过验证的数据（通常校验通过后，返回该数据）

	必须先执行is_valid()之后才能访问：

			.errors：校验失败的信息

			.vaildated_data：校验通过后的数据
</code></pre>
<pre><code class="language-python"># 校验失败，返回校验失败的信息，否则返回校验通过的数据
try:
    serializer_obj.is_valid(raise_exception=True)
except Exception as e:
    res.update(serializer_obj.errors)
    return JsonResponse(res, status=400)
</code></pre>
<h6 id="数据的增-查-改">· 数据的增、查、改</h6>
<p>1）只涉及到数据的校验，无需对模型进行修改（create）</p>
<pre><code>		创建序列化器对象：序列化器类(dict_data)

		开始校验数据：序列化对象.is_valid()

		获取错误信息：序列化对象.errors

		校验成功后，对数据进行修改：序列化对象.save()

				执行save()时，传递的关键字参数，会自动添加到create()的validated_data中，如：创建数据时，同时给出创建者的姓名：序列化对象.save(user='xxx')

		获取校验成功后的数据：序列化对象.data / 序列化对象.validated_data
</code></pre>
<p>2）只获取数据库中的数据（search）</p>
<pre><code>		创建序列化器对象：

				序列化器类(instance=模型类对象)

				序列化器类(instance=查询集, many=True)

				序列化器类(instance=普通对象)

		序列化输出：序列化对象.data
</code></pre>
<pre><code class="language-python">    # 查询接口信息：id默认为空
    def get(self, request, pk=None):
        res = {}
        try:
            if pk:
                # 查询接口详情以及所属项目信息
                inter_obj = Interfaces.objects.get(id=pk)
                serializer_obj = InterfacesSerializer(instance=inter_obj)
                projects_info = self.get_project_info(serializer_obj.data['projects'])
                res['data'] = serializer_obj.data
                res['data']['projects'] = projects_info
            else:
                # 查询接口列表
                inter_obj = Interfaces.objects.all()
                serializer_obj = InterfacesSerializer(instance=inter_obj, many=True)
                res['data'] = serializer_obj.data
            res['code'] = 0
            res['message'] = '查询接口信息成功'
        except Exception as e:
            res['code'] = 1
            res['message'] = f'查询接口信息失败：{e}'
        return JsonResponse(data)
</code></pre>
<p>3）既需要做数据校验，也需要修改数据库中的数据（update）</p>
<pre><code>		创建序列化器对象：

				序列化器类(instance=模型类对象, data=dict_data)

		开始校验数据：序列化对象.is_valid()

		获取错误信息：序列化对象.errors

		校验成功后，对数据进行修改：序列化对象.save()（根据是否有instance传参，判断是更新还是创建操作）

		获取校验成功后的数据：序列化对象.data / 序列化对象.validated_data
</code></pre>
<h4 id="三modelserializer">（三）ModelSerializer</h4>
<pre><code>1. 目的：为了简化序列化器类的定义

2. 功能：

		基于模型类自动生成一系列字段

		基于模型类自动为Serializer生成validators，如：unique_together

		包含默认的create()和update()的实现
</code></pre>
<ol start="3">
<li></li>
</ol>
<p>ModelSerializer定义的字段若与模型类字段同名，会覆盖原有的模型类字段</p>
<ol start="4">
<li></li>
</ol>
<p>ModelSerializer可以基于模型类自动生成validators，如：unique_together</p>
<ol start="5">
<li></li>
</ol>
<p>模型序列化器类中的Meta类</p>
<pre><code class="language-python">class Meta:
    # model类属性：在Meta内部类中指定具体的模型类
    # fields类属性 指定模型类中需要输入或输出的字段
    # 默认id主键会自动添加read_only=True
    # create_time、update_time自动添加read_only=True
    model = Interfaces
    # 将模型类的所有字段都声明到模型序列化器中
    # fields = '__all__'
    # 可以将需要/输出的字段放在fields元组中，在序列化器中定义的所有字段必须添加到fields中
    fields = ('id', 'name', 'tester', 'desc', 'email', 'projects')
    # 把需要排除的字段放在exclude中，既不参与输入，也不参与输出
    # exclude = ('desc',)
    # 可以在read_only_fields中指定只输出，不输入的字段
    read_only_fields = ('id',)
    # 可以在extra_kwargs属性中定制某些字段，可以覆盖，也可以新增，序列化器中定义的字段优先级最高
    extra_kwargs = {
        'tester': {
            'label': '测试负责人',
            'write_only': False,
            'max_length': 10,
            'min_length': 1
        },
        'name': {
            'max_length': 10,
            'min_length': 2,
            'label': '接口名称',
            'help_text': '接口名称',
            'validators': [validators.UniqueValidator(queryset=Interfaces.objects.all(), message='接口名称已存在')]
        }
    }
</code></pre>
<ol start="6">
<li></li>
</ol>
<p>ModelSerializer和Serializer的区别</p>
<p>①字段的定义</p>
<pre><code>Serializer：需手动定义序列化器字段，与模型类字段匹配

ModelSerializer：基于模型类自动生成一系列字段
</code></pre>
<p>②数据的创建或更新</p>
<pre><code>Serializer：需重写create/update方法，完成数据的创建/更新

ModelSerializer：包含create/update方法，无需重写
</code></pre>
<p>③字段校验</p>
<pre><code>Serializer：需手动指定校验器，如：validators=[validators.UniqueValidator()]

ModelSerializer：可基于模型类自动生成某些validators，如：unique_together
</code></pre>
<pre><code class="language-python"># 使用模型序列化器
def get(self, request, pk=None):
    qs = Interfaces.objects.all()
    serializer_obj = InterfacesModelSerializer(instance=qs, many=True)
    return JsonResponse(serializer_obj.data, safe=False)
</code></pre>
<h4 id="四关联字段序列化">（四）关联字段序列化</h4>
<pre><code>1. 子表关联父表

	PrimaryKeyRelatedField：将父表的主键id返回

	StringRelatedField：将父表中对应对象的**str**方法结果返回

	SlugRelatedField：指定序列化输出时返回的父表某个字段值

	关联对象的序列化器：xxxModelSerializer，可以将某个序列化器对象定义为字段，支持Field中的所有参数
</code></pre>
<pre><code># PrimaryKeyRelatedField：将父表的主键id返回
# 此处的字段名一定要与模型中的字段名一致
projects = serializers.PrimaryKeyRelatedField(read_only=True)

# StringRelatedField：将父表中对应对象的__str__方法结果返回
# projects = serializers.StringRelatedField()

# serializers.SlugRelatedField：指定序列化输出时返回的父表某个字段值
# projects = serializers.SlugRelatedField(slug_field='tester', read_only=True)

# ProjectModelSerializer：将某个序列化器对象定义为字段，字典形式返回父序列化器所有字段
projects = ProjectModelSerializer(label='所属项目信息', help_text='所属项目信息', read_only=True)
</code></pre>
<ol start="2">
<li></li>
</ol>
<p>父表关联子表</p>
<p>父表中默认不会生成关联字段(从表字段)，可手动指定</p>
<pre><code># 默认可以使用子表名模型类名小写_set
# interfaces_set = InterfacesModelSerializer(label='拥有的接口', many=True)
# 如果某个字段返回的结果有多条，需要添加many=True
# interfaces_set = serializers.PrimaryKeyRelatedField(many=True)
# 如果模型类中外键字段定义了related_name，则会使用该名称作为字段名
# interface = serializers.StringRelatedField(many=True)
</code></pre>
<h3 id="痛点">痛点</h3>
<pre><code>· 仅支持json格式传参，不支持form表单传参

· 仅能返回json格式数据，其他类型不支持

· 对于模型类的获取，仍然有冗余
</code></pre>
<h3 id="类视图">类视图</h3>
<h4 id="一apiview">（一）APIView</h4>
<h5 id="1-特性">1. 特性</h5>
<pre><code>继承了Django中的View，进行了拓展，是可浏览的API页面

具备认证、授权、限流、不同请求数据的解析
</code></pre>
<h5 id="2-apiview与view的不同">2. APIView与View的不同</h5>
<pre><code>1）传入到视图方法中的是Request对象，而不是Django中的HttpRequest对象

2）视图方法可以返回Response对象，会为响应数据处理（render）为符合前端要求的格式

3）任何APIException异常都会被捕获到，并且处理成合适的响应信息

4）在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制
</code></pre>
<h5 id="3-常用类属性">3. 常用类属性</h5>
<pre><code>authentication_classes	列表或元组，身份认证类

permission_classes	列表或元组，权限检查类

throttle_classes	列表或元组，流量控制类
</code></pre>
<h5 id="4-request">4. Request</h5>
<pre><code>1）对Django中的HttpRequest进行了拓展
</code></pre>
<p>接收到请求后会根据请求头中的Content-Type，自动进行解析，解析为字典形式保存到Request对象</p>
<p>无论前端发送哪种格式的数据，都可以以统一的方式读取</p>
<pre><code>2）.data —— 获取json格式的参数、form表单的参数、files（类似于.body 、.POST、.FILES ）
</code></pre>
<p>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</p>
<p>可以对POST、PUT、PATCH的请求体参数进行解析</p>
<p>Render类	Parse解析类</p>
<pre><code>3）.query_params —— 获取查询字符串参数（类似于.GET ）

4）支持Django HttpRequest中所有的对象和方法
</code></pre>
<h5 id="5-response">5. Response</h5>
<pre><code>1）对Django中的HTTPResponse进行了拓展

2）请求头中的Accept默认为：application/json，浏览器访问时自动设置为：text/html，返回html页面

3）指定响应默认渲染类
</code></pre>
<pre><code class="language-python"># 在全局settings中的REST_FRAMEWORK修改DRF的配置
# DRF框架所有的全局配置都放在REST_FRAMEWORK字典中

REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        # 按列表中的元素顺序排优先级
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
}
</code></pre>
<pre><code>4）Response参数
</code></pre>
<pre><code class="language-python">Response(data, status=None, template_name=None, headers=None, content_type=None)
</code></pre>
<ul>
<li></li>
</ul>
<p>data</p>
<pre><code>序列化处理后的数据

一般为serializer.data（python基本数据类型、字典、嵌套字典的列表）
</code></pre>
<ul>
<li></li>
</ul>
<p>status</p>
<pre><code>状态码，默认为200
</code></pre>
<ul>
<li></li>
</ul>
<p>template_name</p>
<pre><code>模板名称，使用HTMLRenderer渲染时需指明
</code></pre>
<ul>
<li></li>
</ul>
<p>headers</p>
<pre><code>请求头
</code></pre>
<ul>
<li></li>
</ul>
<p>content_type</p>
<pre><code>响应头中的content_type

通常该参数无需设置，会自动根据前端所需类型数据来设置参数
</code></pre>
<h4 id="二genericapiview">（二）GenericAPIView</h4>
<p>GenericAPIView为APIView的子类，拓展了过滤、查询、分页的功能</p>
<h5 id="1-前提">1. 前提</h5>
<pre><code>1）安装过滤引擎 pip install django-filter

2）必须指定的属性（继承APIView所用）

		queryset：定义查询集

		serializer_class：声明模型序列化器类
</code></pre>
<h5 id="2-过滤">2. 过滤</h5>
<pre><code>指定过滤引擎：filter_backends

指定过滤字段：filterset_fields
</code></pre>
<p>· settings.py</p>
<pre><code class="language-python"># 在全局settings.py中指定过滤引擎
# 添加应用
INSTALLED_APPS = [
    'django_filters',
]
# 配置DRF
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BANKENDS': [
   'django_filters.rest_framework.backends.DjangoFilterBackend'
    ],
}
</code></pre>
<p>· views.py</p>
<pre><code class="language-python">from django_filters.rest_framework import DjangoFilterBackend

# 在filter_backends指定过滤引擎
filter_backends = [DjangoFilterBackend]
# 指定需要过滤的字段
filter_fields = ['name', 'tester', 'id']
</code></pre>
<p>URL访问：</p>
<pre><code>name=test1：/?name=test1
</code></pre>
<h5 id="3-排序">3. 排序</h5>
<pre><code>指定过滤引擎：filter_backends

指定排序字段：ordering_fields
</code></pre>
<p>· settings.py</p>
<pre><code class="language-python"># 在全局settings.py中指定排序引擎
# 配置DRF
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BANKENDS': [
        'rest_framework.filters.OrderingFilter'
    ],
}
</code></pre>
<p>· views.py</p>
<pre><code class="language-python">from rest_framework.filters import OrderingFilter

# 在filter_backends指定排序引擎
filter_backends = [OrderingFilter]
# 指定排序字段
ordering_fields = ['name', 'id', 'create_time']
</code></pre>
<p>URL访问：</p>
<pre><code>升序：/?ordering=name&amp;id

降序：/?ordering=-name
</code></pre>
<h5 id="4-分页">4. 分页</h5>
<pre><code>指定分页引擎：pagination_class
</code></pre>
<p>· settings.py</p>
<pre><code class="language-python"># 在全局settings.py中指定分页引擎
# 配置DRF
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': [
        # 使用默认的分页引擎
        'rest_framework.pagination.PageNumberPagination',
        # 指定每页展示数据的条数
        'PAGE_SIZE': 5
    ],
}
</code></pre>
<p>重新定义分页引擎</p>
<pre><code>创建一个新目录utils，用于存放自定义模块，继承PageNumberPagination，重新定义分页引擎

当自定义分页引擎与settings.py中分页引擎同时存在时，自定义的优先级更高
</code></pre>
<pre><code class="language-python">from rest_framework.pagination import PageNumberPagination


class MyPagination(PageNumberPagination):
	# 指定默认每一页的数据条数
	page_size = 4
	# 设置当前页码的查询字符串key名称，不设置则默认key值为page
	page_query_param = 'p'
	# 设置每页显示的数据条数的查询字符串key名称，不设置则无法指定每页显示的数据量
	page_size_query_param = 's'
    # 指定每一页数据条数的最大限制
	max_page_size = 50
</code></pre>
<h5 id="示例">示例</h5>
<h6 id="1过滤分页排序查询">1）过滤+分页+排序查询</h6>
<p>get_queryset()：获取查询集</p>
<p>filter_queryset()：对查询集进行过滤，并返回一个查询集</p>
<p>paginate_queryset()：对查询集进行分页</p>
<pre><code class="language-python">from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import OrderingFilter
# 导入自定义的分页引擎
from utils.pagination import MyPagination

class InterfacesInfo(GenericAPIView):
	# 指定过滤引擎
	filter_backends = [DjangoFilterBackend, OrderingFilter]
	# 指定需要过滤的字段
	filter_fields = ['name', 'tester', 'id']
	# 指定排序字段
	ordering_fields = ['name', 'id']
	# 在特定视图中指定分页引擎类（有些视图需要分页，有些不需要）
	pagination_class = MyPagination

	queryset = Interfaces.objects.all()
	serializer_class = InterfacesModelSerializer

    # 查询接口
    def get(self, request, *args, **kwargs):
        # 传递查询集对象给filter_queryset()
        qs = self.filter_queryset(self.get_queryset())
        page = self.paginate_queryset(qs)
        # 判断是否指定分页引擎
        if page is not None:
            # 调用序列化器，获取数据
            serializer_obj = self.get_serializer(instance=page, many=True)
            # 将数据进行分页
            return self.get_paginated_response(serializer_obj.data)
        serializer_obj = self.get_serializer(instance=qs, many=True)
        return Response(serializer_obj.data, status=status.HTTP_200_OK)
</code></pre>
<h6 id="2查询详情数据">2）查询详情数据</h6>
<p>get_object()：获取url中的id，返回模型类对象</p>
<p>get_serializer()：返回序列化器类</p>
<pre><code class="language-python">class ProjectsDetail(GenericAPIView):
    queryset = Projects.objects.all()
    serializer_class = ProjectModelSerializer

    # 查询项目：id默认为空，id为空时，查询所有项目，否则查询指定项目详情
    def get(self, request, pk):
        obj = self.get_object()
        serializer_obj = self.get_serializer(instance=obj)
        return Response(serializer_obj.data, status=status.HTTP_200_OK)

    # 创建项目：数据以json格式传入
    def post(self, request):
        serializer_obj = self.get_serializer(data=request.data)
        serializer_obj.is_valid(raise_exception=True)
        serializer_obj.save()
        return Response(serializer_obj.data, status=status.HTTP_200_OK)

    # 更新项目：传入需更新记录的id，修改数据以json形式传入
    def put(self, request, pk):
        obj = self.get_object()
        serializer_obj = self.get_serializer(instance=obj, data=request.data)
        # 在视图中抛出的异常，DRF会自动处理，报错信息以json格式返回
        serializer_obj.is_valid(raise_exception=True)
        serializer_obj.save()
        return Response(serializer_obj.data, status=status.HTTP_201_CREATED)

    # 删除项目：传入需删除记录的id
    def delete(self, requset, pk):
        obj = self.get_object()
        obj.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
</code></pre>
<ul>
<li></li>
</ul>
<h6 id="genericapiview的特性">GenericAPIView的特性</h6>
<pre><code>1）GenericAPIView继承了APIView，实现了过滤、排序、分页的功能

2）增加了对于列表视图和详情视图可能用到的通用支持方法， 每个具体通用视图都是一个GenericAPIView搭配一个或多个Mixin扩展类

3）支持的属性
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>queryset</td>
<td>指定列表视图的查询集</td>
</tr>
<tr>
<td>serializer_class</td>
<td>指定视图使用的序列化器</td>
</tr>
<tr>
<td>pagination_class</td>
<td>指定分页引擎</td>
</tr>
<tr>
<td>filter_backends</td>
<td>指定过滤引擎</td>
</tr>
<tr>
<td>lookup_field</td>
<td>查询单一数据库对象时使用的条件字段，默认为'pk'，可以指定为'id'</td>
</tr>
<tr>
<td>lookup_url_kwarg</td>
<td>查询单一数据时URL中的参数关键字名称，默认与look_field相同</td>
</tr>
</tbody>
</table>
<pre><code>4）提供的方法
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>get_object</td>
<td>返回模型类数据对象（单条详情数据）</td>
</tr>
<tr>
<td>get_queryset(qs)</td>
<td>返回查询集</td>
</tr>
<tr>
<td>get_serializer</td>
<td>返回序列化器对象</td>
</tr>
<tr>
<td>filter_queryset</td>
<td>对查询集进行过滤</td>
</tr>
<tr>
<td>paginate_queryset</td>
<td>对查询集进行分页</td>
</tr>
</tbody>
</table>
<ul>
<li></li>
</ul>
<h6 id="痛点-2">痛点</h6>
<p>GenericAPIView和APIView只支持对get、post、put、delete、patch等请求方法</p>
<p>如果要支持action：list、create、update、delete等，需继承视图集：ViewSet</p>
<h4 id="三mixin">（三）Mixin</h4>
<h5 id="拓展类">拓展类</h5>
<ul>
<li></li>
</ul>
<p>RetrieveModelMixin</p>
<p>提供 retrieve(request, *args, **kwargs) 方法，获取详情数据</p>
<p>获取成功，返回 200 OK，否则返回 404 Not Found</p>
<ul>
<li></li>
</ul>
<p>ListModelMixin</p>
<p>提供 list(request, *args, **kwargs) 方法，获取列表数据</p>
<p>获取成功，返回 200 OK，否则返回 404 Not Found</p>
<ul>
<li></li>
</ul>
<p>CreateModelMixin</p>
<p>提供 create(request, *args, **kwargs) 方法，创建数据</p>
<p>获取成功，返回 200 OK；请求参数有误，返回 400 Bad Request</p>
<ul>
<li></li>
</ul>
<p>UpdateModelMixin</p>
<p>提供 update(request, *args, **kwargs) 方法，全更新</p>
<p>提供 partial_update(request, *args, **kwargs) 方法，部分更新，支持PATCH方法</p>
<p>更新成功，返回 200 OK</p>
<p>请求参数有误，返回 400 Bad Request；不存在，返回 404 Not Found</p>
<ul>
<li></li>
</ul>
<p>DestoryModelMixin</p>
<p>提供 destory(request, *args, **kwargs) 方法，删除数据</p>
<p>删除成功，返回 204 No Content，不存在，返回 404 Not Found</p>
<p>示例</p>
<pre><code class="language-python"># 先继承DRF中的Mixin拓展类，最后继承GenericAPIView
class ProjectInfo(mixins.ListModelMixin, mixins.CreateModelMixin, 
                  mixins.UpdateModelMixin, mixins.DestroyModelMixin, GenericAPIView):
    
    queryset = Projects.objects.all()
    serializer_class = ProjectModelSerializer

    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filter_fields = ['name', 'tester', 'id']
    ordering_fields = ['name', 'id']

    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
</code></pre>
<h4 id="四concrete-generic-views">（四）Concrete Generic Views</h4>
<h5 id="拓展类-2">拓展类</h5>
<ul>
<li></li>
</ul>
<p>RetrieveApIView</p>
<p>提供：get方法</p>
<p>继承：RetrieveModelMixin、GenericAPIView</p>
<ul>
<li></li>
</ul>
<p>UpdateApIView</p>
<pre><code>	提供：put、patch方法

	继承：UpdateModelMixin、GenericAPIView
</code></pre>
<ul>
<li>
<p>DestoryApIView</p>
<pre><code>  提供：delete方法

  继承：DestoryModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>ListAPIView</p>
<pre><code>  提供：get方法

  继承：ListModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>CreateAPIView</p>
<pre><code>  提供：post方法

  继承：CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>ListCreateApIView</p>
<pre><code>  提供：post、get方法

  继承：ListModelMixin、CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveUpdateApIView</p>
<pre><code>  提供：get、put、patch方法

  继承：ListModelMixin、CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>ListCreateApIView</p>
<pre><code>  提供：ge、createt方法

  继承：ListModelMixin、CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveUpdateApIView</p>
<pre><code>  提供get、put、patch方法

  继承：RetrieveModelMixin、UpdateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveDestoryApIView</p>
<pre><code>  提供get、delete方法

  继承：RetrieveModelMixin、DestoryModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveUpdateDestoryApIView</p>
<pre><code>  提供get、put、patch、delete方法

  继承：RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin、GenericAPIView
</code></pre>
</li>
</ul>
<h5 id="痛点-3">痛点</h5>
<pre><code>列表视图和详情视图无法合并

两个类视图中，有相同的get方法，会冲突

两个类视图所对应的url地址不一致
</code></pre>
<h4 id="五viewset">（五）ViewSet</h4>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>动作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>retrieve</td>
<td>获取详情数据（单条）</td>
</tr>
<tr>
<td>GET</td>
<td>list</td>
<td>获取列表数据（多条）</td>
</tr>
<tr>
<td>POST</td>
<td>create</td>
<td>创建数据</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
<td>更新数据</td>
</tr>
<tr>
<td>PATCH</td>
<td>partial_update</td>
<td>部分更新</td>
</tr>
<tr>
<td>DELTE</td>
<td>destory</td>
<td>删除数据</td>
</tr>
</tbody>
</table>
<h5 id="viewset">ViewSet</h5>
<pre><code>继承ViewSetMixin和Views.APIView

ViewSetMixin支持action动作

未提供get_object()、get_serializer()、queryset、serializer_class等
</code></pre>
<h5 id="genericviewset">GenericViewSet</h5>
<pre><code>继承ViewSetMixin和generics.GenericAPIView

提供get_object()、get_serializer()、queryset、serializer_class等

在定义路由时，需将请求方法与action动作进行绑定

使用Mixins类简化程序
</code></pre>
<ul>
<li></li>
</ul>
<h6 id="viewset与genericviewset的区别">ViewSet与GenericViewSet的区别</h6>
<table>
<thead>
<tr>
<th>ViewSet</th>
<th>GenericViewSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承：(ViewSetMixin, Views.APIView)</td>
<td>继承：(ViewSetMixin, generics.GenericAPIView)</td>
</tr>
<tr>
<td>未提供通用View的方法集：get_object()、get_serializer()、queryset、serializer_class等</td>
<td>包含基本的通用View的方法集：get_object()、get_serializer()、queryset、serializer_class等</td>
</tr>
<tr>
<td>支持action动作</td>
<td>在定义路由时，需将请求方法与action动作进行映射</td>
</tr>
</tbody>
</table>
<h5 id="modelviewset">ModelViewSet</h5>
<p>继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin</p>
<p>支持的Action</p>
<pre><code>列表视图：list、create

详情视图： retrieve、 update、destory
</code></pre>
<p>urls.py</p>
<pre><code class="language-python"># 继承ViewSet后，支持在路由表中指定请求方法与action的映射
# as_view接收一个字典，key为请求方法，value为请求动作
urlpatterns = [
	path('projects/', views.ProjectViewSet.as_view({
		'get': 'list', 'post': 'create'
	})),
	path('projects/&lt;int:pk&gt;', views.ProjectViewSet.as_view({
		'get': 'retrieve', 'put': 'update', 'delete': 'destory'
	})),
]
</code></pre>
<p>views.py</p>
<pre><code class="language-python">from rest_framework.filters import OrderingFilter
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import viewsets
from .models import Projects
from .serializers import ProjectModelSerializer


class ProjectViewSet(viewsets.ModelViewSet):
    queryset = Projects.objects.all()
    serializer_class = ProjectModelSerializer

    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filter_fields = ['name', 'tester', 'id']
    ordering_fields = ['name', 'id']
</code></pre>
<h5 id="readonlymodelviewset">ReadOnlyModelViewSet</h5>
<pre><code>继承ListModelMixin、RetrieveModelMixin、GenericAPIView
</code></pre>
<h4 id="action">action</h4>
<p>使用action装饰器：@action(methods, detail)</p>
<pre><code>methods：支持的请求方式

					默认值为['get']，可定义多个请求方式['get', 'post', 'put']

detail：声明要处理的是否是详情资源对象（通过url路径获取主键）

	True 表示使用通过URL获取的主键对应的数据对象

	False 表示不使用URL获取主键
</code></pre>
<pre><code class="language-python">from rest_framework.decorators import action

# 可以使用action装饰器自定义动作
# 默认methods参数为['get']，可定义多个请求方式['get', 'post', 'put']
# detail为必填参数，指定是否为详情数据，如需要传递主键ID，则detail=True，否则为列表数据，detail=False
# url_path指定url路径部分，默认为action名称
# url_name指定url的名称，默认为action名称(当前为names，完整的路由名称为/names-list)
@action(methods=['get'], detail=False, url_path='test')
def names(self, requset, *args, **kwargs):
   qs = self.filter_queryset(self.get_queryset())
   serializer_obj = self.get_serializer(instance=qs, many=True)
   return Response(serializer_obj.data)
</code></pre>
<h4 id="router">router</h4>
<pre><code class="language-python">from rest_framework.routers import DefaultRouter, SimpleRouter

# 1. 定义路由对象
router = SimpleRouter()
router = DefaultRouter()
# 2. 使用路由对象，调用register()，进行注册
# 第一个参数指定路由前缀，子应用名称；第二个参数，指定视图集类，无需调用.as_view()
router.register(r'projects', views.ProjectViewSet)
# 使用路由对象.urls属性来获取自动生成的路由条目，往往为列表
# 需要将列表添加到urlpatterns
urlpatterns = [
   # name可以指定路由名称
   path('projects', views.ProjectViewSet.as_view(), name='')
]
urlpatterns += router.urls
</code></pre>
<h3 id="生成api文档">生成API文档</h3>
<h4 id="简介">简介</h4>
<pre><code>生成API文档平台

自动生成测试代码

支持接口测试
</code></pre>
<h4 id="安装-2">安装</h4>
<p>django-rest-swagger、coreapi</p>
<p>可选：Pygments、Markdown</p>
<h4 id="实现">实现</h4>
<h5 id="1-drf-yasg">1. drf-yasg</h5>
<pre><code>安装：pip install drf-yasg

添加到子应用：INSTALLED_APPS = [ 'drf_yasg', ]
</code></pre>
<p>配置urls.py</p>
<pre><code class="language-python">from drf_yasg import openapi 
from drf_yasg.views import get_schema_view 

# 声明schema_view
schema_view = get_schema_view( 
    openapi.Info( 
        title=&quot;Lemon API接口文档平台&quot;, # 必传 
        default_version='v1', # 必传 
        description=&quot;这是一个美轮美奂的接口文档&quot;, 
        terms_of_service=&quot;http://api.keyou.site&quot;, 
contact=openapi.Contact(email=&quot;keyou100@qq.com&quot;),
        license=openapi.License(name=&quot;BSD License&quot;), 
),
    public=True, 
)

# 设置urlpatterns
urlpatterns = [ 
    re_path(r'^swagger(?P&lt;format&gt;\.json|\.yaml)$', 
schema_view.without_ui(cache_timeout=0), name='schema-json'), 
    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'), 
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema- redoc'), ]
</code></pre>
<h5 id="2-coreapi">2. coreapi</h5>
<p>配置全局settings.py</p>
<pre><code class="language-python">REST_FRAMEWORK = {
	'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.coreapi.AutoSchema',
}
</code></pre>
<pre><code class="language-python">from rest_framework.documentation import include_docs_urls
from django.urls import path, include
urlpatterns = [
	path('docs/', include_docs_urls(title='接口测试文档')),
]
</code></pre>
<p>添加注释</p>
<pre><code>单一方法的视图
</code></pre>
<pre><code class="language-python"># 直接在视图类中添加注释
class ProjectsListView(ListAPIView): 
&quot;&quot;&quot; 返回所有项目信息 &quot;&quot;&quot;
</code></pre>
<pre><code>多个方法的视图
</code></pre>
<pre><code class="language-python">class ProjectsListCreateView(ListCreateAPIView): 
&quot;&quot;&quot; 
get: 返回所有项目信息 
post: 新建项目 
&quot;&quot;&quot;
</code></pre>
<pre><code>视图集
</code></pre>
<pre><code class="language-python"> class ProjectsViewset(viewsets.ModelViewSet):
  &quot;&quot;&quot; 
 create: 创建项目 
 retrieve: 获取项目详情数据 
 update: 完整更新项目 
 partial_update: 部分更新项目 
 destroy: 删除项目 
 list: 获取项目列表数据 
 names: 获取所有项目名称 
 interfaces: 获取指定项目的所有接口数据
  &quot;&quot;&quot;
</code></pre>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://grassroadsz.github.io/VkMGKzvHG/">
                  <h3 class="post-title">
                    K8S 单集群部署
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '7d56338c9b683c1db453',
        clientSecret: 'f750ad858d591e21978b5741a92df0a5b8294be9',
        repo: 'grassroadsZ.github.io',
        owner: 'grassroadsZ',
        admin: ['grassroadsZ'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
