<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://grassroadsz.github.io</id>
    <title>grassroadsZ</title>
    <updated>2022-05-28T08:09:20.599Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://grassroadsz.github.io"/>
    <link rel="self" href="https://grassroadsz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://grassroadsz.github.io/images/avatar.png</logo>
    <icon>https://grassroadsz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, grassroadsZ</rights>
    <entry>
        <title type="html"><![CDATA[Git 命令]]></title>
        <id>https://grassroadsz.github.io/kHeewF6F8/</id>
        <link href="https://grassroadsz.github.io/kHeewF6F8/">
        </link>
        <updated>2022-05-28T08:06:00.000Z</updated>
        <content type="html"><![CDATA[<p>名词</p>
<p>master：默认开发分支</p>
<p>origin：默认远程版本库</p>
<p>Index/stage:暂缓区</p>
<p>Workspace：工作区</p>
<p>Repository：仓库区（本地仓库）</p>
<p>Remote：远程仓库</p>
<p>一. 新建代码库</p>
<h1 id="在当前目录新建一个代码仓库">在当前目录新建一个代码仓库</h1>
<pre><code>git init
</code></pre>
<h1 id="新建一个目录将其初始化为-git仓库">新建一个目录，将其初始化为    git仓库</h1>
<pre><code>git init [project-name]
</code></pre>
<h1 id="下载一个项目和它的整个代码历史">下载一个项目和它的整个代码历史</h1>
<pre><code>git clone[url]
</code></pre>
<p>二.配置</p>
<pre><code>git的设置文件为.    gitconfig,它可以在用户主目录下（全局配置）
</code></pre>
<h1 id="显示当前的-git配置">显示当前的    git配置</h1>
<pre><code>git config --list
</code></pre>
<h1 id="编辑-git配置文件">编辑    git配置文件</h1>
<pre><code>git config -e [--global]
</code></pre>
<h1 id="设置提交代码时的用户信息">设置提交代码时的用户信息</h1>
<pre><code>git config [--global]
</code></pre>
<h1 id="设置提交代码时的用户信息-2">设置提交代码时的用户信息</h1>
<pre><code>git config [--global] user.name &quot;[name]&quot;

git config [--global] user.email &quot;email address&quot;
</code></pre>
<p>三.增加/删除/修改文件</p>
<h1 id="查看状态">查看状态</h1>
<pre><code>git status
</code></pre>
<h1 id="查看变更内容">查看变更内容</h1>
<pre><code>git diff
</code></pre>
<h1 id="添加指定文件到暂存区">添加指定文件到暂存区</h1>
<pre><code>git add [file1] [file2]
</code></pre>
<h1 id="添加指定目录到暂缓区包括子目录">添加指定目录到暂缓区，包括子目录</h1>
<pre><code>git add .
</code></pre>
<h1 id="添加每个变化前都会要求确认">添加每个变化前，都会要求确认</h1>
<p>#对于同一个文件的多处变化，可以实现分次提交</p>
<pre><code>git add -p
</code></pre>
<h1 id="删除工作区文件并且将这次删除放入暂缓区">删除工作区文件，并且将这次删除放入=暂缓区</h1>
<pre><code>git rm[file1] [file2]...
</code></pre>
<h1 id="停止追踪指定文件但该文件会保留在工作区">停止追踪指定文件，但该文件会保留在工作区</h1>
<pre><code>git rm --cached [file]
</code></pre>
<h1 id="改名文件并且将这个改名放入暂存区">改名文件，并且将这个改名放入暂存区</h1>
<pre><code>git mv [file-oigin] [file-renamed]
</code></pre>
<p>代码提交</p>
<h1 id="提交暂缓区至仓库区">提交暂缓区至仓库区</h1>
<pre><code>git commit -m [message]
</code></pre>
<h1 id="提交暂缓区的指定文件到仓库区">提交暂缓区的指定文件到仓库区</h1>
<pre><code>git commit [file1] [file2]...m [message]
</code></pre>
<h1 id="提交工作区自上次commit之后的变化直接到仓库区">提交工作区自上次commit之后的变化，直接到仓库区</h1>
<pre><code>git commit -a
</code></pre>
<h1 id="使用一次新的commit替代上一次提交">使用一次新的commit，替代上一次提交</h1>
<h1 id="如果代码没有任何新变化则用来改写上一次commit的提交信息">如果代码没有任何新变化，则用来改写上一次commit的提交信息</h1>
<pre><code>git commit --amend -m [message]
</code></pre>
<h1 id="重做上一次commit并包括指定文件的新变化">重做上一次commit，并包括指定文件的新变化</h1>
<pre><code>git commit --amend [file1] [file2]...
</code></pre>
<p>五.分支</p>
<h1 id="显示所有的本地分支">显示所有的本地分支</h1>
<pre><code>git branch
</code></pre>
<h1 id="列出所有的远程分支">列出所有的远程分支</h1>
<pre><code>git branch -r
</code></pre>
<h1 id="列出所有的本地分支和远程分支">列出所有的本地分支和远程分支</h1>
<pre><code>git branch -a
</code></pre>
<h1 id="新建一个分支但是依然停留在当前分支">新建一个分支，但是依然停留在当前分支</h1>
<pre><code>git branch [branch-name]
</code></pre>
<h1 id="新建一个分支并与指定的远程分支建立追踪关系">新建一个分支，并与指定的远程分支建立追踪关系</h1>
<pre><code>git branch --track [branck] [remote-name]
</code></pre>
<h1 id="删除远程分支">删除远程分支</h1>
<pre><code>git push origin --delete [branch-name]

git branch -dr [remote/branch]
</code></pre>
<h1 id="新建一个分支并切换到该分支">新建一个分支，并切换到该分支</h1>
<pre><code>git checkout -b [branch]
</code></pre>
<h1 id="切换到指定分支并更新工作区">切换到指定分支，并更新工作区</h1>
<pre><code>git checkout [branch-name]
</code></pre>
<h1 id="切换到上一个分支">切换到上一个分支</h1>
<pre><code>git checkout -
</code></pre>
<h1 id="建立追踪关系在现有分支与指定的远程分支之间">建立追踪关系，在现有分支与指定的远程分支之间</h1>
<pre><code>git branch --set-upstream [branch] [remote-branch]
</code></pre>
<h1 id="合并指定分支到当前分支">合并指定分支到当前分支</h1>
<pre><code>git merge [branch]
</code></pre>
<h1 id="衍合指定分支到当前分支">衍合指定分支到当前分支</h1>
<pre><code>git rebase &lt;branch&gt;
</code></pre>
<h1 id="选择一个commit合并到当前分支">选择一个commit，合并到当前分支</h1>
<pre><code>git cherry-pick [commit]
</code></pre>
<p>六. 标签</p>
<h1 id="列出所有本地标签">列出所有本地标签</h1>
<pre><code>git tag
</code></pre>
<h1 id="基于最新提交创建的标签">基于最新提交创建的标签</h1>
<pre><code>git tag &lt;tagname&gt;
</code></pre>
<h1 id="删除标签">删除标签</h1>
<pre><code>git tag -d &lt;tagname&gt;
</code></pre>
<h1 id="删除远程tag">删除远程tag</h1>
<pre><code>git push origin ：refs/tages/[tagename]
</code></pre>
<h1 id="查看tag信息">查看tag信息</h1>
<pre><code>git show [tag]
</code></pre>
<h1 id="提交指定tag">提交指定tag</h1>
<pre><code>git  push [remote] [tag]
</code></pre>
<h1 id="提交所有tag">提交所有tag</h1>
<pre><code>git push [remote] --[tag]
</code></pre>
<h1 id="新建一个分支指向某个tag">新建一个分支，指向某个tag</h1>
<pre><code>git checkout -b [branch] [tag]
</code></pre>
<p>七.查看信息</p>
<h1 id="显示有变更的文件">显示有变更的文件</h1>
<pre><code>git status 
</code></pre>
<h1 id="显示当前分支的版本历史">显示当前分支的版本历史</h1>
<pre><code>git log
</code></pre>
<h1 id="显示commit历史以及每次commit发生变更的文件">显示commit历史，以及每次commit发生变更的文件</h1>
<pre><code>git log --stat
</code></pre>
<h1 id="搜索提交历史根据关键词">搜索提交历史，根据关键词</h1>
<pre><code>git log -s [keyword]
</code></pre>
<h1 id="显示某个commit之后的所有变动每个commit占据一行">显示某个commit之后的所有变动，每个commit占据一行</h1>
<pre><code>git log [tag] HEAD --pretty=format:%s
</code></pre>
<h1 id="显示某个commit之后的所有变动其提交说明必须符合搜索条件">显示某个commit之后的所有变动，其“提交说明”必须符合搜索条件</h1>
<pre><code>git log [tag] HEAD --grep feature
</code></pre>
<h1 id="显示某个文件的版本历史包括文件改名">显示某个文件的版本历史，包括文件改名</h1>
<pre><code>git log --follow [file]
git whatchanged [file]
</code></pre>
<h1 id="显示指定文件相关的每一次diff">显示指定文件相关的每一次diff</h1>
<pre><code>git log -p [file]
</code></pre>
<h1 id="显示过去的5次提交">显示过去的5次提交</h1>
<pre><code>git log -5 --pretty --oneline
</code></pre>
<h1 id="显示所有提交过的用户按提交次数排序">显示所有提交过的用户，按提交次数排序</h1>
<pre><code>git shortlog -sn
</code></pre>
<h1 id="显示指定文件是什么人在什么时间修改过">显示指定文件是什么人在什么时间修改过</h1>
<pre><code>git blame [file]
</code></pre>
<h1 id="显示暂缓区和工作区的差异">显示暂缓区和工作区的差异</h1>
<pre><code>git diff
</code></pre>
<h1 id="显示暂缓区和上一个commit的差异">显示暂缓区和上一个commit的差异</h1>
<pre><code>git diff HEAD
</code></pre>
<h1 id="显示两次提交之间的差异">显示两次提交之间的差异</h1>
<pre><code>git diff [first-branch]...[second-branch]
</code></pre>
<h1 id="显示某次提交发生变化的文件">显示某次提交发生变化的文件</h1>
<pre><code>git show --name-only [commit]
</code></pre>
<p>远程操作</p>
<h1 id="下载远程仓库的所有变动">下载远程仓库的所有变动</h1>
<pre><code>git fetch [remote]
</code></pre>
<h1 id="取回远程仓库的变化并与本地分支合并">取回远程仓库的变化，并与本地分支合并</h1>
<pre><code>git pull [remote] [branch]
</code></pre>
<h1 id="显示所有的远程仓库">显示所有的远程仓库</h1>
<pre><code>git remote -v 
</code></pre>
<h1 id="显示某个远程仓库的信息">显示某个远程仓库的信息</h1>
<pre><code>git remote show [remote]
</code></pre>
<h1 id="增加一个新的远程仓库并命名">增加一个新的远程仓库，并命名</h1>
<pre><code>git remote add [shortname] [url]
</code></pre>
<h1 id="上传本地指定分支到远程仓库">上传本地指定分支到远程仓库</h1>
<pre><code>git push [remote] [branch]
</code></pre>
<h1 id="强行推送当前分支到远程仓库即使有冲突">强行推送当前分支到远程仓库，即使有冲突</h1>
<pre><code>git push [remote] --force
</code></pre>
<h1 id="推送所有的分支到远程仓库">推送所有的分支到远程仓库</h1>
<pre><code>git push [remote] --all
</code></pre>
<p>九.撤销</p>
<h1 id="撤销工作目录中所有未提交文件的修改内容">撤销工作目录中所有未提交文件的修改内容</h1>
<pre><code>git reset --hard HEAD
</code></pre>
<h1 id="撤销指定的未提交文件的修改内容">撤销指定的未提交文件的修改内容</h1>
<pre><code>git  checkout HEAD [file]
</code></pre>
<h1 id="撤销指定的提交">撤销指定的提交</h1>
<pre><code>git revert &lt;commit&gt;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文章迁移]]></title>
        <id>https://grassroadsz.github.io/iRCjGGW61/</id>
        <link href="https://grassroadsz.github.io/iRCjGGW61/">
        </link>
        <updated>2022-05-28T08:03:09.000Z</updated>
        <content type="html"><![CDATA[<p>由于之前服务器到期未进行续费，Halo 博客的数据库也没有备份，避免以后出现这种问题，还是放github吧。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI自动化文件上传]]></title>
        <id>https://grassroadsz.github.io/ui-zi-dong-hua-wen-jian-shang-chuan/</id>
        <link href="https://grassroadsz.github.io/ui-zi-dong-hua-wen-jian-shang-chuan/">
        </link>
        <updated>2022-05-28T06:52:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文链接 https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-upload_file.html#4520068</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>实施UI自动化测试的时候，经常会遇见上传文件的操作，那么对于上传文件你知道几种方法呢？今天我们就总结一下几种常用的上传文件的方法，并分析一下每个方法的优点和缺点以及哪种方法效率，稳定性更高</p>
<h2 id="被测html代码">被测HTML代码</h2>
<figure data-type="image" tabindex="1"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;!--upload_file.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;上传文件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;upload_file&quot; type=&quot;file&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<p>第一种方法：使用webdriver api 提供的方法send_keys上传文件</p>
<h2 id="send_keys方法">send_keys方法</h2>
<h3 id="实例">实例</h3>
<figure data-type="image" tabindex="3"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
&quot;&quot;&quot; 
from selenium import webdriver
import time


driver = webdriver.Firefox()
driver.get(r'file:///e:/CnblogCode/upload_file.html')
upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
time.sleep(3)  # 为了看效果
upload_element.send_keys(r'E:CnblogCodeupload_file.html')
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<h3 id="执行过程">执行过程</h3>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718141749877-90060948.gif" alt="" loading="lazy"></figure>
<p>可以看到执行过程很顺利，且代码实现简单，也没有报错</p>
<p>但是往往现实是残酷的，因为有的网站的上传文件并不是采用 input标签来定义的上传文件按钮，所以就无法使用send_keys方法上传，这也是这个方法的限制</p>
<h2 id="autoit工具">AutoIt工具</h2>
<p>第二种方法是AutoIT工具，它是一个类似脚本语言的软件，利用此软件我们可以方便的实现模拟键盘、鼠标、窗口等操作，实现自动化</p>
<h3 id="安装">安装</h3>
<p>官网地址：<a href="https://www.autoitscript.com/site/autoit/downloads/">https://www.autoitscript.com/site/autoit/downloads/</a></p>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718145953994-1855651642.png" alt="" loading="lazy"></figure>
<p>安装完后可以找到如下一些工具</p>
<figure data-type="image" tabindex="7"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718150114641-2141840187.png" alt="" loading="lazy"></figure>
<h3 id="使用">使用</h3>
<ol>
<li>
<p>打开被测试的HTML页面，并点击上传文件，弹出上传文件窗口，并保持当前窗口</p>
</li>
<li>
<p>打开AutoIt Window Info(x86/x64)工具</p>
</li>
<li>
<p>点击工具中Finder Tool标签下的按钮，开始分别定位上传文件的【输入框】和【打开】按钮，并记录Title，Class，Instance（图中红色窗口中的信息）</p>
</li>
</ol>
<p>注意：不同的浏览器抓取的Title是不一样的（Firefox：文件上传，Chrome：打开，IE：选择要加载的文件)</p>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718150637174-380718539.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>打开 SciTE Script Editor<img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718153911035-1870937893.png" alt="" loading="lazy"><br>
工具开始编写脚本(注意脚本中的Edit1是class 和 instance 拼接的)</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-shell">;first make sure the number of arguments passed into the scripts is more than 1 If $CmdLine[0]&lt;2 Then Exit EndIf ;if parmas num &lt;2 ,then break ;$CmdLine[0] ;参数的数量
;$CmdLine[1] ;第一个参数 (脚本名称后面)
;$CmdLine[2] ;第二个参数
;都是从cmd传入参数
 handleUpload($CmdLine[1],$CmdLine[2])

;定义上传函数，有两个参数，第一个是浏览器名字，第二参数是文件路径
 Func handleUpload($browser, $uploadfile)
     Dim $title                          ;定义一个title变量
            ;根据弹窗的title来判断是什么浏览器
            If $browser=&quot;ie&quot; Then                          ; 代表IE浏览器
                  $title=&quot;选择要加载的文件&quot; ElseIf $browser=&quot;chrome&quot; Then               ; 代表谷歌浏览器
                 $title=&quot;打开&quot; ElseIf    $browser=&quot;firefox&quot; Then             ; 代表火狐浏览器
                  $title=&quot;文件上传&quot; EndIf if WinWait($title,&quot;&quot;,4) Then ;等待弹出出现，最大等待时间是4秒
                   WinActivate($title)                  ;找到弹出窗口之后，激活当前窗口
                   ControlSetText($title,&quot;&quot;,&quot;Edit1&quot;,$uploadfile)   ;把文件路径放入输入框，此”Edit1“是用FinderTool获取到的
                   ControlClick($title,&quot;&quot;,&quot;Button1&quot;)                ;点击保存或者打开或者上传按钮，此“Button1”使用FinderTool获取到的
            Else
            Return False
            EndIf
 EndFunc
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<ol start="5">
<li>编译脚本为exe可执行文件</li>
</ol>
<p>编写完脚本之后，保存文件并打开Compile Script to .exe(x64/x86)工具 <img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718153828567-1147124643.png" alt="" loading="lazy"><br>
，将保存后的脚本.au3文件转换为.exe可执行文件</p>
<ol start="6">
<li>执行转换后的脚本</li>
</ol>
<p>在执行脚本之前，先确保上传文件的窗口已经打开，接下来打开cmd执行exe程序  C:Usersv-xugDesktop&gt;upload_file_new.exe firefox E:CnblogCodeupload_file.html</p>
<ol start="7">
<li>执行效果</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718161454802-676243340.gif" alt="" loading="lazy"></figure>
<ol start="8">
<li>编写selenium脚本</li>
</ol>
<h3 id="实例-2">实例</h3>
<figure data-type="image" tabindex="12"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
from selenium.webdriver.common.action_chains import ActionChains 
import os
from selenium import webdriver
import time 

class Base(object):

    @staticmethod def upload_file(exe, browser, filename): &quot;&quot;&quot; 使用autoIt上传文件
        :param exe: 上传文件的exe程序所在目录
        :param browser: 浏览器类型： firefox chrome ie
        :param filename: 待上传文件路径
        :return: none &quot;&quot;&quot; cmd = exe + ' ' + browser + ' ' + filename
        os.system(cmd) if __name__ == '__main__':
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')  # 打开被测html
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()  # 点击上传文件弹出上传文件窗口
    action.release()
    time.sleep(3)  # 为了看效果
    Base.upload_file(r'E:CnblogCodeupload_file_new.exe', 'firefox', r'E:CnblogCodeupload_file.html')  # 上传文件

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<h3 id="执行过程-2">执行过程</h3>
<figure data-type="image" tabindex="14"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718170623032-66535341.gif" alt="" loading="lazy"></figure>
<p>以上就是使用AutoId工具完成上传文件的过程，其实还是挺复杂的， 但是配置一次之后，以后就可以重复使用编译生成的exe文件了，执行效果还是不错的 没出什么错误，执行效率也还可以</p>
<h2 id="模拟键盘">模拟键盘</h2>
<p>第三种方法：模拟键盘的粘贴与回车操作并结合剪切板的操作来完成上传文件，基本原理是向剪切板中发送文件(文件路径字符串)，然后再从剪切板中获取到文件，最后通过模拟键盘的ctrl+v与enter键来完成文件上传</p>
<p>这种方法需要第三方库的支持，安装pypiwin32库： pip install pypiwin32</p>
<h3 id="实例-3">实例</h3>
<p>模拟键盘操作代码</p>
<figure data-type="image" tabindex="15"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">import win32api import win32con
import time 

class KeyBoard(object): 
    &quot;&quot;&quot;模拟按键&quot;&quot;&quot;
    # 键盘码
    vk_code = { 'enter' : 0x0D, 'ctrl' : 0x11, 'v' : 0x56 }

    @staticmethod def keyDown(key_name): &quot;&quot;&quot;按下键&quot;&quot;&quot; key_name = key_name.lower() try:
            win32api.keybd_event(KeyBoard.vk_code[key_name], 0, 0, 0) except Exception as e: print('未按下enter键') raise e

    @staticmethod def keyUp(key_name): &quot;&quot;&quot;抬起键&quot;&quot;&quot; key_name = key_name.lower()
        win32api.keybd_event(KeyBoard.vk_code[key_name], 0, win32con.KEYEVENTF_KEYUP, 0)

    @staticmethod def oneKey(key): &quot;&quot;&quot;模拟单个按键&quot;&quot;&quot; key = key.lower()
        KeyBoard.keyDown(key)
        time.sleep(2)
        KeyBoard.keyUp(key)

    @staticmethod def twoKeys(key1, key2): &quot;&quot;&quot;模拟组合按键&quot;&quot;&quot; key1 = key1.lower()
        key2 = key2.lower()
        KeyBoard.keyDown(key1)
        KeyBoard.keyDown(key2)
        KeyBoard.keyUp(key1)
        KeyBoard.keyUp(key2) if __name__ == '__main__': pass
</code></pre>
<p>keyboard.py</p>
<p>剪切板操作代码</p>
<figure data-type="image" tabindex="16"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
import win32con 
import win32clipboard as WC 

class ClipBoard(object): 
    &quot;&quot;&quot;设置剪切板内容和获取剪切板内容&quot;&quot;&quot; 
    
    @staticmethod def getText(): &quot;&quot;&quot;获取剪切板的内容&quot;&quot;&quot; 
        WC.OpenClipboard()
        value = WC.GetClipboardData(win32con.CF_TEXT)
        WC.CloseClipboard() return value

    @staticmethod def setText(value): &quot;&quot;&quot;设置剪切板的内容&quot;&quot;&quot; 
        WC.OpenClipboard()
        WC.EmptyClipboard()
        WC.SetClipboardData(win32con.CF_UNICODETEXT, value)
        WC.CloseClipboard() 
if __name__ == '__main__': 
    pass
</code></pre>
<p>clipboard.py</p>
<p>上传文件代码</p>
<figure data-type="image" tabindex="17"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">from clipboard import ClipBoard 
from keyboard import KeyBoard 
from selenium import webdriver 
import time 
from selenium.webdriver.common.action_chains import ActionChains 

if __name__ == '__main__':
    ClipBoard.setText(r'E:CnblogCodeupload_file.html')  # 待上传文件设置到剪切板
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()
    action.release()
    time.sleep(3)  # 为了看效果
    KeyBoard.twoKeys('ctrl', 'v')
    KeyBoard.oneKey('enter')

upload_file_board.py
</code></pre>
<h3 id="执行过程-3">执行过程</h3>
<figure data-type="image" tabindex="18"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718173040775-1045026529.gif" alt="" loading="lazy"></figure>
<p>失败</p>
<figure data-type="image" tabindex="19"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718173123389-1294379262.gif" alt="" loading="lazy"></figure>
<p>可以看到第二个动画上传文件未成功，这也就这个方法的弊端，只要移动了鼠标就有可能就不会成功，毕竟模拟的是enter键，这个过程你点击了别的地方，那么enter的效果就变了，所以这种方法很不稳定，也不难发现，代码量也很多，而且需要掌握模拟键盘和剪切板的操作，最不推荐使用的就是这种方法</p>
<p>之前我的实战项目里面，用到过这种方法， 当时我已经发现了这种方法的弊端， 但是为了掌握这种模拟键盘的方法，所以才使用的，当然模拟键盘操作用到一些特殊的情况还是能解决很多实际问题的</p>
<h2 id="winspy工具">WinSpy工具</h2>
<p>第四种方法：这个工具其实和AutoIt工具的元素定位方式一样，但是不需要生成exe文件，其实只是个辅助工具，主要用来获取windows窗口句柄，进而通过python脚本来控制</p>
<h3 id="winspy安装">WinSpy安装</h3>
<p><a href="https://sourceforge.net/projects/winspyex/">https://sourceforge.net/projects/winspyex/</a></p>
<p>下载完直接解压打开WinSpy32(64).exe即可使用</p>
<p>使用方法和autoId一样，请按照下图的步骤操作，记录winspy-Tree中红框信息</p>
<figure data-type="image" tabindex="20"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718174930856-1995061900.png" alt="" loading="lazy"></figure>
<p>编写代码之前，同样需要提前安装 pypiwin32库</p>
<h3 id="实例-4">实例</h3>
<figure data-type="image" tabindex="21"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">from selenium.webdriver.common.action_chains import ActionChains
from selenium import webdriver
import win32con 
import win32gui 
import time 

def upload_file(browser: str, file: str):
    browser_type = { &quot;firefox&quot;: &quot;文件上传&quot;, &quot;chrome&quot;: &quot;打开&quot;, &quot;ie&quot;: &quot;选择要加载的文件&quot; }
    time.sleep(2)
    dialog = win32gui.FindWindow(&quot;#32770&quot;, browser_type[browser])  # 火狐浏览器为”文件上传“，谷歌为”打开“
    combobox_ex32 = win32gui.FindWindowEx(dialog, 0, &quot;ComboBoxEx32&quot;, None)
    combobox = win32gui.FindWindowEx(combobox_ex32, 0, 'ComboBox', None)
    edit = win32gui.FindWindowEx(combobox, 0, 'Edit', None)
    button = win32gui.FindWindowEx(dialog, 0, 'Button', None)
    win32gui.SendMessage(edit, win32con.WM_SETTEXT, None, file)
    win32gui.SendMessage(dialog, win32con.WM_COMMAND, 1, button) if __name__ == '__main__':
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()
    action.release()
    time.sleep(3)  # 为了看效果
    upload_file('firefox', r'E:CnblogCodeupload_file.html')
</code></pre>
<p>load_file_winspy.py</p>
<h3 id="执行过程-4">执行过程</h3>
<figure data-type="image" tabindex="22"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718175927417-974106887.gif" alt="" loading="lazy"></figure>
<p>此方法也比较稳定，只要通过传递不同的浏览器参数，即可完成不同浏览器中的上传文件操作，而且相比于AutoId而言，这种方法可以直接使用python编写代码且不需要编译成exe程序，可以随时对代码进行修改，易维护</p>
<h2 id="总结">总结</h2>
<p>最后总结一下每个方法的优缺点</p>
<ol>
<li>
<p>send_keys(): 如果所遇见的上传文件使用的是input标签且属性type=file，均可使用，也最好采用此方法，方便，简单，执行效率高</p>
</li>
<li>
<p>AutoId： 需编写VBS代码并编译为exe可执行文件，过程繁琐，编写selenium测试用例时无法随时调试内部代码，但send_keys()无法使用时，可以采用此方法，执行效率较高，稳定性也算可以</p>
</li>
<li>
<p>模拟键盘和剪切板： 此方法需要掌win32api，win32gui模块的使用，且代码编写繁琐，上传文件时如果鼠标点击其他地方会导致上传失败，脚本稳定性差，且效率低，但是如果用到一些特殊地方会起到比较好的效果</p>
</li>
<li>
<p>WinSpay：windows窗口句柄抓取工具，不需要编译脚本为exe文件，且上传文件操作使用的脚本是python第三方库实现，易维护，执行效率也较高，推荐send_keys()不可使用时，首先考虑此方法</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium知识点]]></title>
        <id>https://grassroadsz.github.io/selenium-zhi-shi-dian/</id>
        <link href="https://grassroadsz.github.io/selenium-zhi-shi-dian/">
        </link>
        <updated>2022-05-27T15:34:25.000Z</updated>
        <content type="html"><![CDATA[<p>题目来源于网络,答案系个人浅显理解，如有错误及不足之处，欢迎指正</p>
<p>• Selenium是否支持桌面应用软件的自动化测试</p>
<pre><code>Selenium不支持桌面应用软件的自动化测试，Selenium是通过操作HTML页面中的DOM树上的节点进行模拟用户行为，暂时不支持桌面应用
</code></pre>
<p>• Selenium是否支持用例的执行的引擎。</p>
<pre><code>selenium只是一个用来操作HTML页面元素的库，并不支持用例的执行引擎，python中需要使用unittest 或pytest 等测试框架完成用例的执行的引擎。
</code></pre>
<p>• Seleinum是否有读取excel文件的库</p>
<pre><code>selenium无读取excel文件的库，我一般使用openpyxl 库进行excel的读写操作
</code></pre>
<p>• Selenium有哪些组件?</p>
<pre><code>Selenium的组件有Selenium Grid（用于调度），webdriver（用于生成对应的浏览器实例，进行模拟用户浏览操作），Selenium IDE（浏览器录制回放）
</code></pre>
<p>• Selenium有什么限制或者缺陷</p>
<pre><code>Selenium只能完成浏览器或者移动端基于DOM元素的操作，无报告，用例执行引擎等功能
</code></pre>
<p>• 在selenium中，有哪些不同定位元素方法</p>
<pre><code>id/xpath/name/link_text/className/PartialLinkText/CSS selector，测试脚本编写过程中使用最多的xpath，css这两种
</code></pre>
<p>• 什么是imlicitlyWait (隐式等待)</p>
<pre><code>全局只需设置一次，元素或脚本执行的结果在设定的最长时间内出现则返回，未出现则在最长时间后抛出找不到元素的异常
</code></pre>
<p>• 什么是expliciteWait (显式等待)</p>
<pre><code>一般设置两个参数，一个为最长时间，一个为间隔轮询时间，例如WebDriverWait(10,0.5).until(...),则代表每间隔0.5s查询一次元素是否出现，出现则返回，未出现则间隔0.5s后再查找一次。10s后仍未找到则抛出找不到元素异常
</code></pre>
<p>• 什么是线程等待(硬式等待)</p>
<pre><code>time.sleep(3) 强制当前线程等待3s后再继续执行。
</code></pre>
<p>• 什么是pollingEvery</p>
<pre><code>python 的selenium中未发现这个，可能是指WebDriverWait中的poll_frequency参数
</code></pre>
<p>• 你写的测试脚本能在不同浏览器上运行吗，支持跨浏览器平台吗</p>
<pre><code>支持，在初始化driver的时候使用不同的Webdriver即可，我使用pytest做自动化测试时通过定义addoption方法，在pytest启动时根据传参不同，调用不同的浏览器
</code></pre>
<p>• 什么是POM,为什么要使用它</p>
<pre><code>PageObjectModel,页面对象模型，将页面映射成代码中的类，页面上的元素映射成类中的属性，页面上的操作映射成类的方法，使用POM在进行测试用例编写时只需要调用在页面类中定义好的方法即可，页面发生变动只需修改维护对应页面类中的属性或方法即可，无需修改测试用例，减少因页面频繁变动而造成的大量维护成本。
</code></pre>
<p>• 在你做自动化过程中，遇到了什么问题吗?举例下</p>
<pre><code>在做UI自动化时，数据的前置我通过接口进行生成，接口返回成功了，但是真正到页面上可查询存在一个时间差，导致case运行失败，我通过参考显示等待的方式，在页面上操作接口生成的数据无法找到时，同样使用类似轮询的机制，未找到，则刷新页面再找，直到超时时间内找到未知，再继续执行后续的case操作

有些手工操作时单击的操作通过代码单击会报元素不可点击，使用双击解决

UI运行受客户端环境影响较大，我使用docker selenium,保证了每次运行的浏览器实例都是新的无污染。
</code></pre>
<p>• 举例一下你遇到过那些异常，在selenium自动化测试</p>
<pre><code>超时，元素不可点击，未找到元素，元素没有某个属性
</code></pre>
<p>• 如何处理alert弹窗</p>
<pre><code class="language-python">a =driver.switch_to.alert
a.accept()
a.dismiss()
a.text

• 在selenium中如何处理多窗口?

driver.window_handles 获取窗口列表
driver.switch_to.windows(windows_name)
</code></pre>
<p>• 你查找元素遇到过在Frame里面吗?你是如何处理</p>
<pre><code>暂时没遇到，driver.switch_to.fram(id/name/索引)
</code></pre>
<p>• Frame里面元素定位的?</p>
<pre><code>切换至Frame内后继续操作即可
</code></pre>
<p>• 怎么验证勾选框是enable/disabled/checked/Unchecked/ displayed/not displayed?</p>
<pre><code class="language-python">    ele=driver.find_element((locator,value))
    ele.is_displayed()
    ele.is_enabled()
    ele.is_selected()
</code></pre>
<p>• 如何处理下拉菜单?</p>
<pre><code>我的项目中下拉框是div+li组成的下拉框，无法使用selenium中的select类提供的方法，我通过点击下拉框，唤出菜单，然后使用xpath，定位文本内容进行内容选择点击操作
</code></pre>
<p>• 在日历这种web表单你是如何处理的?</p>
<pre><code>日历表单如果可点击，可以使用点击操作，如果不可点击可使用driver.execute(js代码)，进行赋值操作(据反馈目前一些日历表单可能需要键盘操作配合才可以)
</code></pre>
<p>• 关闭浏览器中quit和close的区别</p>
<pre><code>close只是关闭窗口，session连接并没有关闭，浏览器进程仍然处于运行状态，quit是断开session连接，浏览器进程关闭
</code></pre>
<p>• 在Selenium中如何实现截图，如何实现用例执行失败才截图</p>
<pre><code>driver.get_screenshot_as_png()
在用例执行时进行try expect 异常捕获，expect时截图
</code></pre>
<p>• 在Selenium中如何实现拖拽滚动条?</p>
<pre><code>使用js进行拖拽，
滚动至顶部：driver.execute(&quot;windows.scrollTo(0,0)&quot;)
</code></pre>
<p>• 如何实现文件上传?<br>
<a href="https://grassroadsz.github.io/post/ui-zi-dong-hua-wen-jian-shang-chuan/">参考链接</a></p>
<p>文件上传若是input类型的可尝试使用send_keys() 方法(据反馈VUE组件中input类型为file的以无法使用send_keys方法)<br>
其它类型需使用借助第三方实现.</p>
<p>• 如何处理“不受信任的证书”的问题?<br>
<a href="https://stackoverflow.com/questions/24507078/how-to-deal-with-certificates-using-selenium">参考链接</a></p>
<pre><code class="language-python"># Firfox
profile = webdriver.FirefoxProfile()
profile.accept_untrusted_certs = True
driver = webdriver.Firefox(firefox_profile=profile)
# Chrome
options = webdriver.ChromeOptions()
options.add_argument('--ignore-certificate-errors')
driver = webdriver.Chrome(chrome_options=options)
# IE
capabilities = webdriver.DesiredCapabilities().INTERNETEXPLORER
capabilities['acceptSslCerts'] = True
driver = webdriver.Ie(capabilities=capabilities)
</code></pre>
<p>• 如何实现鼠标悬停,键盘事件和拖拽动作?</p>
<pre><code>使用ActionChains类的方法

click(on_element=None) ——单击鼠标左键
click_and_hold(on_element=None) ——点击鼠标左键，不松开
context_click(on_element=None) ——点击鼠标右键
double_click(on_element=None) ——双击鼠标左键
drag_and_drop(source, target) ——拖拽到某个元素然后松开
drag_and_drop_by_offset(source, xoffset, yoffset) ——拖拽到某个坐标然后松开
key_down(value, element=None) ——按下某个键盘上的键
key_up(value, element=None) ——松开某个键
move_by_offset(xoffset, yoffset) ——鼠标从当前位置移动到某个坐标
move_to_element(to_element) ——鼠标移动到某个元素
move_to_element_with_offset(to_element, xoffset, yoffset) ——移动到距某个元素（左上角坐标）多少距离的位置
perform() ——执行链中的所有动作
release(on_element=None) ——在某个元素位置松开鼠标左键
send_keys(*keys_to_send) ——发送某个键到当前焦点的元素
send_keys_to_element(element, *keys_to_send) ——发送某个键到指定元素

使用Keys类实现键盘事件：ele.send_keys(Keys.CONTROL,'x') 实现&quot;CTRL + X&quot;
</code></pre>
<p>• 如何获取页面标题，悬浮文本和错误文本，并验证?</p>
<pre><code>assert driver.title == 'xx标题'
悬浮文本和错误文本可以使用ActionChains().move_to_element() 然后ele.text
</code></pre>
<p>• 在selenium自动化测试中，你-般完成什么类型的测试?</p>
<pre><code>回归测试
</code></pre>
<p>• 你是如何管理你的测试用例并执行?</p>
<pre><code>测试用例按照业务模块划分成以test开头的py文件，pytest测试框架可识别以test开头或结尾的测试类或方法或文件，运行在根目录执行pytest 即可，当需要指定较多的参数或需要其他操作时定义run入口文件，直接运行run文件即可
</code></pre>
<p>• 关于自动化测试报告生成?</p>
<pre><code>使用的是pytest-html库生成html报告及allure
</code></pre>
<p>• 你如何用Selenium测试?</p>
<pre><code>将基础通用操作封装成base类，然后页面对象模型继承Base类。
</code></pre>
<p>• 如何解决问题?</p>
<pre><code>针对UI自动化中遇到的问题，先查看报错信息，定位是自己封装问题则修改封装，非自己代码问题则先看实现相关功能模块依赖库的官方说明文档，官方文档中未解决问题，若是开源库则对应github参考查看issue栏目，最后再百度或谷歌
</code></pre>
<p>• 你是怎么开发测试框架的?<br>
<img src="https://www.yuque.com/api/filetransfer/images?url=http%3A%2F%2Fblogimage.grassroadsz.top%2F20200403202457.png&amp;sign=c0829bb7cb2ed78db82d522cbecb36c8cb8664e49607290b0d128a55a63397dd" alt="" loading="lazy"><br>
• 做自动化测试的目的?</p>
<pre><code>接口自动化测试可尽快介入项目测试，在联调前发现编码中的问题，在版本更新发布后即进行接口自动化可对既有功能进行验证，保证此次新功能或bug修复对原有功能无影响。UI自动化可减少手工操作，进行兼容性测试。加快版本更新发布进度
</code></pre>
<p>• 如何判断case是否通过?</p>
<pre><code>接口的case 根据规定的响应状态码 + 接口响应的值 + db 中对应的数据变化进行判断
UI的case 根据业务场景进行后页面上的变动及相关特定提示语 ，也同样可根据db中的数据状态进行判断
</code></pre>
<p>• 你项目中有多少case,通过率怎么样?</p>
<pre><code>UI的case 单次运行目前通过率大约在95% 以上，通过加入失败重试机制后大约98%-99%左右
</code></pre>
<p>• 失败截图的原理是什么?</p>
<pre><code>我在框架中使用driver.get_screenshot_as_png() 方法在Base类中使用try expect在expect时即调用截图方法

具体实现没看出来
</code></pre>
<p>• 报告哪里来，主要统计什么?</p>
<pre><code>使用第三方库实现，统计用例成功失败，跳过，条数，运行时间、环境等
</code></pre>
<p>• testNG中注解有哪些</p>
<p>• TestNG有哪些优点</p>
<p>• 什么是web自动化</p>
<p>• 写出selenium中你最熟悉的接口或者类</p>
<pre><code>WebDriverWait：显示等待的类
webdrier.Chrome：实例化Chrome driver实例
</code></pre>
<p>• Xpath是什么?</p>
<pre><code>一门查找XML文档中信息的语言
</code></pre>
<p>• findElement()和findElements()方法有什么区别</p>
<pre><code>前者返回一个WebElement对象，后者返回一个由WebElement 组成的list
</code></pre>
<p>• 登录按钮除了click方法还有其他方式吗?</p>
<pre><code>driver.submit()
</code></pre>
<p>• 怎么对含有验证码的功能进行自动化测试</p>
<pre><code>简单验证码使用PIL库进行解决，过于复杂，识别难度过高与开发沟通使用通用验证码，或者使用第三方服务提供的图片识别服务
</code></pre>
<p>• 举一个WebDriver中方 法重载的例子</p>
<pre><code>webdriver.Chrome() 的__init__方法即重载了RemoteWebDriver的__init__方法
</code></pre>
<p>• 你如何模拟浏览器的前后移动?</p>
<pre><code>driver.forward()
driver.back()
</code></pre>
<p>• 你如何获得当前页面的URL?</p>
<pre><code>driver.current_url
</code></pre>
<p>• 如何在WebDriver中实现同步?<br>
selenium 与request 同步的话 可以把cookies 拿出来共享，对应的将cookies 放入对应的数据结果中即可<br>
• 如何从文本框中获取打字文本?</p>
<pre><code>ele.text
</code></pre>
<p>• 你如何清除中文本框的内容?</p>
<pre><code>ele.clear()
</code></pre>
<p>• 如何在webdriver中调用应用程序?</p>
<pre><code>os.system()
</code></pre>
<p>• 如何获取页面上的帧数?<br>
暂时未用到，但是应该可以使用js 获取到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytest小结]]></title>
        <id>https://grassroadsz.github.io/pytest-xiao-jie/</id>
        <link href="https://grassroadsz.github.io/pytest-xiao-jie/">
        </link>
        <updated>2022-05-27T15:17:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<pre><code class="language-shell">pip3 install -U pytest -i http://pypi.douban.com/sample
# html报告
pip install pytest-HTML 
# 失败重跑
pip install pytest-rerunfailures
# html 报告插件
pip install pytest-allure-adaptor
allure软件
</code></pre>
<h1 id="运行">运行</h1>
<h2 id="文件规则">文件规则</h2>
<pre><code>查找当前目录及其子目录以test*.py开头或者*test.py的文件，找到文件后在文件中找到以test开头函数并执行
</code></pre>
<h2 id="用例规则">用例规则</h2>
<pre><code>- 测试文件以test开头或者以test结尾
- 测试类以Test开头，且类不能带有init方法
- 测试函数以test_开头，使用assert断言
- 所有的包Pakeage必须有init.py 文件
</code></pre>
<h2 id="cmd运行">cmd运行</h2>
<pre><code>- pytest

- py.test

- Python -m pytest
</code></pre>
<h2 id="运行参数">运行参数</h2>
<h3 id="无参数">无参数</h3>
<pre><code>读取dir下所有符合规则的文件、类和方法、函数并执行
pytest dir
</code></pre>
<h3 id="-v打印日志详细程度">-v(打印日志详细程度)</h3>
<pre><code>打印详细运行信息
</code></pre>
<h3 id="-s输出代码中的print">-s（输出代码中的print）</h3>
<pre><code>控制台输出结果
</code></pre>
<h3 id="-k-跳过">-k (跳过)</h3>
<pre><code>pytest -k '类名'
pytest -k '方法名'
pytest -k '类名 and 方法名'  # 运行类中所有的方法。不包含某个方法
</code></pre>
<h3 id="-x-遇到失败用例立即停止运行">-x （遇到失败用例立即停止运行）</h3>
<pre><code>P0级别用例一条失败即停止用例运行
pytest -x
</code></pre>
<h3 id="-maxfail-用例失败个数达到阈值即停止运行">-maxfail (用例失败个数达到阈值即停止运行)</h3>
<pre><code>P1级别10条用例最多失败多少条即停止执行所有用例
pytest -maxfail=num
</code></pre>
<h3 id="-n-并行运行">-n 并行运行</h3>
<pre><code>pip install pytest-xdist
</code></pre>
<p>安装后在命令行中指定-n 进程数即可(使用参数化时需要动态参数的情况时需先将动态生成的参数生成至文件后从文件读取，保证多个worker节点的数据一致)</p>
<h3 id="-m指定运行某个标记的用例">-m（指定运行某个标记的用例）</h3>
<pre><code class="language-python">@pytest.mark.shopping
def function():
pass
</code></pre>
<pre><code>pytest -m shopping
</code></pre>
<h3 id="指定运行">指定运行</h3>
<pre><code>- 文件级别：pytest filename.py
- 文件内某个函数：pytest file.py::test_func
- 文件内某个类的的某个方法：pytest file.py::TestClass::test_method
</code></pre>
<h3 id="pycharm">Pycharm</h3>
<p>file -&gt; Setting -&gt; Tools -&gt; Python Intergrated Tools -&gt;projectname -&gt; Default test runner -&gt; pytest</p>
<p>示例</p>
<pre><code class="language-python">import pytest
class TestClass:
    def test_add(self):
        assert 1 + 1 == 5
    def test_sub(self):
        assert 1 * 1 == 3
if __name__ == '__main__':
  # main 中需要传list
    pytest.main([&quot;-q test_example_run.py&quot;])
</code></pre>
<h1 id="用法">用法</h1>
<h2 id="前置后置">前置后置</h2>
<pre><code class="language-python">class TestA(object):

    @staticmethod
    def teardown():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @staticmethod
    def setup():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def setup_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def teardown_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    def test_01(self):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))
        assert 2 == 1


def setup_module():
    print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))


def teardown_module():
    print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))


class TestB(object):

    @staticmethod
    def teardown():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @staticmethod
    def setup():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def setup_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def teardown_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    def test_00(self):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))
        assert 1 == 1


if __name__ == '__main__':
    pytest.main(['-sqv'])
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.nlark.com/yuque/0/2020/png/739683/1590631258407-3fa87540-1d05-4ac7-8695-4c8c7806527a.png?x-oss-process=image%2Fresize%2Cw_500%2Climit_0" alt="结果" loading="lazy"></figure>
<h3 id="conftestpy-pytestfixture">conftest.py-@pytest.fixture()</h3>
<pre><code>写在conftest.py文件中，不同的package可以有不同的conftest.py文件
</code></pre>
<h3 id="作用顺序">作用顺序</h3>
<pre><code>session &gt; module &gt; class &gt; function,
</code></pre>
<p>相同级别作用域的，其实例化顺序遵循它们在测试用例中被声明的顺序（也就是形参的顺序），或者fixture之间的相互调用关系；</p>
<p>使用autouse的fixture，先于其同级别的其它fixture实例化</p>
<pre><code class="language-python"># encoding:utf-8
# Motto：good good study, day day up. why you so lazy ？？？

import pytest

@pytest.fixture(scope='module',autouse=True) # 设置为autouse=True时在测试函数上面不需要写pytest.mark.fixture()
def open():
    print(&quot;这里类似于setup的操作，这里出错不会执行yield的操作&quot;)
    yield
    print(&quot;这里类似于teardown的操作，这期间raise不会影响执行&quot;)
# 除了使用yield 还可以使用addfinalizer，addfinalizer无论setup有无异常，均会执行类型teardown的操作
    
&quot;&quot;&quot;
使用方法：
1.可以测试类的每个测试方法都传一次调用
2.使用usefixture
当需要用到fixture的返回值时只能用fixture，不能用usefixtures
&quot;&quot;&quot;
class TestFix01:
    def test_01(self, login):
        pass

    def test_02(self, login):
        pass

# 使用usefixtures,每个测试函数都会调用
@pytest.mark.usefixtures(&quot;login&quot;)
class TestFix02:
    def test_01(self):
        pass

    def test_02(self):
        pass
    
# 使用多个usefixtures,先执行的在最下面
@pytest.mark.usefixtures(&quot;second&quot;)
@pytest.mark.usefixtures(&quot;first&quot;)
class TestFix03:
    def test_01(self):
        pass

    def test_02(self):
        pass
</code></pre>
<h3 id="参数化pytestmarkparametrize">参数化@pytest.mark.parametrize()</h3>
<pre><code class="language-python">@pytest.mark.parametrize(&quot;input_name, expect&quot;, [(1, 2), (3, 4), pytest.param(3, 7, marks=pytest.mark.xfail)],indirect=True)
# indirect=Truefixture定义的函数当成函数调用而不是参数
def test_add(input_name, expect):
    assert input_name == expect

@pytest.mark.parametrize(&quot;x&quot;, [(1, 2), (3, 4), pytest.param((3,), marks=pytest.mark.xfail)])
@pytest.mark.parametrize(&quot;y&quot;, [(1, 2), (3, 4), pytest.param((3,), marks=pytest.mark.xfail)])
def test_add(x, y):
    assert x == y
</code></pre>
<h3 id="标记pytestmarkmarkname">标记@pytest.mark.markname</h3>
<pre><code class="language-python"># 只运行mark=test的
@pytest.mark.test
def test_mark_name():
    print(&quot;这是测试mark标记的&quot;)

def test_a():
    print(&quot;这个么有mark&quot;)

if __name__ == '__main__':
    pytest.main([&quot;-m=test&quot;, &quot;test_mark.py&quot;])
</code></pre>
<h3 id="pytestini">pytest.ini</h3>
<pre><code class="language-ini">[pytest]
# 报告所有测试用例被跳过，预期失败，预期失败但是通过的原因
addopt = -rsxX

# 将被@pytest.mark.xfail但是实际却通过测试的用例改成失败
xfail_strict = true

# 记录标记的含义，可以使用pytest --markers查看
markers =
    test:测试mark标记

# 直接输入pytest 默认带上下列参数
addopts = -v --rerun 1 --html=report.html --self-contained-html
</code></pre>
<h3 id="pytest-html测试报告定制失败自动保存截图">pytest-html测试报告定制:失败自动保存截图</h3>
<pre><code class="language-python"># encoding:utf-8
# Motto：good good study, day day up. why you so lazy ？？？

import pytest
from selenium import webdriver
from py._xmlgen import html

driver = None

@pytest.fixture(scope='session', autouse=True)
def browser():
    global driver
    if driver is None:
        driver = webdriver.Chrome()
    return driver


def _capture_screenshot():
    return driver.get_screenshot_as_base64()


@pytest.mark.hookwrapper
def pytest_runtest_makereport(item):
    &quot;&quot;&quot;
    当测试失败的时候，自动截图，展示到html报告中
    :param item:
    &quot;&quot;&quot;
    pytest_html = item.config.pluginmanager.getplugin('html')
    outcome = yield
    report = outcome.get_result()
    extra = getattr(report, 'extra', [])

    if report.when == 'call' or report.when == &quot;setup&quot;:
        xfail = hasattr(report, 'wasxfail')
        if (report.skipped and xfail) or (report.failed and not xfail):
            file_name = report.nodeid.replace(&quot;::&quot;, &quot;_&quot;) + &quot;.png&quot;
            screen_img = _capture_screenshot()
            if file_name:
                html = '&lt;div&gt;&lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:600px;height:300px;&quot; ' \
                       'onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&gt;&lt;/div&gt;' % screen_img
                extra.append(pytest_html.extras.html(html))
        report.extra = extra
        report.description = str(item.function.__doc__)
        report.nodeid = report.nodeid.encode(&quot;utf-8&quot;).decode(&quot;unicode_escape&quot;)


@pytest.mark.optionalhook
def pytest_html_results_table_header(cells):
    cells.insert(1, html.th('Description'))
    cells.insert(2, html.th('Test_nodeid'))
    cells.pop(2)


@pytest.mark.optionalhook
def pytest_html_results_table_row(report, cells):
    cells.insert(1, html.td(report.description))
    cells.insert(2, html.td(report.nodeid))
    cells.pop(2)
</code></pre>
<h3 id="失败重跑">失败重跑</h3>
<pre><code>pip install pytest-rerunfailures
</code></pre>
<p>参数：</p>
<ul>
<li>--reruns=num 重试次数</li>
<li>--reruns-delay=time  失败后多少秒重新执行</li>
</ul>
<h3 id="命令行传参">命令行传参</h3>
<p>demo</p>
<pre><code class="language-python"># conftest.py
import pytest

def pytest_addoption(parser):
    '''添加命令行参数--env'''
    parser.addoption(
        &quot;--env&quot;, action=&quot;store&quot;, default=&quot;local&quot;, help=&quot;env option:  local or linux&quot;
    )
    parser.addoption(
        &quot;--user&quot;, action=&quot;store&quot;, default=&quot;user_1&quot;, help=&quot;env option:  user_1 or user_2&quot;
    )

@pytest.fixture(scope='session', autouse=True)
def begin(request):
    env = request.config.getoption(&quot;--env&quot;)
    user = request.config.getoption(&quot;--user&quot;)
    if env == 'local':
        print(&quot;这是本地环境&quot;)
    if user:
        print(&quot;我是用户{}&quot;.format(user))
        
# test_addoption.py
import pytest


@pytest.mark.parametrize('y', list(range(2)))
@pytest.mark.parametrize('x', list(range(2)))
def test_add(x, y):
    re = x + y
    assert re == 1

if __name__ == '__main__':
    pytest.main(['-vsq', '--user=user_1'])
</code></pre>
<pre><code>D:\Croe\pyest-doc\venv\Scripts\python.exe D:/Croe/pyest-doc/test_addoption.py
============================= test session starts =============================
platform win32 -- Python 3.8.0, pytest-5.4.2, py-1.8.1, pluggy-0.13.1
rootdir: D:\Croe\pyest-doc
collected 4 items

test_addoption.py 这是本地环境
我是用户user_1
F..F
</code></pre>
<h3 id="生成allure测试报告">生成allure测试报告</h3>
<p>下载安装allure2，配置环境变量</p>
<pre><code>pip3 install pytest-allure-adaptor
# 生成allure
pytest --alluredir=./allure_report --html=resutl.html --self-contained-html
# 本地打开(allure_report/html目录下的index.html)
allure generate ./allure_report -o ./allure_report/html
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Python进行Dubbo服务接口测试]]></title>
        <id>https://grassroadsz.github.io/shi-yong-python-jin-xing-dubbo-fu-wu-jie-kou-ce-shi/</id>
        <link href="https://grassroadsz.github.io/shi-yong-python-jin-xing-dubbo-fu-wu-jie-kou-ce-shi/">
        </link>
        <updated>2022-05-27T06:02:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>good good study day day up</p>
</blockquote>
<p>使用python请求dubbo服务</p>
<p>请求方式<br>
● 跳过zk，直接使用telnet命令请求dubbo服务<br>
● 连接zk，通过zk找到对应的dubbo服务的ip及port，使用telnet命令请求</p>
<p>方式一<br>
参考代码</p>
<pre><code class="language-python">import json
import telnetlib
import socket


class Dubbo(telnetlib.Telnet):
    prompt = 'dubbo&gt;'
    coding = 'gbk'

    def __init__(self, host=None, port=0,
                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        super().__init__(host, port)
        self.write(b'\n')

    def command(self, flag, str_=&quot;&quot;):
        data = self.read_until(flag.encode())
        self.write(str_.encode() + b&quot;\n&quot;)
        return data

    def invoke(self, service_name, method_name, arg):
        command_str = &quot;invoke {0}.{1}({2})&quot;.format(
            service_name, method_name, json.dumps(arg))
        self.command(Dubbo.prompt, command_str)
        data = self.command(Dubbo.prompt, &quot;&quot;)
        data = data.decode(&quot;utf-8&quot;,
                           errors='ignore').split('\n')[1].strip()

        return data


if __name__ == '__main__':
    # Dubbo服务的ip, 与port
    conn = Dubbo('192.168.227.237', 34510)

    json_data = {&quot;dtlBeanList&quot;: [
        {&quot;cost&quot;: 100, &quot;memoSku&quot;: &quot;haha&quot;, &quot;orderUnit&quot;: &quot;EAJ&quot;, &quot;poNo&quot;: &quot;string&quot;, &quot;qty&quot;: 10, &quot;seq&quot;: &quot;1&quot;, &quot;sku&quot;: &quot;999999&quot;,
         &quot;unitCost&quot;: 10}], &quot;mstBean&quot;: {&quot;address&quot;: &quot;string&quot;, &quot;cancelDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;city&quot;: &quot;string&quot;,
                                       &quot;comCode&quot;: &quot;ZB91&quot;, &quot;currency&quot;: &quot;string&quot;, &quot;issuedBy&quot;: &quot;string&quot;, &quot;memo&quot;: &quot;string&quot;,
                                       &quot;orderDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;orderType&quot;: 0, &quot;poNo&quot;: &quot;2801723696&quot;,
                                       &quot;province&quot;: &quot;string&quot;, &quot;receiver&quot;: &quot;string&quot;, &quot;receiverPhone&quot;: &quot;string&quot;,
                                       &quot;refPoNo&quot;: &quot;string&quot;, &quot;refStoreCode&quot;: &quot;2588&quot;, &quot;region&quot;: &quot;string&quot;, &quot;serviceFee&quot;: 0,
                                       &quot;status&quot;: 0, &quot;storeCode&quot;: &quot;2588&quot;, &quot;street&quot;: &quot;string&quot;, &quot;totalPrice&quot;: 0,
                                       &quot;vendorCode&quot;: &quot;string&quot;}}

    result = conn.invoke(&quot;com.bnq.supplier.sp.enpower.api.service.IEnpowerPlatformServiceRPC&quot;,
                         &quot;saveChannelOrder&quot;,
                         json_data
                         )
    print(result)
</code></pre>
<p>缺点<br>
● dubbo服务ip地址，port均会发生变化，通过写死的ip和port直连dubbo服务不利于使用脚本集成，dubbo服务重启，对应的ip和port在脚本中均需要修改</p>
<p>方式二<br>
参考代码</p>
<pre><code class="language-python">import urllib
import json
import telnetlib
from urllib.parse import unquote

# 需要安装kazoo依赖库
from kazoo.client import KazooClient


class Dubbo(telnetlib.Telnet):
    prompt = 'dubbo&gt;'
    coding = 'utf-8'

    def __init__(self, host=None, port=0, timeout=10):
        super().__init__(host, port)
        self.write(b'\n')

    def command(self, flag, str_=&quot;&quot;):
        data = self.read_until(flag.encode())
        self.write(str_.encode() + b&quot;\n&quot;)
        return data

    def invoke(self, service_name, method_name, arg):
        command_str = &quot;invoke {0}.{1}({2})&quot;.format(
            service_name, method_name, json.dumps(arg))
        self.command(Dubbo.prompt, command_str)
        data = self.command(Dubbo.prompt, &quot;&quot;)
        data = data.decode(&quot;utf-8&quot;,
                           errors='ignore').split('\n')[1].strip()

        return data


class DubboUtils(object):
    def __init__(self, zk_service, interface):
        self.zk_service = zk_service
        self.interface = interface

    def _get_dubbo(self, server_name):
        &quot;&quot;&quot;
        获取单个dubbo服务的
        :param server_name:服务名
        :return:{&quot;service&quot;: service, &quot;paths&quot;: paths, &quot;method&quot;: method}
        &quot;&quot;&quot;
        zk = KazooClient(hosts=&quot;{}&quot;.format(self.zk_service))
        zk.start()
        urls = []
        service_list = zk.get_children(&quot;dubbo&quot;)
        for i in service_list:
            if server_name in i:
                try:
                    # 获取服务发布方
                    providers = zk.get_children(&quot;/dubbo/{}/providers&quot;.format(i))
                    if providers:
                        for provider in providers:
                            url = urllib.parse.unquote(provider)
                            if url.startswith('dubbo:'):
                                urls.append(url.split('dubbo://')[1])
                except Exception as e:
                    print(e)
        paths = []
        for i in urls:
            try:
                path, temp = i.split('/')
                service = temp.split('?')[0]
                method = temp.split('methods=')[1].split('&amp;')[0].split(',')
                paths.append(path)
            except Exception as e:
                print(e)
        services = {&quot;service&quot;: service, &quot;paths&quot;: paths, &quot;method&quot;: method}
        zk.stop()
        return services

    def requests_dubbo(self, method, param):
        &quot;&quot;&quot;
        请求dubbo接口
        :param method: dubbo接口的方法
        :param param: 请求参数
        :return:
        &quot;&quot;&quot;
        res = self._get_dubbo(self.interface)
        methods = res.get(&quot;method&quot;)
        if method not in methods:
            raise NameError(f&quot;{method} not in {methods}&quot;)
        ip, port = res.get(&quot;paths&quot;)[0].split(&quot;:&quot;)
        con = Dubbo(ip, port)
        result = con.invoke(self.interface, method, param)
        return result


if __name__ == '__main__':
    d = DubboUtils(&quot;zk-dev&quot;, 'com.bnq.supplier.sp.enpower.api.service.IEnpowerPlatformServiceRPC')
    json_data = {&quot;dtlBeanList&quot;: [
        {&quot;cost&quot;: 100, &quot;memoSku&quot;: &quot;haha&quot;, &quot;orderUnit&quot;: &quot;EAJ&quot;, &quot;poNo&quot;: &quot;string&quot;, &quot;qty&quot;: 10, &quot;seq&quot;: &quot;1&quot;, &quot;sku&quot;: &quot;999999&quot;,
         &quot;unitCost&quot;: 10}], &quot;mstBean&quot;: {&quot;address&quot;: &quot;string&quot;, &quot;cancelDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;city&quot;: &quot;string&quot;,
                                       &quot;comCode&quot;: &quot;ZB91&quot;, &quot;currency&quot;: &quot;string&quot;, &quot;issuedBy&quot;: &quot;string&quot;, &quot;memo&quot;: &quot;string&quot;,
                                       &quot;orderDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;orderType&quot;: 0, &quot;poNo&quot;: &quot;2801723696&quot;,
                                       &quot;province&quot;: &quot;string&quot;, &quot;receiver&quot;: &quot;string&quot;, &quot;receiverPhone&quot;: &quot;string&quot;,
                                       &quot;refPoNo&quot;: &quot;string&quot;, &quot;refStoreCode&quot;: &quot;2588&quot;, &quot;region&quot;: &quot;string&quot;, &quot;serviceFee&quot;: 0,
                                       &quot;status&quot;: 0, &quot;storeCode&quot;: &quot;2588&quot;, &quot;street&quot;: &quot;string&quot;, &quot;totalPrice&quot;: 0,
                                       &quot;vendorCode&quot;: &quot;string&quot;}}

    print(d.requests_dubbo(&quot;saveChannelOrder&quot;, json_data))

</code></pre>
<p>优点<br>
● 先连接zookeeper注册中心，通过zookeeper注册中心获取到dubbo服务的ip和port，保证每次获取到的ip和port均是正确可用的，便于与脚本进行集成<br>
缺点<br>
● 可能是因为需要先连接zk注册中心，然后获取dubbo服务，耗时比直接使用telnet命令时间稍长，约1s(对于测试脚本来说速度完全可以接受)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊入门-1 基础准备]]></title>
        <id>https://grassroadsz.github.io/yi-tai-fang-ru-men-1-ji-chu-zhun-bei/</id>
        <link href="https://grassroadsz.github.io/yi-tai-fang-ru-men-1-ji-chu-zhun-bei/">
        </link>
        <updated>2022-05-14T15:59:20.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>添加测试网Rinkeby 地址,使用 chainlink: <code>https://chainlist.quantclass.cn/</code></li>
<li>默认的测试网选项没有打开，需要使用设置 --&gt; 高级 -- &gt; 显示测试网络</li>
<li>测试币领取 <code>https://faucet.rinkeby.io/</code> 打开<code>https://twitter.com/intent/tweet?text=Requesting%20faucet%20funds%20into%200x0000000000000000000000000000000000000000%20on%20the%20%23Rinkeby%20%23Ethereum%20test%20network.</code> 将 其中的 000 改成自己的地址 ，发送twitter 后将twitter 地址copy 到 领水地址 进行领水</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊入门开发课]]></title>
        <id>https://grassroadsz.github.io/yi-tai-fang-ru-men-kai-fa-ke/</id>
        <link href="https://grassroadsz.github.io/yi-tai-fang-ru-men-kai-fa-ke/">
        </link>
        <updated>2022-05-14T15:59:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://forested-celsius-818.notion.site/62be43fb25c84db1965eb21f620087b0">课程学员手册</a></p>
<h2 id="以太坊入门-1-基础准备">以太坊入门-1 基础准备</h2>
<ul>
<li>添加测试网Rinkeby 地址,使用 chainlink: <a href="https://chainlist.quantclass.cn/">https://chainlist.quantclass.cn/</a></li>
<li>默认的测试网选项没有打开，需要使用设置 --&gt; 高级 -- &gt; 显示测试网络</li>
<li>测试币领取<a href="https://faucet.rinkeby.io/">https://faucet.rinkeby.io/</a><br>
打开<code>https://twitter.com/intent/tweet?text=Requesting%20faucet%20funds%20into%200x0000000000000000000000000000000000000000%20on%20the%20%23Rinkeby%20%23Ethereum%20test%20network.</code> 将 其中的 000 改成自己的地址 ，发送twitter 后将twitter 地址copy 到 领水地址 进行领水</li>
</ul>
<h2 id="arbitrum">Arbitrum</h2>
<ul>
<li>
<p>跨链桥：<code>https://bridge.arbitrum.io/</code></p>
<p>合约交互代码</p>
<pre><code class="language-python">def connect_web3_instance(network=&quot;mainnet&quot;):
  # 使用dotenv 进行配置的管理 此处只需要使用 Infura 的project_id 即可
  INFURA_PROJECT_ID = os.getenv('INFURA_PROJECT_ID')
  INFURA_MAIN_NETWORK = f'https://{network}.infura.io/v3/{INFURA_PROJECT_ID}'

  web3_instance = Web3(Web3.HTTPProvider(endpoint_uri=INFURA_MAIN_NETWORK))
  print(web3_instance.isConnected())
  return web3_instance


def bridge_arbitrum(from_address, from_address_private_key, l1_amount):
  &quot;&quot;&quot;
  Arbitrum 测试网跨链桥
  &quot;&quot;&quot;
  ArbitrumProxyContract = &quot;0x578BAde599406A8fE3d24Fd7f7211c0911F5B29e&quot;
  ArbitrumProxyContractAbi = '[{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;messageNum&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;InboxMessageDelivered&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;messageNum&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;InboxMessageDeliveredFromOrigin&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;enabled&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;name&quot;:&quot;PauseToggled&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;enabled&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;name&quot;:&quot;RewriteToggled&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newSource&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;WhitelistSourceUpdated&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;bridge&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;contract IBridge&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;createRetryableTicket&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;createRetryableTicketNoRefundAliasRewrite&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;depositEth&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;contract IBridge&quot;,&quot;name&quot;:&quot;_bridge&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;_whitelist&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;initialize&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;isCreateRetryablePaused&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;isMaster&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;pauseCreateRetryables&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendContractTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL1FundedContractTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;nonce&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL1FundedUnsignedTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;messageData&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL2Message&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;messageData&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL2MessageFromOrigin&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;nonce&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendUnsignedTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;shouldRewriteSender&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;startRewriteAddress&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;stopRewriteAddress&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;unpauseCreateRetryables&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;unsafeCreateRetryableTicket&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newSource&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;updateWhitelistSource&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;whitelist&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;}]'
  web3_instance = connect_web3_instance(&quot;rinkeby&quot;)

  # 通过合约地址 以及abi 实例化的 对象才可以使用abi中的方法进行调用
  ArbitrumProxyContractInstance = web3_instance.eth.contract(address=Web3.toChecksumAddress(ArbitrumProxyContract),
                                                             abi=ArbitrumProxyContractAbi)

  l1_amount = web3_instance.toWei(l1_amount, &quot;ether&quot;)
  from_address_balance = web3_instance.eth.get_balance(web3_instance.toChecksumAddress(from_address))
  print(f&quot;{from_address} 的 地址余额 为 {float(from_address_balance / 1e18)} ETH,转账 {l1_amount / 1e18} ETH&quot;)

  function_instance = ArbitrumProxyContractInstance.functions.depositEth(maxSubmissionCost=l1_amount)

  params = {

      'gas': 250000,
      'nonce': web3_instance.eth.getTransactionCount(web3_instance.toChecksumAddress(from_address)),
      'from': web3_instance.toChecksumAddress(from_address),
      'value': l1_amount,
      # 'gasPrice': w3.toWei('5', 'gwei'),
      'maxFeePerGas': web3_instance.toWei(5, 'gwei'),
      'maxPriorityFeePerGas': web3_instance.toWei(5, 'gwei'),
      'chainId': 4,

  }
  try:
      # 构建tx
      tx = function_instance.buildTransaction(params)
      # 签名
      sign_tx = web3_instance.eth.account.signTransaction(tx, private_key=from_address_private_key)
      # 发送交易
      txn = web3_instance.eth.sendRawTransaction(sign_tx.rawTransaction)
      from_address_balance = web3_instance.eth.get_balance(web3_instance.toChecksumAddress(from_address))
      print(f&quot;{from_address} 的 地址余额 为 {float(from_address_balance / 1e18)} ETH&quot;)

      return {'status': 'succeed', 'txn_hash': web3_instance.toHex(txn), 'task': 'Bridge ETH'}

  except Exception as e:
      return {'status': 'failed', 'error': e, 'task': 'Bridge ETH'}
</code></pre>
</li>
</ul>
<pre><code>


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试文章]]></title>
        <id>https://grassroadsz.github.io/ce-shi-wen-zhang/</id>
        <link href="https://grassroadsz.github.io/ce-shi-wen-zhang/">
        </link>
        <updated>2022-05-12T23:38:51.000Z</updated>
        <content type="html"><![CDATA[<p>测试文章</p>
]]></content>
    </entry>
</feed>