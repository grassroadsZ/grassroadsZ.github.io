<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://grassroadsz.github.io</id>
    <title>Gridea</title>
    <updated>2022-05-28T07:06:52.779Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://grassroadsz.github.io"/>
    <link rel="self" href="https://grassroadsz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://grassroadsz.github.io/images/avatar.png</logo>
    <icon>https://grassroadsz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[UI自动化文件上传]]></title>
        <id>https://grassroadsz.github.io/post/ui-zi-dong-hua-wen-jian-shang-chuan/</id>
        <link href="https://grassroadsz.github.io/post/ui-zi-dong-hua-wen-jian-shang-chuan/">
        </link>
        <updated>2022-05-28T06:52:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文链接 https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-upload_file.html#4520068</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>实施UI自动化测试的时候，经常会遇见上传文件的操作，那么对于上传文件你知道几种方法呢？今天我们就总结一下几种常用的上传文件的方法，并分析一下每个方法的优点和缺点以及哪种方法效率，稳定性更高</p>
<h2 id="被测html代码">被测HTML代码</h2>
<figure data-type="image" tabindex="1"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;!--upload_file.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;上传文件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;upload_file&quot; type=&quot;file&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<p>第一种方法：使用webdriver api 提供的方法send_keys上传文件</p>
<h2 id="send_keys方法">send_keys方法</h2>
<h3 id="实例">实例</h3>
<figure data-type="image" tabindex="3"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
&quot;&quot;&quot; 
from selenium import webdriver
import time


driver = webdriver.Firefox()
driver.get(r'file:///e:/CnblogCode/upload_file.html')
upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
time.sleep(3)  # 为了看效果
upload_element.send_keys(r'E:CnblogCodeupload_file.html')
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<h3 id="执行过程">执行过程</h3>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718141749877-90060948.gif" alt="" loading="lazy"></figure>
<p>可以看到执行过程很顺利，且代码实现简单，也没有报错</p>
<p>但是往往现实是残酷的，因为有的网站的上传文件并不是采用 input标签来定义的上传文件按钮，所以就无法使用send_keys方法上传，这也是这个方法的限制</p>
<h2 id="autoit工具">AutoIt工具</h2>
<p>第二种方法是AutoIT工具，它是一个类似脚本语言的软件，利用此软件我们可以方便的实现模拟键盘、鼠标、窗口等操作，实现自动化</p>
<h3 id="安装">安装</h3>
<p>官网地址：<a href="https://www.autoitscript.com/site/autoit/downloads/">https://www.autoitscript.com/site/autoit/downloads/</a></p>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718145953994-1855651642.png" alt="" loading="lazy"></figure>
<p>安装完后可以找到如下一些工具</p>
<figure data-type="image" tabindex="7"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718150114641-2141840187.png" alt="" loading="lazy"></figure>
<h3 id="使用">使用</h3>
<ol>
<li>
<p>打开被测试的HTML页面，并点击上传文件，弹出上传文件窗口，并保持当前窗口</p>
</li>
<li>
<p>打开AutoIt Window Info(x86/x64)工具</p>
</li>
<li>
<p>点击工具中Finder Tool标签下的按钮，开始分别定位上传文件的【输入框】和【打开】按钮，并记录Title，Class，Instance（图中红色窗口中的信息）</p>
</li>
</ol>
<p>注意：不同的浏览器抓取的Title是不一样的（Firefox：文件上传，Chrome：打开，IE：选择要加载的文件)</p>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718150637174-380718539.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>打开 SciTE Script Editor<img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718153911035-1870937893.png" alt="" loading="lazy"><br>
工具开始编写脚本(注意脚本中的Edit1是class 和 instance 拼接的)</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-shell">;first make sure the number of arguments passed into the scripts is more than 1 If $CmdLine[0]&lt;2 Then Exit EndIf ;if parmas num &lt;2 ,then break ;$CmdLine[0] ;参数的数量
;$CmdLine[1] ;第一个参数 (脚本名称后面)
;$CmdLine[2] ;第二个参数
;都是从cmd传入参数
 handleUpload($CmdLine[1],$CmdLine[2])

;定义上传函数，有两个参数，第一个是浏览器名字，第二参数是文件路径
 Func handleUpload($browser, $uploadfile)
     Dim $title                          ;定义一个title变量
            ;根据弹窗的title来判断是什么浏览器
            If $browser=&quot;ie&quot; Then                          ; 代表IE浏览器
                  $title=&quot;选择要加载的文件&quot; ElseIf $browser=&quot;chrome&quot; Then               ; 代表谷歌浏览器
                 $title=&quot;打开&quot; ElseIf    $browser=&quot;firefox&quot; Then             ; 代表火狐浏览器
                  $title=&quot;文件上传&quot; EndIf if WinWait($title,&quot;&quot;,4) Then ;等待弹出出现，最大等待时间是4秒
                   WinActivate($title)                  ;找到弹出窗口之后，激活当前窗口
                   ControlSetText($title,&quot;&quot;,&quot;Edit1&quot;,$uploadfile)   ;把文件路径放入输入框，此”Edit1“是用FinderTool获取到的
                   ControlClick($title,&quot;&quot;,&quot;Button1&quot;)                ;点击保存或者打开或者上传按钮，此“Button1”使用FinderTool获取到的
            Else
            Return False
            EndIf
 EndFunc
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<ol start="5">
<li>编译脚本为exe可执行文件</li>
</ol>
<p>编写完脚本之后，保存文件并打开Compile Script to .exe(x64/x86)工具 <img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718153828567-1147124643.png" alt="" loading="lazy"><br>
，将保存后的脚本.au3文件转换为.exe可执行文件</p>
<ol start="6">
<li>执行转换后的脚本</li>
</ol>
<p>在执行脚本之前，先确保上传文件的窗口已经打开，接下来打开cmd执行exe程序  C:Usersv-xugDesktop&gt;upload_file_new.exe firefox E:CnblogCodeupload_file.html</p>
<ol start="7">
<li>执行效果</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718161454802-676243340.gif" alt="" loading="lazy"></figure>
<ol start="8">
<li>编写selenium脚本</li>
</ol>
<h3 id="实例-2">实例</h3>
<figure data-type="image" tabindex="12"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
from selenium.webdriver.common.action_chains import ActionChains 
import os
from selenium import webdriver
import time 

class Base(object):

    @staticmethod def upload_file(exe, browser, filename): &quot;&quot;&quot; 使用autoIt上传文件
        :param exe: 上传文件的exe程序所在目录
        :param browser: 浏览器类型： firefox chrome ie
        :param filename: 待上传文件路径
        :return: none &quot;&quot;&quot; cmd = exe + ' ' + browser + ' ' + filename
        os.system(cmd) if __name__ == '__main__':
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')  # 打开被测html
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()  # 点击上传文件弹出上传文件窗口
    action.release()
    time.sleep(3)  # 为了看效果
    Base.upload_file(r'E:CnblogCodeupload_file_new.exe', 'firefox', r'E:CnblogCodeupload_file.html')  # 上传文件

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<h3 id="执行过程-2">执行过程</h3>
<figure data-type="image" tabindex="14"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718170623032-66535341.gif" alt="" loading="lazy"></figure>
<p>以上就是使用AutoId工具完成上传文件的过程，其实还是挺复杂的， 但是配置一次之后，以后就可以重复使用编译生成的exe文件了，执行效果还是不错的 没出什么错误，执行效率也还可以</p>
<h2 id="模拟键盘">模拟键盘</h2>
<p>第三种方法：模拟键盘的粘贴与回车操作并结合剪切板的操作来完成上传文件，基本原理是向剪切板中发送文件(文件路径字符串)，然后再从剪切板中获取到文件，最后通过模拟键盘的ctrl+v与enter键来完成文件上传</p>
<p>这种方法需要第三方库的支持，安装pypiwin32库： pip install pypiwin32</p>
<h3 id="实例-3">实例</h3>
<p>模拟键盘操作代码</p>
<figure data-type="image" tabindex="15"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">import win32api import win32con
import time 

class KeyBoard(object): 
    &quot;&quot;&quot;模拟按键&quot;&quot;&quot;
    # 键盘码
    vk_code = { 'enter' : 0x0D, 'ctrl' : 0x11, 'v' : 0x56 }

    @staticmethod def keyDown(key_name): &quot;&quot;&quot;按下键&quot;&quot;&quot; key_name = key_name.lower() try:
            win32api.keybd_event(KeyBoard.vk_code[key_name], 0, 0, 0) except Exception as e: print('未按下enter键') raise e

    @staticmethod def keyUp(key_name): &quot;&quot;&quot;抬起键&quot;&quot;&quot; key_name = key_name.lower()
        win32api.keybd_event(KeyBoard.vk_code[key_name], 0, win32con.KEYEVENTF_KEYUP, 0)

    @staticmethod def oneKey(key): &quot;&quot;&quot;模拟单个按键&quot;&quot;&quot; key = key.lower()
        KeyBoard.keyDown(key)
        time.sleep(2)
        KeyBoard.keyUp(key)

    @staticmethod def twoKeys(key1, key2): &quot;&quot;&quot;模拟组合按键&quot;&quot;&quot; key1 = key1.lower()
        key2 = key2.lower()
        KeyBoard.keyDown(key1)
        KeyBoard.keyDown(key2)
        KeyBoard.keyUp(key1)
        KeyBoard.keyUp(key2) if __name__ == '__main__': pass
</code></pre>
<p>keyboard.py</p>
<p>剪切板操作代码</p>
<figure data-type="image" tabindex="16"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
import win32con 
import win32clipboard as WC 

class ClipBoard(object): 
    &quot;&quot;&quot;设置剪切板内容和获取剪切板内容&quot;&quot;&quot; 
    
    @staticmethod def getText(): &quot;&quot;&quot;获取剪切板的内容&quot;&quot;&quot; 
        WC.OpenClipboard()
        value = WC.GetClipboardData(win32con.CF_TEXT)
        WC.CloseClipboard() return value

    @staticmethod def setText(value): &quot;&quot;&quot;设置剪切板的内容&quot;&quot;&quot; 
        WC.OpenClipboard()
        WC.EmptyClipboard()
        WC.SetClipboardData(win32con.CF_UNICODETEXT, value)
        WC.CloseClipboard() 
if __name__ == '__main__': 
    pass
</code></pre>
<p>clipboard.py</p>
<p>上传文件代码</p>
<figure data-type="image" tabindex="17"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">from clipboard import ClipBoard 
from keyboard import KeyBoard 
from selenium import webdriver 
import time 
from selenium.webdriver.common.action_chains import ActionChains 

if __name__ == '__main__':
    ClipBoard.setText(r'E:CnblogCodeupload_file.html')  # 待上传文件设置到剪切板
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()
    action.release()
    time.sleep(3)  # 为了看效果
    KeyBoard.twoKeys('ctrl', 'v')
    KeyBoard.oneKey('enter')

upload_file_board.py
</code></pre>
<h3 id="执行过程-3">执行过程</h3>
<figure data-type="image" tabindex="18"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718173040775-1045026529.gif" alt="" loading="lazy"></figure>
<p>失败</p>
<figure data-type="image" tabindex="19"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718173123389-1294379262.gif" alt="" loading="lazy"></figure>
<p>可以看到第二个动画上传文件未成功，这也就这个方法的弊端，只要移动了鼠标就有可能就不会成功，毕竟模拟的是enter键，这个过程你点击了别的地方，那么enter的效果就变了，所以这种方法很不稳定，也不难发现，代码量也很多，而且需要掌握模拟键盘和剪切板的操作，最不推荐使用的就是这种方法</p>
<p>之前我的实战项目里面，用到过这种方法， 当时我已经发现了这种方法的弊端， 但是为了掌握这种模拟键盘的方法，所以才使用的，当然模拟键盘操作用到一些特殊的情况还是能解决很多实际问题的</p>
<h2 id="winspy工具">WinSpy工具</h2>
<p>第四种方法：这个工具其实和AutoIt工具的元素定位方式一样，但是不需要生成exe文件，其实只是个辅助工具，主要用来获取windows窗口句柄，进而通过python脚本来控制</p>
<h3 id="winspy安装">WinSpy安装</h3>
<p><a href="https://sourceforge.net/projects/winspyex/">https://sourceforge.net/projects/winspyex/</a></p>
<p>下载完直接解压打开WinSpy32(64).exe即可使用</p>
<p>使用方法和autoId一样，请按照下图的步骤操作，记录winspy-Tree中红框信息</p>
<figure data-type="image" tabindex="20"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718174930856-1995061900.png" alt="" loading="lazy"></figure>
<p>编写代码之前，同样需要提前安装 pypiwin32库</p>
<h3 id="实例-4">实例</h3>
<figure data-type="image" tabindex="21"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">from selenium.webdriver.common.action_chains import ActionChains
from selenium import webdriver
import win32con 
import win32gui 
import time 

def upload_file(browser: str, file: str):
    browser_type = { &quot;firefox&quot;: &quot;文件上传&quot;, &quot;chrome&quot;: &quot;打开&quot;, &quot;ie&quot;: &quot;选择要加载的文件&quot; }
    time.sleep(2)
    dialog = win32gui.FindWindow(&quot;#32770&quot;, browser_type[browser])  # 火狐浏览器为”文件上传“，谷歌为”打开“
    combobox_ex32 = win32gui.FindWindowEx(dialog, 0, &quot;ComboBoxEx32&quot;, None)
    combobox = win32gui.FindWindowEx(combobox_ex32, 0, 'ComboBox', None)
    edit = win32gui.FindWindowEx(combobox, 0, 'Edit', None)
    button = win32gui.FindWindowEx(dialog, 0, 'Button', None)
    win32gui.SendMessage(edit, win32con.WM_SETTEXT, None, file)
    win32gui.SendMessage(dialog, win32con.WM_COMMAND, 1, button) if __name__ == '__main__':
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()
    action.release()
    time.sleep(3)  # 为了看效果
    upload_file('firefox', r'E:CnblogCodeupload_file.html')
</code></pre>
<p>load_file_winspy.py</p>
<h3 id="执行过程-4">执行过程</h3>
<figure data-type="image" tabindex="22"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718175927417-974106887.gif" alt="" loading="lazy"></figure>
<p>此方法也比较稳定，只要通过传递不同的浏览器参数，即可完成不同浏览器中的上传文件操作，而且相比于AutoId而言，这种方法可以直接使用python编写代码且不需要编译成exe程序，可以随时对代码进行修改，易维护</p>
<h2 id="总结">总结</h2>
<p>最后总结一下每个方法的优缺点</p>
<ol>
<li>
<p>send_keys(): 如果所遇见的上传文件使用的是input标签且属性type=file，均可使用，也最好采用此方法，方便，简单，执行效率高</p>
</li>
<li>
<p>AutoId： 需编写VBS代码并编译为exe可执行文件，过程繁琐，编写selenium测试用例时无法随时调试内部代码，但send_keys()无法使用时，可以采用此方法，执行效率较高，稳定性也算可以</p>
</li>
<li>
<p>模拟键盘和剪切板： 此方法需要掌win32api，win32gui模块的使用，且代码编写繁琐，上传文件时如果鼠标点击其他地方会导致上传失败，脚本稳定性差，且效率低，但是如果用到一些特殊地方会起到比较好的效果</p>
</li>
<li>
<p>WinSpay：windows窗口句柄抓取工具，不需要编译脚本为exe文件，且上传文件操作使用的脚本是python第三方库实现，易维护，执行效率也较高，推荐send_keys()不可使用时，首先考虑此方法</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium知识点]]></title>
        <id>https://grassroadsz.github.io/post/selenium-zhi-shi-dian/</id>
        <link href="https://grassroadsz.github.io/post/selenium-zhi-shi-dian/">
        </link>
        <updated>2022-05-27T15:34:25.000Z</updated>
        <content type="html"><![CDATA[<p>题目来源于网络,答案系个人浅显理解，如有错误及不足之处，欢迎指正</p>
<p>• Selenium是否支持桌面应用软件的自动化测试</p>
<pre><code>Selenium不支持桌面应用软件的自动化测试，Selenium是通过操作HTML页面中的DOM树上的节点进行模拟用户行为，暂时不支持桌面应用
</code></pre>
<p>• Selenium是否支持用例的执行的引擎。</p>
<pre><code>selenium只是一个用来操作HTML页面元素的库，并不支持用例的执行引擎，python中需要使用unittest 或pytest 等测试框架完成用例的执行的引擎。
</code></pre>
<p>• Seleinum是否有读取excel文件的库</p>
<pre><code>selenium无读取excel文件的库，我一般使用openpyxl 库进行excel的读写操作
</code></pre>
<p>• Selenium有哪些组件?</p>
<pre><code>Selenium的组件有Selenium Grid（用于调度），webdriver（用于生成对应的浏览器实例，进行模拟用户浏览操作），Selenium IDE（浏览器录制回放）
</code></pre>
<p>• Selenium有什么限制或者缺陷</p>
<pre><code>Selenium只能完成浏览器或者移动端基于DOM元素的操作，无报告，用例执行引擎等功能
</code></pre>
<p>• 在selenium中，有哪些不同定位元素方法</p>
<pre><code>id/xpath/name/link_text/className/PartialLinkText/CSS selector，测试脚本编写过程中使用最多的xpath，css这两种
</code></pre>
<p>• 什么是imlicitlyWait (隐式等待)</p>
<pre><code>全局只需设置一次，元素或脚本执行的结果在设定的最长时间内出现则返回，未出现则在最长时间后抛出找不到元素的异常
</code></pre>
<p>• 什么是expliciteWait (显式等待)</p>
<pre><code>一般设置两个参数，一个为最长时间，一个为间隔轮询时间，例如WebDriverWait(10,0.5).until(...),则代表每间隔0.5s查询一次元素是否出现，出现则返回，未出现则间隔0.5s后再查找一次。10s后仍未找到则抛出找不到元素异常
</code></pre>
<p>• 什么是线程等待(硬式等待)</p>
<pre><code>time.sleep(3) 强制当前线程等待3s后再继续执行。
</code></pre>
<p>• 什么是pollingEvery</p>
<pre><code>python 的selenium中未发现这个，可能是指WebDriverWait中的poll_frequency参数
</code></pre>
<p>• 你写的测试脚本能在不同浏览器上运行吗，支持跨浏览器平台吗</p>
<pre><code>支持，在初始化driver的时候使用不同的Webdriver即可，我使用pytest做自动化测试时通过定义addoption方法，在pytest启动时根据传参不同，调用不同的浏览器
</code></pre>
<p>• 什么是POM,为什么要使用它</p>
<pre><code>PageObjectModel,页面对象模型，将页面映射成代码中的类，页面上的元素映射成类中的属性，页面上的操作映射成类的方法，使用POM在进行测试用例编写时只需要调用在页面类中定义好的方法即可，页面发生变动只需修改维护对应页面类中的属性或方法即可，无需修改测试用例，减少因页面频繁变动而造成的大量维护成本。
</code></pre>
<p>• 在你做自动化过程中，遇到了什么问题吗?举例下</p>
<pre><code>在做UI自动化时，数据的前置我通过接口进行生成，接口返回成功了，但是真正到页面上可查询存在一个时间差，导致case运行失败，我通过参考显示等待的方式，在页面上操作接口生成的数据无法找到时，同样使用类似轮询的机制，未找到，则刷新页面再找，直到超时时间内找到未知，再继续执行后续的case操作

有些手工操作时单击的操作通过代码单击会报元素不可点击，使用双击解决

UI运行受客户端环境影响较大，我使用docker selenium,保证了每次运行的浏览器实例都是新的无污染。
</code></pre>
<p>• 举例一下你遇到过那些异常，在selenium自动化测试</p>
<pre><code>超时，元素不可点击，未找到元素，元素没有某个属性
</code></pre>
<p>• 如何处理alert弹窗</p>
<pre><code class="language-python">a =driver.switch_to.alert
a.accept()
a.dismiss()
a.text

• 在selenium中如何处理多窗口?

driver.window_handles 获取窗口列表
driver.switch_to.windows(windows_name)
</code></pre>
<p>• 你查找元素遇到过在Frame里面吗?你是如何处理</p>
<pre><code>暂时没遇到，driver.switch_to.fram(id/name/索引)
</code></pre>
<p>• Frame里面元素定位的?</p>
<pre><code>切换至Frame内后继续操作即可
</code></pre>
<p>• 怎么验证勾选框是enable/disabled/checked/Unchecked/ displayed/not displayed?<br>
<code>python ele=driver.find_element((locator,value)) ele.is_displayed() ele.is_enabled() ele.is_selected()</code><br>
• 如何处理下拉菜单?</p>
<pre><code>我的项目中下拉框是div+li组成的下拉框，无法使用selenium中的select类提供的方法，我通过点击下拉框，唤出菜单，然后使用xpath，定位文本内容进行内容选择点击操作
</code></pre>
<p>• 在日历这种web表单你是如何处理的?</p>
<pre><code>日历表单如果可点击，可以使用点击操作，如果不可点击可使用driver.execute(js代码)，进行赋值操作(据反馈目前一些日历表单可能需要键盘操作配合才可以)
</code></pre>
<p>• 关闭浏览器中quit和close的区别</p>
<pre><code>close只是关闭窗口，session连接并没有关闭，浏览器进程仍然处于运行状态，quit是断开session连接，浏览器进程关闭
</code></pre>
<p>• 在Selenium中如何实现截图，如何实现用例执行失败才截图</p>
<pre><code>driver.get_screenshot_as_png()
在用例执行时进行try expect 异常捕获，expect时截图
</code></pre>
<p>• 在Selenium中如何实现拖拽滚动条?</p>
<pre><code>使用js进行拖拽，
滚动至顶部：driver.execute(&quot;windows.scrollTo(0,0)&quot;)
</code></pre>
<p>• 如何实现文件上传?<br>
参考链接</p>
<p>文件上传若是input类型的可尝试使用send_keys() 方法(据反馈VUE组件中input类型为file的以无法使用send_keys方法)<br>
其它类型需使用借助第三方实现.</p>
<p>• 如何处理“不受信任的证书”的问题?<br>
参考链接</p>
<h1 id="firfox">Firfox</h1>
<p>profile = webdriver.FirefoxProfile()<br>
profile.accept_untrusted_certs = True<br>
driver = webdriver.Firefox(firefox_profile=profile)</p>
<h1 id="chrome">Chrome</h1>
<p>options = webdriver.ChromeOptions()<br>
options.add_argument('--ignore-certificate-errors')<br>
driver = webdriver.Chrome(chrome_options=options)</p>
<h1 id="ie">IE</h1>
<p>capabilities = webdriver.DesiredCapabilities().INTERNETEXPLORER<br>
capabilities['acceptSslCerts'] = True<br>
driver = webdriver.Ie(capabilities=capabilities)</p>
<p>• 如何实现鼠标悬停,键盘事件和拖拽动作?</p>
<p>使用ActionChains类的方法</p>
<p>click(on_element=None) ——单击鼠标左键<br>
click_and_hold(on_element=None) ——点击鼠标左键，不松开<br>
context_click(on_element=None) ——点击鼠标右键<br>
double_click(on_element=None) ——双击鼠标左键<br>
drag_and_drop(source, target) ——拖拽到某个元素然后松开<br>
drag_and_drop_by_offset(source, xoffset, yoffset) ——拖拽到某个坐标然后松开<br>
key_down(value, element=None) ——按下某个键盘上的键<br>
key_up(value, element=None) ——松开某个键<br>
move_by_offset(xoffset, yoffset) ——鼠标从当前位置移动到某个坐标<br>
move_to_element(to_element) ——鼠标移动到某个元素<br>
move_to_element_with_offset(to_element, xoffset, yoffset) ——移动到距某个元素（左上角坐标）多少距离的位置<br>
perform() ——执行链中的所有动作<br>
release(on_element=None) ——在某个元素位置松开鼠标左键<br>
send_keys(*keys_to_send) ——发送某个键到当前焦点的元素<br>
send_keys_to_element(element, *keys_to_send) ——发送某个键到指定元素</p>
<p>使用Keys类实现键盘事件：ele.send_keys(Keys.CONTROL,'x') 实现&quot;CTRL + X&quot;</p>
<p>• 如何获取页面标题，悬浮文本和错误文本，并验证?</p>
<p>assert driver.title == 'xx标题'<br>
悬浮文本和错误文本可以使用ActionChains().move_to_element() 然后ele.text</p>
<p>• 在selenium自动化测试中，你-般完成什么类型的测试?</p>
<p>回归测试</p>
<p>• 你是如何管理你的测试用例并执行?</p>
<p>测试用例按照业务模块划分成以test开头的py文件，pytest测试框架可识别以test开头或结尾的测试类或方法或文件，运行在根目录执行pytest 即可，当需要指定较多的参数或需要其他操作时定义run入口文件，直接运行run文件即可</p>
<p>• 关于自动化测试报告生成?</p>
<p>使用的是pytest-html库生成html报告及allure</p>
<p>• 你如何用Selenium测试?</p>
<p>将基础通用操作封装成base类，然后页面对象模型继承Base类。</p>
<p>• 如何解决问题?</p>
<p>针对UI自动化中遇到的问题，先查看报错信息，定位是自己封装问题则修改封装，非自己代码问题则先看实现相关功能模块依赖库的官方说明文档，官方文档中未解决问题，若是开源库则对应github参考查看issue栏目，最后再百度或谷歌</p>
<p>• 你是怎么开发测试框架的?</p>
<p>• 做自动化测试的目的?</p>
<p>接口自动化测试可尽快介入项目测试，在联调前发现编码中的问题，在版本更新发布后即进行接口自动化可对既有功能进行验证，保证此次新功能或bug修复对原有功能无影响。UI自动化可减少手工操作，进行兼容性测试。加快版本更新发布进度</p>
<p>• 如何判断case是否通过?</p>
<p>接口的case 根据规定的响应状态码 + 接口响应的值 + db 中对应的数据变化进行判断<br>
UI的case 根据业务场景进行后页面上的变动及相关特定提示语 ，也同样可根据db中的数据状态进行判断</p>
<p>• 你项目中有多少case,通过率怎么样?</p>
<p>UI的case 单次运行目前通过率大约在95% 以上，通过加入失败重试机制后大约98%-99%左右</p>
<p>• 失败截图的原理是什么?</p>
<p>我在框架中使用driver.get_screenshot_as_png() 方法在Base类中使用try expect在expect时即调用截图方法</p>
<p>具体实现没看出来</p>
<p>• 报告哪里来，主要统计什么?</p>
<p>使用第三方库实现，统计用例成功失败，跳过，条数，运行时间、环境等</p>
<p>• testNG中注解有哪些</p>
<p>• TestNG有哪些优点</p>
<p>• 什么是web自动化</p>
<p>• 写出selenium中你最熟悉的接口或者类</p>
<p>WebDriverWait：显示等待的类<br>
webdrier.Chrome：实例化Chrome driver实例</p>
<p>• Xpath是什么?</p>
<p>一门查找XML文档中信息的语言</p>
<p>• findElement()和findElements()方法有什么区别</p>
<p>前者返回一个WebElement对象，后者返回一个由WebElement 组成的list</p>
<p>• 登录按钮除了click方法还有其他方式吗?</p>
<p>driver.submit()</p>
<p>• 怎么对含有验证码的功能进行自动化测试</p>
<p>简单验证码使用PIL库进行解决，过于复杂，识别难度过高与开发沟通使用通用验证码，或者使用第三方服务提供的图片识别服务</p>
<p>• 举一个WebDriver中方 法重载的例子</p>
<p>webdriver.Chrome() 的__init__方法即重载了RemoteWebDriver的__init__方法</p>
<p>• 你如何模拟浏览器的前后移动?</p>
<p>driver.forward()<br>
driver.back()</p>
<p>• 你如何获得当前页面的URL?</p>
<p>driver.current_url</p>
<p>• 如何在WebDriver中实现同步?</p>
<p>• 如何从文本框中获取打字文本?</p>
<p>ele.text</p>
<p>• 你如何清除中文本框的内容?</p>
<p>ele.clear()</p>
<p>• 如何在webdriver中调用应用程序?</p>
<p>• 如何获取页面上的帧数?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Python进行Dubbo服务接口测试]]></title>
        <id>https://grassroadsz.github.io/post/shi-yong-python-jin-xing-dubbo-fu-wu-jie-kou-ce-shi/</id>
        <link href="https://grassroadsz.github.io/post/shi-yong-python-jin-xing-dubbo-fu-wu-jie-kou-ce-shi/">
        </link>
        <updated>2022-05-27T06:02:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>good good study day day up</p>
</blockquote>
<p>使用python请求dubbo服务</p>
<p>请求方式<br>
● 跳过zk，直接使用telnet命令请求dubbo服务<br>
● 连接zk，通过zk找到对应的dubbo服务的ip及port，使用telnet命令请求</p>
<p>方式一<br>
参考代码</p>
<pre><code class="language-python">import json
import telnetlib
import socket


class Dubbo(telnetlib.Telnet):
    prompt = 'dubbo&gt;'
    coding = 'gbk'

    def __init__(self, host=None, port=0,
                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        super().__init__(host, port)
        self.write(b'\n')

    def command(self, flag, str_=&quot;&quot;):
        data = self.read_until(flag.encode())
        self.write(str_.encode() + b&quot;\n&quot;)
        return data

    def invoke(self, service_name, method_name, arg):
        command_str = &quot;invoke {0}.{1}({2})&quot;.format(
            service_name, method_name, json.dumps(arg))
        self.command(Dubbo.prompt, command_str)
        data = self.command(Dubbo.prompt, &quot;&quot;)
        data = data.decode(&quot;utf-8&quot;,
                           errors='ignore').split('\n')[1].strip()

        return data


if __name__ == '__main__':
    # Dubbo服务的ip, 与port
    conn = Dubbo('192.168.227.237', 34510)

    json_data = {&quot;dtlBeanList&quot;: [
        {&quot;cost&quot;: 100, &quot;memoSku&quot;: &quot;haha&quot;, &quot;orderUnit&quot;: &quot;EAJ&quot;, &quot;poNo&quot;: &quot;string&quot;, &quot;qty&quot;: 10, &quot;seq&quot;: &quot;1&quot;, &quot;sku&quot;: &quot;999999&quot;,
         &quot;unitCost&quot;: 10}], &quot;mstBean&quot;: {&quot;address&quot;: &quot;string&quot;, &quot;cancelDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;city&quot;: &quot;string&quot;,
                                       &quot;comCode&quot;: &quot;ZB91&quot;, &quot;currency&quot;: &quot;string&quot;, &quot;issuedBy&quot;: &quot;string&quot;, &quot;memo&quot;: &quot;string&quot;,
                                       &quot;orderDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;orderType&quot;: 0, &quot;poNo&quot;: &quot;2801723696&quot;,
                                       &quot;province&quot;: &quot;string&quot;, &quot;receiver&quot;: &quot;string&quot;, &quot;receiverPhone&quot;: &quot;string&quot;,
                                       &quot;refPoNo&quot;: &quot;string&quot;, &quot;refStoreCode&quot;: &quot;2588&quot;, &quot;region&quot;: &quot;string&quot;, &quot;serviceFee&quot;: 0,
                                       &quot;status&quot;: 0, &quot;storeCode&quot;: &quot;2588&quot;, &quot;street&quot;: &quot;string&quot;, &quot;totalPrice&quot;: 0,
                                       &quot;vendorCode&quot;: &quot;string&quot;}}

    result = conn.invoke(&quot;com.bnq.supplier.sp.enpower.api.service.IEnpowerPlatformServiceRPC&quot;,
                         &quot;saveChannelOrder&quot;,
                         json_data
                         )
    print(result)
</code></pre>
<p>缺点<br>
● dubbo服务ip地址，port均会发生变化，通过写死的ip和port直连dubbo服务不利于使用脚本集成，dubbo服务重启，对应的ip和port在脚本中均需要修改</p>
<p>方式二<br>
参考代码</p>
<pre><code class="language-python">import urllib
import json
import telnetlib
from urllib.parse import unquote

# 需要安装kazoo依赖库
from kazoo.client import KazooClient


class Dubbo(telnetlib.Telnet):
    prompt = 'dubbo&gt;'
    coding = 'utf-8'

    def __init__(self, host=None, port=0, timeout=10):
        super().__init__(host, port)
        self.write(b'\n')

    def command(self, flag, str_=&quot;&quot;):
        data = self.read_until(flag.encode())
        self.write(str_.encode() + b&quot;\n&quot;)
        return data

    def invoke(self, service_name, method_name, arg):
        command_str = &quot;invoke {0}.{1}({2})&quot;.format(
            service_name, method_name, json.dumps(arg))
        self.command(Dubbo.prompt, command_str)
        data = self.command(Dubbo.prompt, &quot;&quot;)
        data = data.decode(&quot;utf-8&quot;,
                           errors='ignore').split('\n')[1].strip()

        return data


class DubboUtils(object):
    def __init__(self, zk_service, interface):
        self.zk_service = zk_service
        self.interface = interface

    def _get_dubbo(self, server_name):
        &quot;&quot;&quot;
        获取单个dubbo服务的
        :param server_name:服务名
        :return:{&quot;service&quot;: service, &quot;paths&quot;: paths, &quot;method&quot;: method}
        &quot;&quot;&quot;
        zk = KazooClient(hosts=&quot;{}&quot;.format(self.zk_service))
        zk.start()
        urls = []
        service_list = zk.get_children(&quot;dubbo&quot;)
        for i in service_list:
            if server_name in i:
                try:
                    # 获取服务发布方
                    providers = zk.get_children(&quot;/dubbo/{}/providers&quot;.format(i))
                    if providers:
                        for provider in providers:
                            url = urllib.parse.unquote(provider)
                            if url.startswith('dubbo:'):
                                urls.append(url.split('dubbo://')[1])
                except Exception as e:
                    print(e)
        paths = []
        for i in urls:
            try:
                path, temp = i.split('/')
                service = temp.split('?')[0]
                method = temp.split('methods=')[1].split('&amp;')[0].split(',')
                paths.append(path)
            except Exception as e:
                print(e)
        services = {&quot;service&quot;: service, &quot;paths&quot;: paths, &quot;method&quot;: method}
        zk.stop()
        return services

    def requests_dubbo(self, method, param):
        &quot;&quot;&quot;
        请求dubbo接口
        :param method: dubbo接口的方法
        :param param: 请求参数
        :return:
        &quot;&quot;&quot;
        res = self._get_dubbo(self.interface)
        methods = res.get(&quot;method&quot;)
        if method not in methods:
            raise NameError(f&quot;{method} not in {methods}&quot;)
        ip, port = res.get(&quot;paths&quot;)[0].split(&quot;:&quot;)
        con = Dubbo(ip, port)
        result = con.invoke(self.interface, method, param)
        return result


if __name__ == '__main__':
    d = DubboUtils(&quot;zk-dev&quot;, 'com.bnq.supplier.sp.enpower.api.service.IEnpowerPlatformServiceRPC')
    json_data = {&quot;dtlBeanList&quot;: [
        {&quot;cost&quot;: 100, &quot;memoSku&quot;: &quot;haha&quot;, &quot;orderUnit&quot;: &quot;EAJ&quot;, &quot;poNo&quot;: &quot;string&quot;, &quot;qty&quot;: 10, &quot;seq&quot;: &quot;1&quot;, &quot;sku&quot;: &quot;999999&quot;,
         &quot;unitCost&quot;: 10}], &quot;mstBean&quot;: {&quot;address&quot;: &quot;string&quot;, &quot;cancelDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;city&quot;: &quot;string&quot;,
                                       &quot;comCode&quot;: &quot;ZB91&quot;, &quot;currency&quot;: &quot;string&quot;, &quot;issuedBy&quot;: &quot;string&quot;, &quot;memo&quot;: &quot;string&quot;,
                                       &quot;orderDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;orderType&quot;: 0, &quot;poNo&quot;: &quot;2801723696&quot;,
                                       &quot;province&quot;: &quot;string&quot;, &quot;receiver&quot;: &quot;string&quot;, &quot;receiverPhone&quot;: &quot;string&quot;,
                                       &quot;refPoNo&quot;: &quot;string&quot;, &quot;refStoreCode&quot;: &quot;2588&quot;, &quot;region&quot;: &quot;string&quot;, &quot;serviceFee&quot;: 0,
                                       &quot;status&quot;: 0, &quot;storeCode&quot;: &quot;2588&quot;, &quot;street&quot;: &quot;string&quot;, &quot;totalPrice&quot;: 0,
                                       &quot;vendorCode&quot;: &quot;string&quot;}}

    print(d.requests_dubbo(&quot;saveChannelOrder&quot;, json_data))

</code></pre>
<p>优点<br>
● 先连接zookeeper注册中心，通过zookeeper注册中心获取到dubbo服务的ip和port，保证每次获取到的ip和port均是正确可用的，便于与脚本进行集成<br>
缺点<br>
● 可能是因为需要先连接zk注册中心，然后获取dubbo服务，耗时比直接使用telnet命令时间稍长，约1s(对于测试脚本来说速度完全可以接受)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊入门-1 基础准备]]></title>
        <id>https://grassroadsz.github.io/post/yi-tai-fang-ru-men-1-ji-chu-zhun-bei/</id>
        <link href="https://grassroadsz.github.io/post/yi-tai-fang-ru-men-1-ji-chu-zhun-bei/">
        </link>
        <updated>2022-05-14T15:59:20.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>添加测试网Rinkeby 地址,使用 chainlink: <code>https://chainlist.quantclass.cn/</code></li>
<li>默认的测试网选项没有打开，需要使用设置 --&gt; 高级 -- &gt; 显示测试网络</li>
<li>测试币领取 <code>https://faucet.rinkeby.io/</code> 打开<code>https://twitter.com/intent/tweet?text=Requesting%20faucet%20funds%20into%200x0000000000000000000000000000000000000000%20on%20the%20%23Rinkeby%20%23Ethereum%20test%20network.</code> 将 其中的 000 改成自己的地址 ，发送twitter 后将twitter 地址copy 到 领水地址 进行领水</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊入门开发课]]></title>
        <id>https://grassroadsz.github.io/post/yi-tai-fang-ru-men-kai-fa-ke/</id>
        <link href="https://grassroadsz.github.io/post/yi-tai-fang-ru-men-kai-fa-ke/">
        </link>
        <updated>2022-05-14T15:59:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://forested-celsius-818.notion.site/62be43fb25c84db1965eb21f620087b0">课程学员手册</a></p>
<h2 id="以太坊入门-1-基础准备">以太坊入门-1 基础准备</h2>
<ul>
<li>添加测试网Rinkeby 地址,使用 chainlink: <a href="https://chainlist.quantclass.cn/">https://chainlist.quantclass.cn/</a></li>
<li>默认的测试网选项没有打开，需要使用设置 --&gt; 高级 -- &gt; 显示测试网络</li>
<li>测试币领取<a href="https://faucet.rinkeby.io/">https://faucet.rinkeby.io/</a><br>
打开<code>https://twitter.com/intent/tweet?text=Requesting%20faucet%20funds%20into%200x0000000000000000000000000000000000000000%20on%20the%20%23Rinkeby%20%23Ethereum%20test%20network.</code> 将 其中的 000 改成自己的地址 ，发送twitter 后将twitter 地址copy 到 领水地址 进行领水</li>
</ul>
<h2 id="arbitrum">Arbitrum</h2>
<ul>
<li>
<p>跨链桥：<code>https://bridge.arbitrum.io/</code></p>
<p>合约交互代码</p>
<pre><code class="language-python">def connect_web3_instance(network=&quot;mainnet&quot;):
  # 使用dotenv 进行配置的管理 此处只需要使用 Infura 的project_id 即可
  INFURA_PROJECT_ID = os.getenv('INFURA_PROJECT_ID')
  INFURA_MAIN_NETWORK = f'https://{network}.infura.io/v3/{INFURA_PROJECT_ID}'

  web3_instance = Web3(Web3.HTTPProvider(endpoint_uri=INFURA_MAIN_NETWORK))
  print(web3_instance.isConnected())
  return web3_instance


def bridge_arbitrum(from_address, from_address_private_key, l1_amount):
  &quot;&quot;&quot;
  Arbitrum 测试网跨链桥
  &quot;&quot;&quot;
  ArbitrumProxyContract = &quot;0x578BAde599406A8fE3d24Fd7f7211c0911F5B29e&quot;
  ArbitrumProxyContractAbi = '[{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;messageNum&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;InboxMessageDelivered&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;messageNum&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;InboxMessageDeliveredFromOrigin&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;enabled&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;name&quot;:&quot;PauseToggled&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;enabled&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;name&quot;:&quot;RewriteToggled&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newSource&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;WhitelistSourceUpdated&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;bridge&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;contract IBridge&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;createRetryableTicket&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;createRetryableTicketNoRefundAliasRewrite&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;depositEth&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;contract IBridge&quot;,&quot;name&quot;:&quot;_bridge&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;_whitelist&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;initialize&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;isCreateRetryablePaused&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;isMaster&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;pauseCreateRetryables&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendContractTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL1FundedContractTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;nonce&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL1FundedUnsignedTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;messageData&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL2Message&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;messageData&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL2MessageFromOrigin&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;nonce&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendUnsignedTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;shouldRewriteSender&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;startRewriteAddress&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;stopRewriteAddress&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;unpauseCreateRetryables&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;unsafeCreateRetryableTicket&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newSource&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;updateWhitelistSource&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;whitelist&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;}]'
  web3_instance = connect_web3_instance(&quot;rinkeby&quot;)

  # 通过合约地址 以及abi 实例化的 对象才可以使用abi中的方法进行调用
  ArbitrumProxyContractInstance = web3_instance.eth.contract(address=Web3.toChecksumAddress(ArbitrumProxyContract),
                                                             abi=ArbitrumProxyContractAbi)

  l1_amount = web3_instance.toWei(l1_amount, &quot;ether&quot;)
  from_address_balance = web3_instance.eth.get_balance(web3_instance.toChecksumAddress(from_address))
  print(f&quot;{from_address} 的 地址余额 为 {float(from_address_balance / 1e18)} ETH,转账 {l1_amount / 1e18} ETH&quot;)

  function_instance = ArbitrumProxyContractInstance.functions.depositEth(maxSubmissionCost=l1_amount)

  params = {

      'gas': 250000,
      'nonce': web3_instance.eth.getTransactionCount(web3_instance.toChecksumAddress(from_address)),
      'from': web3_instance.toChecksumAddress(from_address),
      'value': l1_amount,
      # 'gasPrice': w3.toWei('5', 'gwei'),
      'maxFeePerGas': web3_instance.toWei(5, 'gwei'),
      'maxPriorityFeePerGas': web3_instance.toWei(5, 'gwei'),
      'chainId': 4,

  }
  try:
      # 构建tx
      tx = function_instance.buildTransaction(params)
      # 签名
      sign_tx = web3_instance.eth.account.signTransaction(tx, private_key=from_address_private_key)
      # 发送交易
      txn = web3_instance.eth.sendRawTransaction(sign_tx.rawTransaction)
      from_address_balance = web3_instance.eth.get_balance(web3_instance.toChecksumAddress(from_address))
      print(f&quot;{from_address} 的 地址余额 为 {float(from_address_balance / 1e18)} ETH&quot;)

      return {'status': 'succeed', 'txn_hash': web3_instance.toHex(txn), 'task': 'Bridge ETH'}

  except Exception as e:
      return {'status': 'failed', 'error': e, 'task': 'Bridge ETH'}
</code></pre>
</li>
</ul>
<pre><code>


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试文章]]></title>
        <id>https://grassroadsz.github.io/post/ce-shi-wen-zhang/</id>
        <link href="https://grassroadsz.github.io/post/ce-shi-wen-zhang/">
        </link>
        <updated>2022-05-12T23:38:51.000Z</updated>
        <content type="html"><![CDATA[<p>测试文章</p>
]]></content>
    </entry>
</feed>