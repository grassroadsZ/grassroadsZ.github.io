<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://grassroadsz.github.io</id>
    <title>Gridea</title>
    <updated>2022-05-28T07:51:29.862Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://grassroadsz.github.io"/>
    <link rel="self" href="https://grassroadsz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://grassroadsz.github.io/images/avatar.png</logo>
    <icon>https://grassroadsz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[UI自动化文件上传]]></title>
        <id>https://grassroadsz.github.io/ui-zi-dong-hua-wen-jian-shang-chuan/</id>
        <link href="https://grassroadsz.github.io/ui-zi-dong-hua-wen-jian-shang-chuan/">
        </link>
        <updated>2022-05-28T06:52:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文链接 https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-upload_file.html#4520068</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>实施UI自动化测试的时候，经常会遇见上传文件的操作，那么对于上传文件你知道几种方法呢？今天我们就总结一下几种常用的上传文件的方法，并分析一下每个方法的优点和缺点以及哪种方法效率，稳定性更高</p>
<h2 id="被测html代码">被测HTML代码</h2>
<figure data-type="image" tabindex="1"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;!--upload_file.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;上传文件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;upload_file&quot; type=&quot;file&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<p>第一种方法：使用webdriver api 提供的方法send_keys上传文件</p>
<h2 id="send_keys方法">send_keys方法</h2>
<h3 id="实例">实例</h3>
<figure data-type="image" tabindex="3"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
&quot;&quot;&quot; 
from selenium import webdriver
import time


driver = webdriver.Firefox()
driver.get(r'file:///e:/CnblogCode/upload_file.html')
upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
time.sleep(3)  # 为了看效果
upload_element.send_keys(r'E:CnblogCodeupload_file.html')
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<h3 id="执行过程">执行过程</h3>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718141749877-90060948.gif" alt="" loading="lazy"></figure>
<p>可以看到执行过程很顺利，且代码实现简单，也没有报错</p>
<p>但是往往现实是残酷的，因为有的网站的上传文件并不是采用 input标签来定义的上传文件按钮，所以就无法使用send_keys方法上传，这也是这个方法的限制</p>
<h2 id="autoit工具">AutoIt工具</h2>
<p>第二种方法是AutoIT工具，它是一个类似脚本语言的软件，利用此软件我们可以方便的实现模拟键盘、鼠标、窗口等操作，实现自动化</p>
<h3 id="安装">安装</h3>
<p>官网地址：<a href="https://www.autoitscript.com/site/autoit/downloads/">https://www.autoitscript.com/site/autoit/downloads/</a></p>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718145953994-1855651642.png" alt="" loading="lazy"></figure>
<p>安装完后可以找到如下一些工具</p>
<figure data-type="image" tabindex="7"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718150114641-2141840187.png" alt="" loading="lazy"></figure>
<h3 id="使用">使用</h3>
<ol>
<li>
<p>打开被测试的HTML页面，并点击上传文件，弹出上传文件窗口，并保持当前窗口</p>
</li>
<li>
<p>打开AutoIt Window Info(x86/x64)工具</p>
</li>
<li>
<p>点击工具中Finder Tool标签下的按钮，开始分别定位上传文件的【输入框】和【打开】按钮，并记录Title，Class，Instance（图中红色窗口中的信息）</p>
</li>
</ol>
<p>注意：不同的浏览器抓取的Title是不一样的（Firefox：文件上传，Chrome：打开，IE：选择要加载的文件)</p>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718150637174-380718539.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>打开 SciTE Script Editor<img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718153911035-1870937893.png" alt="" loading="lazy"><br>
工具开始编写脚本(注意脚本中的Edit1是class 和 instance 拼接的)</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-shell">;first make sure the number of arguments passed into the scripts is more than 1 If $CmdLine[0]&lt;2 Then Exit EndIf ;if parmas num &lt;2 ,then break ;$CmdLine[0] ;参数的数量
;$CmdLine[1] ;第一个参数 (脚本名称后面)
;$CmdLine[2] ;第二个参数
;都是从cmd传入参数
 handleUpload($CmdLine[1],$CmdLine[2])

;定义上传函数，有两个参数，第一个是浏览器名字，第二参数是文件路径
 Func handleUpload($browser, $uploadfile)
     Dim $title                          ;定义一个title变量
            ;根据弹窗的title来判断是什么浏览器
            If $browser=&quot;ie&quot; Then                          ; 代表IE浏览器
                  $title=&quot;选择要加载的文件&quot; ElseIf $browser=&quot;chrome&quot; Then               ; 代表谷歌浏览器
                 $title=&quot;打开&quot; ElseIf    $browser=&quot;firefox&quot; Then             ; 代表火狐浏览器
                  $title=&quot;文件上传&quot; EndIf if WinWait($title,&quot;&quot;,4) Then ;等待弹出出现，最大等待时间是4秒
                   WinActivate($title)                  ;找到弹出窗口之后，激活当前窗口
                   ControlSetText($title,&quot;&quot;,&quot;Edit1&quot;,$uploadfile)   ;把文件路径放入输入框，此”Edit1“是用FinderTool获取到的
                   ControlClick($title,&quot;&quot;,&quot;Button1&quot;)                ;点击保存或者打开或者上传按钮，此“Button1”使用FinderTool获取到的
            Else
            Return False
            EndIf
 EndFunc
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<ol start="5">
<li>编译脚本为exe可执行文件</li>
</ol>
<p>编写完脚本之后，保存文件并打开Compile Script to .exe(x64/x86)工具 <img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718153828567-1147124643.png" alt="" loading="lazy"><br>
，将保存后的脚本.au3文件转换为.exe可执行文件</p>
<ol start="6">
<li>执行转换后的脚本</li>
</ol>
<p>在执行脚本之前，先确保上传文件的窗口已经打开，接下来打开cmd执行exe程序  C:Usersv-xugDesktop&gt;upload_file_new.exe firefox E:CnblogCodeupload_file.html</p>
<ol start="7">
<li>执行效果</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718161454802-676243340.gif" alt="" loading="lazy"></figure>
<ol start="8">
<li>编写selenium脚本</li>
</ol>
<h3 id="实例-2">实例</h3>
<figure data-type="image" tabindex="12"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
from selenium.webdriver.common.action_chains import ActionChains 
import os
from selenium import webdriver
import time 

class Base(object):

    @staticmethod def upload_file(exe, browser, filename): &quot;&quot;&quot; 使用autoIt上传文件
        :param exe: 上传文件的exe程序所在目录
        :param browser: 浏览器类型： firefox chrome ie
        :param filename: 待上传文件路径
        :return: none &quot;&quot;&quot; cmd = exe + ' ' + browser + ' ' + filename
        os.system(cmd) if __name__ == '__main__':
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')  # 打开被测html
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()  # 点击上传文件弹出上传文件窗口
    action.release()
    time.sleep(3)  # 为了看效果
    Base.upload_file(r'E:CnblogCodeupload_file_new.exe', 'firefox', r'E:CnblogCodeupload_file.html')  # 上传文件

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://common.cnblogs.com/images/copycode.gif" alt="" loading="lazy"></figure>
<h3 id="执行过程-2">执行过程</h3>
<figure data-type="image" tabindex="14"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718170623032-66535341.gif" alt="" loading="lazy"></figure>
<p>以上就是使用AutoId工具完成上传文件的过程，其实还是挺复杂的， 但是配置一次之后，以后就可以重复使用编译生成的exe文件了，执行效果还是不错的 没出什么错误，执行效率也还可以</p>
<h2 id="模拟键盘">模拟键盘</h2>
<p>第三种方法：模拟键盘的粘贴与回车操作并结合剪切板的操作来完成上传文件，基本原理是向剪切板中发送文件(文件路径字符串)，然后再从剪切板中获取到文件，最后通过模拟键盘的ctrl+v与enter键来完成文件上传</p>
<p>这种方法需要第三方库的支持，安装pypiwin32库： pip install pypiwin32</p>
<h3 id="实例-3">实例</h3>
<p>模拟键盘操作代码</p>
<figure data-type="image" tabindex="15"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">import win32api import win32con
import time 

class KeyBoard(object): 
    &quot;&quot;&quot;模拟按键&quot;&quot;&quot;
    # 键盘码
    vk_code = { 'enter' : 0x0D, 'ctrl' : 0x11, 'v' : 0x56 }

    @staticmethod def keyDown(key_name): &quot;&quot;&quot;按下键&quot;&quot;&quot; key_name = key_name.lower() try:
            win32api.keybd_event(KeyBoard.vk_code[key_name], 0, 0, 0) except Exception as e: print('未按下enter键') raise e

    @staticmethod def keyUp(key_name): &quot;&quot;&quot;抬起键&quot;&quot;&quot; key_name = key_name.lower()
        win32api.keybd_event(KeyBoard.vk_code[key_name], 0, win32con.KEYEVENTF_KEYUP, 0)

    @staticmethod def oneKey(key): &quot;&quot;&quot;模拟单个按键&quot;&quot;&quot; key = key.lower()
        KeyBoard.keyDown(key)
        time.sleep(2)
        KeyBoard.keyUp(key)

    @staticmethod def twoKeys(key1, key2): &quot;&quot;&quot;模拟组合按键&quot;&quot;&quot; key1 = key1.lower()
        key2 = key2.lower()
        KeyBoard.keyDown(key1)
        KeyBoard.keyDown(key2)
        KeyBoard.keyUp(key1)
        KeyBoard.keyUp(key2) if __name__ == '__main__': pass
</code></pre>
<p>keyboard.py</p>
<p>剪切板操作代码</p>
<figure data-type="image" tabindex="16"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">
import win32con 
import win32clipboard as WC 

class ClipBoard(object): 
    &quot;&quot;&quot;设置剪切板内容和获取剪切板内容&quot;&quot;&quot; 
    
    @staticmethod def getText(): &quot;&quot;&quot;获取剪切板的内容&quot;&quot;&quot; 
        WC.OpenClipboard()
        value = WC.GetClipboardData(win32con.CF_TEXT)
        WC.CloseClipboard() return value

    @staticmethod def setText(value): &quot;&quot;&quot;设置剪切板的内容&quot;&quot;&quot; 
        WC.OpenClipboard()
        WC.EmptyClipboard()
        WC.SetClipboardData(win32con.CF_UNICODETEXT, value)
        WC.CloseClipboard() 
if __name__ == '__main__': 
    pass
</code></pre>
<p>clipboard.py</p>
<p>上传文件代码</p>
<figure data-type="image" tabindex="17"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">from clipboard import ClipBoard 
from keyboard import KeyBoard 
from selenium import webdriver 
import time 
from selenium.webdriver.common.action_chains import ActionChains 

if __name__ == '__main__':
    ClipBoard.setText(r'E:CnblogCodeupload_file.html')  # 待上传文件设置到剪切板
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()
    action.release()
    time.sleep(3)  # 为了看效果
    KeyBoard.twoKeys('ctrl', 'v')
    KeyBoard.oneKey('enter')

upload_file_board.py
</code></pre>
<h3 id="执行过程-3">执行过程</h3>
<figure data-type="image" tabindex="18"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718173040775-1045026529.gif" alt="" loading="lazy"></figure>
<p>失败</p>
<figure data-type="image" tabindex="19"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718173123389-1294379262.gif" alt="" loading="lazy"></figure>
<p>可以看到第二个动画上传文件未成功，这也就这个方法的弊端，只要移动了鼠标就有可能就不会成功，毕竟模拟的是enter键，这个过程你点击了别的地方，那么enter的效果就变了，所以这种方法很不稳定，也不难发现，代码量也很多，而且需要掌握模拟键盘和剪切板的操作，最不推荐使用的就是这种方法</p>
<p>之前我的实战项目里面，用到过这种方法， 当时我已经发现了这种方法的弊端， 但是为了掌握这种模拟键盘的方法，所以才使用的，当然模拟键盘操作用到一些特殊的情况还是能解决很多实际问题的</p>
<h2 id="winspy工具">WinSpy工具</h2>
<p>第四种方法：这个工具其实和AutoIt工具的元素定位方式一样，但是不需要生成exe文件，其实只是个辅助工具，主要用来获取windows窗口句柄，进而通过python脚本来控制</p>
<h3 id="winspy安装">WinSpy安装</h3>
<p><a href="https://sourceforge.net/projects/winspyex/">https://sourceforge.net/projects/winspyex/</a></p>
<p>下载完直接解压打开WinSpy32(64).exe即可使用</p>
<p>使用方法和autoId一样，请按照下图的步骤操作，记录winspy-Tree中红框信息</p>
<figure data-type="image" tabindex="20"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718174930856-1995061900.png" alt="" loading="lazy"></figure>
<p>编写代码之前，同样需要提前安装 pypiwin32库</p>
<h3 id="实例-4">实例</h3>
<figure data-type="image" tabindex="21"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" loading="lazy"></figure>
<pre><code class="language-python">from selenium.webdriver.common.action_chains import ActionChains
from selenium import webdriver
import win32con 
import win32gui 
import time 

def upload_file(browser: str, file: str):
    browser_type = { &quot;firefox&quot;: &quot;文件上传&quot;, &quot;chrome&quot;: &quot;打开&quot;, &quot;ie&quot;: &quot;选择要加载的文件&quot; }
    time.sleep(2)
    dialog = win32gui.FindWindow(&quot;#32770&quot;, browser_type[browser])  # 火狐浏览器为”文件上传“，谷歌为”打开“
    combobox_ex32 = win32gui.FindWindowEx(dialog, 0, &quot;ComboBoxEx32&quot;, None)
    combobox = win32gui.FindWindowEx(combobox_ex32, 0, 'ComboBox', None)
    edit = win32gui.FindWindowEx(combobox, 0, 'Edit', None)
    button = win32gui.FindWindowEx(dialog, 0, 'Button', None)
    win32gui.SendMessage(edit, win32con.WM_SETTEXT, None, file)
    win32gui.SendMessage(dialog, win32con.WM_COMMAND, 1, button) if __name__ == '__main__':
    driver = webdriver.Firefox()
    driver.get(r'file:///e:/CnblogCode/upload_file.html')
    upload_element = driver.find_element_by_xpath('//*[@id=&quot;upload_file&quot;]')
    action = ActionChains(driver)
    action.move_to_element(upload_element).click().perform()
    action.release()
    time.sleep(3)  # 为了看效果
    upload_file('firefox', r'E:CnblogCodeupload_file.html')
</code></pre>
<p>load_file_winspy.py</p>
<h3 id="执行过程-4">执行过程</h3>
<figure data-type="image" tabindex="22"><img src="https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190718175927417-974106887.gif" alt="" loading="lazy"></figure>
<p>此方法也比较稳定，只要通过传递不同的浏览器参数，即可完成不同浏览器中的上传文件操作，而且相比于AutoId而言，这种方法可以直接使用python编写代码且不需要编译成exe程序，可以随时对代码进行修改，易维护</p>
<h2 id="总结">总结</h2>
<p>最后总结一下每个方法的优缺点</p>
<ol>
<li>
<p>send_keys(): 如果所遇见的上传文件使用的是input标签且属性type=file，均可使用，也最好采用此方法，方便，简单，执行效率高</p>
</li>
<li>
<p>AutoId： 需编写VBS代码并编译为exe可执行文件，过程繁琐，编写selenium测试用例时无法随时调试内部代码，但send_keys()无法使用时，可以采用此方法，执行效率较高，稳定性也算可以</p>
</li>
<li>
<p>模拟键盘和剪切板： 此方法需要掌win32api，win32gui模块的使用，且代码编写繁琐，上传文件时如果鼠标点击其他地方会导致上传失败，脚本稳定性差，且效率低，但是如果用到一些特殊地方会起到比较好的效果</p>
</li>
<li>
<p>WinSpay：windows窗口句柄抓取工具，不需要编译脚本为exe文件，且上传文件操作使用的脚本是python第三方库实现，易维护，执行效率也较高，推荐send_keys()不可使用时，首先考虑此方法</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytest小结]]></title>
        <id>https://grassroadsz.github.io/pytest-xiao-jie/</id>
        <link href="https://grassroadsz.github.io/pytest-xiao-jie/">
        </link>
        <updated>2022-05-27T15:17:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<pre><code class="language-shell">pip3 install -U pytest -i http://pypi.douban.com/sample
# html报告
pip install pytest-HTML 
# 失败重跑
pip install pytest-rerunfailures
# html 报告插件
pip install pytest-allure-adaptor
allure软件
</code></pre>
<h1 id="运行">运行</h1>
<h2 id="文件规则">文件规则</h2>
<pre><code>查找当前目录及其子目录以test*.py开头或者*test.py的文件，找到文件后在文件中找到以test开头函数并执行
</code></pre>
<h2 id="用例规则">用例规则</h2>
<pre><code>- 测试文件以test开头或者以test结尾
- 测试类以Test开头，且类不能带有init方法
- 测试函数以test_开头，使用assert断言
- 所有的包Pakeage必须有init.py 文件
</code></pre>
<h2 id="cmd运行">cmd运行</h2>
<pre><code>- pytest

- py.test

- Python -m pytest
</code></pre>
<h2 id="运行参数">运行参数</h2>
<h3 id="无参数">无参数</h3>
<pre><code>读取dir下所有符合规则的文件、类和方法、函数并执行
pytest dir
</code></pre>
<h3 id="-v打印日志详细程度">-v(打印日志详细程度)</h3>
<pre><code>打印详细运行信息
</code></pre>
<h3 id="-s输出代码中的print">-s（输出代码中的print）</h3>
<pre><code>控制台输出结果
</code></pre>
<h3 id="-k-跳过">-k (跳过)</h3>
<pre><code>pytest -k '类名'
pytest -k '方法名'
pytest -k '类名 and 方法名'  # 运行类中所有的方法。不包含某个方法
</code></pre>
<h3 id="-x-遇到失败用例立即停止运行">-x （遇到失败用例立即停止运行）</h3>
<pre><code>P0级别用例一条失败即停止用例运行
pytest -x
</code></pre>
<h3 id="-maxfail-用例失败个数达到阈值即停止运行">-maxfail (用例失败个数达到阈值即停止运行)</h3>
<pre><code>P1级别10条用例最多失败多少条即停止执行所有用例
pytest -maxfail=num
</code></pre>
<h3 id="-n-并行运行">-n 并行运行</h3>
<pre><code>pip install pytest-xdist
</code></pre>
<p>安装后在命令行中指定-n 进程数即可(使用参数化时需要动态参数的情况时需先将动态生成的参数生成至文件后从文件读取，保证多个worker节点的数据一致)</p>
<h3 id="-m指定运行某个标记的用例">-m（指定运行某个标记的用例）</h3>
<pre><code class="language-python">@pytest.mark.shopping
def function():
pass
</code></pre>
<pre><code>pytest -m shopping
</code></pre>
<h3 id="指定运行">指定运行</h3>
<pre><code>- 文件级别：pytest filename.py
- 文件内某个函数：pytest file.py::test_func
- 文件内某个类的的某个方法：pytest file.py::TestClass::test_method
</code></pre>
<h3 id="pycharm">Pycharm</h3>
<p>file -&gt; Setting -&gt; Tools -&gt; Python Intergrated Tools -&gt;projectname -&gt; Default test runner -&gt; pytest</p>
<p>示例</p>
<pre><code class="language-python">import pytest
class TestClass:
    def test_add(self):
        assert 1 + 1 == 5
    def test_sub(self):
        assert 1 * 1 == 3
if __name__ == '__main__':
  # main 中需要传list
    pytest.main([&quot;-q test_example_run.py&quot;])
</code></pre>
<h1 id="用法">用法</h1>
<h2 id="前置后置">前置后置</h2>
<pre><code class="language-python">class TestA(object):

    @staticmethod
    def teardown():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @staticmethod
    def setup():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def setup_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def teardown_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    def test_01(self):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))
        assert 2 == 1


def setup_module():
    print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))


def teardown_module():
    print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))


class TestB(object):

    @staticmethod
    def teardown():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @staticmethod
    def setup():
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def setup_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    @classmethod
    def teardown_class(cls):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))

    def test_00(self):
        print(&quot;\n我的名字是{}&quot;.format(inspect.stack()[0][3]))
        assert 1 == 1


if __name__ == '__main__':
    pytest.main(['-sqv'])
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.nlark.com/yuque/0/2020/png/739683/1590631258407-3fa87540-1d05-4ac7-8695-4c8c7806527a.png?x-oss-process=image%2Fresize%2Cw_500%2Climit_0" alt="结果" loading="lazy"></figure>
<h3 id="conftestpy-pytestfixture">conftest.py-@pytest.fixture()</h3>
<pre><code>写在conftest.py文件中，不同的package可以有不同的conftest.py文件
</code></pre>
<h3 id="作用顺序">作用顺序</h3>
<pre><code>session &gt; module &gt; class &gt; function,
</code></pre>
<p>相同级别作用域的，其实例化顺序遵循它们在测试用例中被声明的顺序（也就是形参的顺序），或者fixture之间的相互调用关系；</p>
<p>使用autouse的fixture，先于其同级别的其它fixture实例化</p>
<pre><code class="language-python"># encoding:utf-8
# Motto：good good study, day day up. why you so lazy ？？？

import pytest

@pytest.fixture(scope='module',autouse=True) # 设置为autouse=True时在测试函数上面不需要写pytest.mark.fixture()
def open():
    print(&quot;这里类似于setup的操作，这里出错不会执行yield的操作&quot;)
    yield
    print(&quot;这里类似于teardown的操作，这期间raise不会影响执行&quot;)
# 除了使用yield 还可以使用addfinalizer，addfinalizer无论setup有无异常，均会执行类型teardown的操作
    
&quot;&quot;&quot;
使用方法：
1.可以测试类的每个测试方法都传一次调用
2.使用usefixture
当需要用到fixture的返回值时只能用fixture，不能用usefixtures
&quot;&quot;&quot;
class TestFix01:
    def test_01(self, login):
        pass

    def test_02(self, login):
        pass

# 使用usefixtures,每个测试函数都会调用
@pytest.mark.usefixtures(&quot;login&quot;)
class TestFix02:
    def test_01(self):
        pass

    def test_02(self):
        pass
    
# 使用多个usefixtures,先执行的在最下面
@pytest.mark.usefixtures(&quot;second&quot;)
@pytest.mark.usefixtures(&quot;first&quot;)
class TestFix03:
    def test_01(self):
        pass

    def test_02(self):
        pass
</code></pre>
<h3 id="参数化pytestmarkparametrize">参数化@pytest.mark.parametrize()</h3>
<pre><code class="language-python">@pytest.mark.parametrize(&quot;input_name, expect&quot;, [(1, 2), (3, 4), pytest.param(3, 7, marks=pytest.mark.xfail)],indirect=True)
# indirect=Truefixture定义的函数当成函数调用而不是参数
def test_add(input_name, expect):
    assert input_name == expect

@pytest.mark.parametrize(&quot;x&quot;, [(1, 2), (3, 4), pytest.param((3,), marks=pytest.mark.xfail)])
@pytest.mark.parametrize(&quot;y&quot;, [(1, 2), (3, 4), pytest.param((3,), marks=pytest.mark.xfail)])
def test_add(x, y):
    assert x == y
</code></pre>
<h3 id="标记pytestmarkmarkname">标记@pytest.mark.markname</h3>
<pre><code class="language-python"># 只运行mark=test的
@pytest.mark.test
def test_mark_name():
    print(&quot;这是测试mark标记的&quot;)

def test_a():
    print(&quot;这个么有mark&quot;)

if __name__ == '__main__':
    pytest.main([&quot;-m=test&quot;, &quot;test_mark.py&quot;])
</code></pre>
<h3 id="pytestini">pytest.ini</h3>
<pre><code class="language-ini">[pytest]
# 报告所有测试用例被跳过，预期失败，预期失败但是通过的原因
addopt = -rsxX

# 将被@pytest.mark.xfail但是实际却通过测试的用例改成失败
xfail_strict = true

# 记录标记的含义，可以使用pytest --markers查看
markers =
    test:测试mark标记

# 直接输入pytest 默认带上下列参数
addopts = -v --rerun 1 --html=report.html --self-contained-html
</code></pre>
<h3 id="pytest-html测试报告定制失败自动保存截图">pytest-html测试报告定制:失败自动保存截图</h3>
<pre><code class="language-python"># encoding:utf-8
# Motto：good good study, day day up. why you so lazy ？？？

import pytest
from selenium import webdriver
from py._xmlgen import html

driver = None

@pytest.fixture(scope='session', autouse=True)
def browser():
    global driver
    if driver is None:
        driver = webdriver.Chrome()
    return driver


def _capture_screenshot():
    return driver.get_screenshot_as_base64()


@pytest.mark.hookwrapper
def pytest_runtest_makereport(item):
    &quot;&quot;&quot;
    当测试失败的时候，自动截图，展示到html报告中
    :param item:
    &quot;&quot;&quot;
    pytest_html = item.config.pluginmanager.getplugin('html')
    outcome = yield
    report = outcome.get_result()
    extra = getattr(report, 'extra', [])

    if report.when == 'call' or report.when == &quot;setup&quot;:
        xfail = hasattr(report, 'wasxfail')
        if (report.skipped and xfail) or (report.failed and not xfail):
            file_name = report.nodeid.replace(&quot;::&quot;, &quot;_&quot;) + &quot;.png&quot;
            screen_img = _capture_screenshot()
            if file_name:
                html = '&lt;div&gt;&lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:600px;height:300px;&quot; ' \
                       'onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&gt;&lt;/div&gt;' % screen_img
                extra.append(pytest_html.extras.html(html))
        report.extra = extra
        report.description = str(item.function.__doc__)
        report.nodeid = report.nodeid.encode(&quot;utf-8&quot;).decode(&quot;unicode_escape&quot;)


@pytest.mark.optionalhook
def pytest_html_results_table_header(cells):
    cells.insert(1, html.th('Description'))
    cells.insert(2, html.th('Test_nodeid'))
    cells.pop(2)


@pytest.mark.optionalhook
def pytest_html_results_table_row(report, cells):
    cells.insert(1, html.td(report.description))
    cells.insert(2, html.td(report.nodeid))
    cells.pop(2)
</code></pre>
<h3 id="失败重跑">失败重跑</h3>
<pre><code>pip install pytest-rerunfailures
</code></pre>
<p>参数：</p>
<ul>
<li>--reruns=num 重试次数</li>
<li>--reruns-delay=time  失败后多少秒重新执行</li>
</ul>
<h3 id="命令行传参">命令行传参</h3>
<p>demo</p>
<pre><code class="language-python"># conftest.py
import pytest

def pytest_addoption(parser):
    '''添加命令行参数--env'''
    parser.addoption(
        &quot;--env&quot;, action=&quot;store&quot;, default=&quot;local&quot;, help=&quot;env option:  local or linux&quot;
    )
    parser.addoption(
        &quot;--user&quot;, action=&quot;store&quot;, default=&quot;user_1&quot;, help=&quot;env option:  user_1 or user_2&quot;
    )

@pytest.fixture(scope='session', autouse=True)
def begin(request):
    env = request.config.getoption(&quot;--env&quot;)
    user = request.config.getoption(&quot;--user&quot;)
    if env == 'local':
        print(&quot;这是本地环境&quot;)
    if user:
        print(&quot;我是用户{}&quot;.format(user))
        
# test_addoption.py
import pytest


@pytest.mark.parametrize('y', list(range(2)))
@pytest.mark.parametrize('x', list(range(2)))
def test_add(x, y):
    re = x + y
    assert re == 1

if __name__ == '__main__':
    pytest.main(['-vsq', '--user=user_1'])
</code></pre>
<pre><code>D:\Croe\pyest-doc\venv\Scripts\python.exe D:/Croe/pyest-doc/test_addoption.py
============================= test session starts =============================
platform win32 -- Python 3.8.0, pytest-5.4.2, py-1.8.1, pluggy-0.13.1
rootdir: D:\Croe\pyest-doc
collected 4 items

test_addoption.py 这是本地环境
我是用户user_1
F..F
</code></pre>
<h3 id="生成allure测试报告">生成allure测试报告</h3>
<p>下载安装allure2，配置环境变量</p>
<pre><code>pip3 install pytest-allure-adaptor
# 生成allure
pytest --alluredir=./allure_report --html=resutl.html --self-contained-html
# 本地打开(allure_report/html目录下的index.html)
allure generate ./allure_report -o ./allure_report/html
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Python进行Dubbo服务接口测试]]></title>
        <id>https://grassroadsz.github.io/shi-yong-python-jin-xing-dubbo-fu-wu-jie-kou-ce-shi/</id>
        <link href="https://grassroadsz.github.io/shi-yong-python-jin-xing-dubbo-fu-wu-jie-kou-ce-shi/">
        </link>
        <updated>2022-05-27T06:02:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>good good study day day up</p>
</blockquote>
<p>使用python请求dubbo服务</p>
<p>请求方式<br>
● 跳过zk，直接使用telnet命令请求dubbo服务<br>
● 连接zk，通过zk找到对应的dubbo服务的ip及port，使用telnet命令请求</p>
<p>方式一<br>
参考代码</p>
<pre><code class="language-python">import json
import telnetlib
import socket


class Dubbo(telnetlib.Telnet):
    prompt = 'dubbo&gt;'
    coding = 'gbk'

    def __init__(self, host=None, port=0,
                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        super().__init__(host, port)
        self.write(b'\n')

    def command(self, flag, str_=&quot;&quot;):
        data = self.read_until(flag.encode())
        self.write(str_.encode() + b&quot;\n&quot;)
        return data

    def invoke(self, service_name, method_name, arg):
        command_str = &quot;invoke {0}.{1}({2})&quot;.format(
            service_name, method_name, json.dumps(arg))
        self.command(Dubbo.prompt, command_str)
        data = self.command(Dubbo.prompt, &quot;&quot;)
        data = data.decode(&quot;utf-8&quot;,
                           errors='ignore').split('\n')[1].strip()

        return data


if __name__ == '__main__':
    # Dubbo服务的ip, 与port
    conn = Dubbo('192.168.227.237', 34510)

    json_data = {&quot;dtlBeanList&quot;: [
        {&quot;cost&quot;: 100, &quot;memoSku&quot;: &quot;haha&quot;, &quot;orderUnit&quot;: &quot;EAJ&quot;, &quot;poNo&quot;: &quot;string&quot;, &quot;qty&quot;: 10, &quot;seq&quot;: &quot;1&quot;, &quot;sku&quot;: &quot;999999&quot;,
         &quot;unitCost&quot;: 10}], &quot;mstBean&quot;: {&quot;address&quot;: &quot;string&quot;, &quot;cancelDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;city&quot;: &quot;string&quot;,
                                       &quot;comCode&quot;: &quot;ZB91&quot;, &quot;currency&quot;: &quot;string&quot;, &quot;issuedBy&quot;: &quot;string&quot;, &quot;memo&quot;: &quot;string&quot;,
                                       &quot;orderDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;orderType&quot;: 0, &quot;poNo&quot;: &quot;2801723696&quot;,
                                       &quot;province&quot;: &quot;string&quot;, &quot;receiver&quot;: &quot;string&quot;, &quot;receiverPhone&quot;: &quot;string&quot;,
                                       &quot;refPoNo&quot;: &quot;string&quot;, &quot;refStoreCode&quot;: &quot;2588&quot;, &quot;region&quot;: &quot;string&quot;, &quot;serviceFee&quot;: 0,
                                       &quot;status&quot;: 0, &quot;storeCode&quot;: &quot;2588&quot;, &quot;street&quot;: &quot;string&quot;, &quot;totalPrice&quot;: 0,
                                       &quot;vendorCode&quot;: &quot;string&quot;}}

    result = conn.invoke(&quot;com.bnq.supplier.sp.enpower.api.service.IEnpowerPlatformServiceRPC&quot;,
                         &quot;saveChannelOrder&quot;,
                         json_data
                         )
    print(result)
</code></pre>
<p>缺点<br>
● dubbo服务ip地址，port均会发生变化，通过写死的ip和port直连dubbo服务不利于使用脚本集成，dubbo服务重启，对应的ip和port在脚本中均需要修改</p>
<p>方式二<br>
参考代码</p>
<pre><code class="language-python">import urllib
import json
import telnetlib
from urllib.parse import unquote

# 需要安装kazoo依赖库
from kazoo.client import KazooClient


class Dubbo(telnetlib.Telnet):
    prompt = 'dubbo&gt;'
    coding = 'utf-8'

    def __init__(self, host=None, port=0, timeout=10):
        super().__init__(host, port)
        self.write(b'\n')

    def command(self, flag, str_=&quot;&quot;):
        data = self.read_until(flag.encode())
        self.write(str_.encode() + b&quot;\n&quot;)
        return data

    def invoke(self, service_name, method_name, arg):
        command_str = &quot;invoke {0}.{1}({2})&quot;.format(
            service_name, method_name, json.dumps(arg))
        self.command(Dubbo.prompt, command_str)
        data = self.command(Dubbo.prompt, &quot;&quot;)
        data = data.decode(&quot;utf-8&quot;,
                           errors='ignore').split('\n')[1].strip()

        return data


class DubboUtils(object):
    def __init__(self, zk_service, interface):
        self.zk_service = zk_service
        self.interface = interface

    def _get_dubbo(self, server_name):
        &quot;&quot;&quot;
        获取单个dubbo服务的
        :param server_name:服务名
        :return:{&quot;service&quot;: service, &quot;paths&quot;: paths, &quot;method&quot;: method}
        &quot;&quot;&quot;
        zk = KazooClient(hosts=&quot;{}&quot;.format(self.zk_service))
        zk.start()
        urls = []
        service_list = zk.get_children(&quot;dubbo&quot;)
        for i in service_list:
            if server_name in i:
                try:
                    # 获取服务发布方
                    providers = zk.get_children(&quot;/dubbo/{}/providers&quot;.format(i))
                    if providers:
                        for provider in providers:
                            url = urllib.parse.unquote(provider)
                            if url.startswith('dubbo:'):
                                urls.append(url.split('dubbo://')[1])
                except Exception as e:
                    print(e)
        paths = []
        for i in urls:
            try:
                path, temp = i.split('/')
                service = temp.split('?')[0]
                method = temp.split('methods=')[1].split('&amp;')[0].split(',')
                paths.append(path)
            except Exception as e:
                print(e)
        services = {&quot;service&quot;: service, &quot;paths&quot;: paths, &quot;method&quot;: method}
        zk.stop()
        return services

    def requests_dubbo(self, method, param):
        &quot;&quot;&quot;
        请求dubbo接口
        :param method: dubbo接口的方法
        :param param: 请求参数
        :return:
        &quot;&quot;&quot;
        res = self._get_dubbo(self.interface)
        methods = res.get(&quot;method&quot;)
        if method not in methods:
            raise NameError(f&quot;{method} not in {methods}&quot;)
        ip, port = res.get(&quot;paths&quot;)[0].split(&quot;:&quot;)
        con = Dubbo(ip, port)
        result = con.invoke(self.interface, method, param)
        return result


if __name__ == '__main__':
    d = DubboUtils(&quot;zk-dev&quot;, 'com.bnq.supplier.sp.enpower.api.service.IEnpowerPlatformServiceRPC')
    json_data = {&quot;dtlBeanList&quot;: [
        {&quot;cost&quot;: 100, &quot;memoSku&quot;: &quot;haha&quot;, &quot;orderUnit&quot;: &quot;EAJ&quot;, &quot;poNo&quot;: &quot;string&quot;, &quot;qty&quot;: 10, &quot;seq&quot;: &quot;1&quot;, &quot;sku&quot;: &quot;999999&quot;,
         &quot;unitCost&quot;: 10}], &quot;mstBean&quot;: {&quot;address&quot;: &quot;string&quot;, &quot;cancelDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;city&quot;: &quot;string&quot;,
                                       &quot;comCode&quot;: &quot;ZB91&quot;, &quot;currency&quot;: &quot;string&quot;, &quot;issuedBy&quot;: &quot;string&quot;, &quot;memo&quot;: &quot;string&quot;,
                                       &quot;orderDate&quot;: &quot;2020-06-22 07:11:40.238&quot;, &quot;orderType&quot;: 0, &quot;poNo&quot;: &quot;2801723696&quot;,
                                       &quot;province&quot;: &quot;string&quot;, &quot;receiver&quot;: &quot;string&quot;, &quot;receiverPhone&quot;: &quot;string&quot;,
                                       &quot;refPoNo&quot;: &quot;string&quot;, &quot;refStoreCode&quot;: &quot;2588&quot;, &quot;region&quot;: &quot;string&quot;, &quot;serviceFee&quot;: 0,
                                       &quot;status&quot;: 0, &quot;storeCode&quot;: &quot;2588&quot;, &quot;street&quot;: &quot;string&quot;, &quot;totalPrice&quot;: 0,
                                       &quot;vendorCode&quot;: &quot;string&quot;}}

    print(d.requests_dubbo(&quot;saveChannelOrder&quot;, json_data))

</code></pre>
<p>优点<br>
● 先连接zookeeper注册中心，通过zookeeper注册中心获取到dubbo服务的ip和port，保证每次获取到的ip和port均是正确可用的，便于与脚本进行集成<br>
缺点<br>
● 可能是因为需要先连接zk注册中心，然后获取dubbo服务，耗时比直接使用telnet命令时间稍长，约1s(对于测试脚本来说速度完全可以接受)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊入门-1 基础准备]]></title>
        <id>https://grassroadsz.github.io/yi-tai-fang-ru-men-1-ji-chu-zhun-bei/</id>
        <link href="https://grassroadsz.github.io/yi-tai-fang-ru-men-1-ji-chu-zhun-bei/">
        </link>
        <updated>2022-05-14T15:59:20.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>添加测试网Rinkeby 地址,使用 chainlink: <code>https://chainlist.quantclass.cn/</code></li>
<li>默认的测试网选项没有打开，需要使用设置 --&gt; 高级 -- &gt; 显示测试网络</li>
<li>测试币领取 <code>https://faucet.rinkeby.io/</code> 打开<code>https://twitter.com/intent/tweet?text=Requesting%20faucet%20funds%20into%200x0000000000000000000000000000000000000000%20on%20the%20%23Rinkeby%20%23Ethereum%20test%20network.</code> 将 其中的 000 改成自己的地址 ，发送twitter 后将twitter 地址copy 到 领水地址 进行领水</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊入门开发课]]></title>
        <id>https://grassroadsz.github.io/yi-tai-fang-ru-men-kai-fa-ke/</id>
        <link href="https://grassroadsz.github.io/yi-tai-fang-ru-men-kai-fa-ke/">
        </link>
        <updated>2022-05-14T15:59:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://forested-celsius-818.notion.site/62be43fb25c84db1965eb21f620087b0">课程学员手册</a></p>
<h2 id="以太坊入门-1-基础准备">以太坊入门-1 基础准备</h2>
<ul>
<li>添加测试网Rinkeby 地址,使用 chainlink: <a href="https://chainlist.quantclass.cn/">https://chainlist.quantclass.cn/</a></li>
<li>默认的测试网选项没有打开，需要使用设置 --&gt; 高级 -- &gt; 显示测试网络</li>
<li>测试币领取<a href="https://faucet.rinkeby.io/">https://faucet.rinkeby.io/</a><br>
打开<code>https://twitter.com/intent/tweet?text=Requesting%20faucet%20funds%20into%200x0000000000000000000000000000000000000000%20on%20the%20%23Rinkeby%20%23Ethereum%20test%20network.</code> 将 其中的 000 改成自己的地址 ，发送twitter 后将twitter 地址copy 到 领水地址 进行领水</li>
</ul>
<h2 id="arbitrum">Arbitrum</h2>
<ul>
<li>
<p>跨链桥：<code>https://bridge.arbitrum.io/</code></p>
<p>合约交互代码</p>
<pre><code class="language-python">def connect_web3_instance(network=&quot;mainnet&quot;):
  # 使用dotenv 进行配置的管理 此处只需要使用 Infura 的project_id 即可
  INFURA_PROJECT_ID = os.getenv('INFURA_PROJECT_ID')
  INFURA_MAIN_NETWORK = f'https://{network}.infura.io/v3/{INFURA_PROJECT_ID}'

  web3_instance = Web3(Web3.HTTPProvider(endpoint_uri=INFURA_MAIN_NETWORK))
  print(web3_instance.isConnected())
  return web3_instance


def bridge_arbitrum(from_address, from_address_private_key, l1_amount):
  &quot;&quot;&quot;
  Arbitrum 测试网跨链桥
  &quot;&quot;&quot;
  ArbitrumProxyContract = &quot;0x578BAde599406A8fE3d24Fd7f7211c0911F5B29e&quot;
  ArbitrumProxyContractAbi = '[{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;messageNum&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;InboxMessageDelivered&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;messageNum&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;InboxMessageDeliveredFromOrigin&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;enabled&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;name&quot;:&quot;PauseToggled&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;enabled&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;name&quot;:&quot;RewriteToggled&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newSource&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;WhitelistSourceUpdated&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;bridge&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;contract IBridge&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;createRetryableTicket&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;createRetryableTicketNoRefundAliasRewrite&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;depositEth&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;contract IBridge&quot;,&quot;name&quot;:&quot;_bridge&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;_whitelist&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;initialize&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;isCreateRetryablePaused&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;isMaster&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;pauseCreateRetryables&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendContractTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL1FundedContractTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;nonce&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL1FundedUnsignedTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;messageData&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL2Message&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;messageData&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendL2MessageFromOrigin&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;nonce&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;sendUnsignedTransaction&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;shouldRewriteSender&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;startRewriteAddress&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;stopRewriteAddress&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;unpauseCreateRetryables&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;destAddr&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;l2CallValue&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxSubmissionCost&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;excessFeeRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;callValueRefundAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;maxGas&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;gasPriceBid&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;internalType&quot;:&quot;bytes&quot;,&quot;name&quot;:&quot;data&quot;,&quot;type&quot;:&quot;bytes&quot;}],&quot;name&quot;:&quot;unsafeCreateRetryableTicket&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newSource&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;updateWhitelistSource&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;name&quot;:&quot;whitelist&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;}]'
  web3_instance = connect_web3_instance(&quot;rinkeby&quot;)

  # 通过合约地址 以及abi 实例化的 对象才可以使用abi中的方法进行调用
  ArbitrumProxyContractInstance = web3_instance.eth.contract(address=Web3.toChecksumAddress(ArbitrumProxyContract),
                                                             abi=ArbitrumProxyContractAbi)

  l1_amount = web3_instance.toWei(l1_amount, &quot;ether&quot;)
  from_address_balance = web3_instance.eth.get_balance(web3_instance.toChecksumAddress(from_address))
  print(f&quot;{from_address} 的 地址余额 为 {float(from_address_balance / 1e18)} ETH,转账 {l1_amount / 1e18} ETH&quot;)

  function_instance = ArbitrumProxyContractInstance.functions.depositEth(maxSubmissionCost=l1_amount)

  params = {

      'gas': 250000,
      'nonce': web3_instance.eth.getTransactionCount(web3_instance.toChecksumAddress(from_address)),
      'from': web3_instance.toChecksumAddress(from_address),
      'value': l1_amount,
      # 'gasPrice': w3.toWei('5', 'gwei'),
      'maxFeePerGas': web3_instance.toWei(5, 'gwei'),
      'maxPriorityFeePerGas': web3_instance.toWei(5, 'gwei'),
      'chainId': 4,

  }
  try:
      # 构建tx
      tx = function_instance.buildTransaction(params)
      # 签名
      sign_tx = web3_instance.eth.account.signTransaction(tx, private_key=from_address_private_key)
      # 发送交易
      txn = web3_instance.eth.sendRawTransaction(sign_tx.rawTransaction)
      from_address_balance = web3_instance.eth.get_balance(web3_instance.toChecksumAddress(from_address))
      print(f&quot;{from_address} 的 地址余额 为 {float(from_address_balance / 1e18)} ETH&quot;)

      return {'status': 'succeed', 'txn_hash': web3_instance.toHex(txn), 'task': 'Bridge ETH'}

  except Exception as e:
      return {'status': 'failed', 'error': e, 'task': 'Bridge ETH'}
</code></pre>
</li>
</ul>
<pre><code>


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试文章]]></title>
        <id>https://grassroadsz.github.io/ce-shi-wen-zhang/</id>
        <link href="https://grassroadsz.github.io/ce-shi-wen-zhang/">
        </link>
        <updated>2022-05-12T23:38:51.000Z</updated>
        <content type="html"><![CDATA[<p>测试文章</p>
]]></content>
    </entry>
</feed>