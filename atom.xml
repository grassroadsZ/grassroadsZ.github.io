<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://grassroadsz.github.io</id>
    <title>grassroadsZ</title>
    <updated>2022-06-08T02:42:51.661Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://grassroadsz.github.io"/>
    <link rel="self" href="https://grassroadsz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://grassroadsz.github.io/images/avatar.png</logo>
    <icon>https://grassroadsz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, grassroadsZ</rights>
    <entry>
        <title type="html"><![CDATA[Django知识点]]></title>
        <id>https://grassroadsz.github.io/FUjWD5NC8/</id>
        <link href="https://grassroadsz.github.io/FUjWD5NC8/">
        </link>
        <updated>2022-05-31T01:50:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-创建django">一、创建Django</h2>
<h4 id="1-创建django项目">1. 创建Django项目</h4>
<pre><code>1）利用命令创建
</code></pre>
<pre><code>	执行：django-admin.py startproject 项目名称

 2）利用pycharm创建

	打开pycharm，点击File =&gt; New Project =&gt; Django
</code></pre>
<h4 id="2-django工程目录结构">2. Django工程目录结构</h4>
<pre><code>	** init **.py：当前project为一个包

	asgi.py：存放ASGI异步请求的入口配置信息

	settings.py：存放项目全局配置信息

	urls.py：存放项目的路由信息

	wsgi.py：存放WSGI协议服务的入口配置信息（一般在部署时使用）

	sqlite3：默认的关系型文本数据库

	templates：存放模板

	manage.py：命令行管理工具，用于开发阶段的项目启动、数据迁移、静态文件收集等
</code></pre>
<h4 id="3-配置初始设置">3. 配置初始设置</h4>
<pre><code>	settings.py：指定简体中文、指定时区、定义子应用等
</code></pre>
<pre><code class="language-python"># 指定简体中文
LANGUAGE_CODE = 'zh-hans'
# 指定时区
TIME_ZONE = 'Asia/ShangHai'
</code></pre>
<h4 id="4-运行项目">4. 运行项目</h4>
<pre><code>	python manage.py runserver 127.0.0.1:8000
</code></pre>
<h2 id="二-子应用">二、子应用</h2>
<h4 id="1-子应用的作用">1. 子应用的作用</h4>
<pre><code>· 实现业务功能模块的复用

· 将工程项目拆分为不同的子功能模块，以子应用的形式存在

· 各功能模块之间可以保持相对的独立

· 实现路由的分发，便于管理各模块的url，减少代码维护成本
</code></pre>
<h4 id="2-创建">2. 创建</h4>
<pre><code>1）python manage.py startapp projects

2）注册

	在全局配置文件settings中的INSTALLED_APPS列表，添加子应用
</code></pre>
<pre><code># 子应用名.apps.子应用名首字母大写Config
'projects.apps.ProjectsConfig',
</code></pre>
<pre><code>3）在views.py中创建视图函数

4）在urls.py中配置路由信息

	子路由表：将url和需要调用的视图函数之间进行映射

	全局路由表：使用include加载子路由
</code></pre>
<h4 id="3-目录结构">3. 目录结构</h4>
<pre><code>migrations 存放数据库迁移脚本历史记录等信息

admin.py：admin后台站点的相关配置

apps.py：app label的相关配置

models.py：存放数据库模型相关信息

test.py：对当前子应用进行自测，单元测试

views.py：子应用视图
</code></pre>
<h2 id="三-路由">三、路由</h2>
<h4 id="1-定义">1. 定义</h4>
<pre><code>路由表：url与后端视图函数的一个映射关系表

web应用调用后端服务：前端访问url获取页面 --&gt; 后端调用指定函数func(a, b, ...)
</code></pre>
<h4 id="2-路由匹配规则">2. 路由匹配规则</h4>
<pre><code>①urlpatterns自上而下开始匹配

②一旦匹配成功，将调用path第二个参数所指定的视图函数，并且不会再向下匹配

③若url匹配不成功，则页面返回404

④路由信息一般以'/'结尾

⑤在子应用下定义子路由，主路由中使用include('子应用名.urls')来加载子路由，若url第一部分匹配，则剩下部分会被拿到子路由中匹配。
</code></pre>
<h4 id="3-路由分发">3. 路由分发</h4>
<pre><code>	在子路由中，将url和需要调用的视图函数之间进行映射，全局路由对各个应用进行绑定，利用include加载子路由，从而实现路由的分发，便于根据不同的应用来管理各自的url，减少代码维护成本
</code></pre>
<h2 id="四-视图">四、视图</h2>
<h3 id="1-函数视图">1. 函数视图</h3>
<pre><code class="language-python"># 第一个参数为HttpRequest对象或者HttpRequest子类对象，无需手动传递，一般参数名为request
# 一定要返回HttpResponse对象或者HttpResponse子类对象

def index01_page(request):
    return HttpResponse('&lt;h2&gt;Hello World&lt;/h2&gt;')
</code></pre>
<h3 id="2-类视图">2. 类视图</h3>
<pre><code class="language-python"># 一定要继承View的父类或子类
# 可定义get、put、post、delete等方法，实现多种方式的请求
# 方法名称固定小写
# 实例方法的第二个参数为HttpRequest对象

class IndexPage(View):
    def get(self, request):
        &quot;&quot;&quot;
        可使用url后面?的参数，称为query string查询字符串参数
        request.GET去获取参数字符串参数
        request.GET返回QueryDict对象，类似字典，支持字典中的所有操作
        request.GET[key]、request.GET.get(key)、request.GET.getlist()去获取参数值
        &quot;&quot;&quot;
        return HttpResponse('&lt;h2&gt;get请求&lt;/h2&gt;')
    
    def put(self, request):
        &quot;&quot;&quot;
        HttpResponse对象，第一个参数为字符串类型或字节型参数，会将字符串内容返回到前端
        可以使用content_type来传递内容类型
        可以使用status参数来指定响应状态码
        &quot;&quot;&quot;
        data = &quot;{'name': 'ergui', 'age': 18}&quot;
        return HttpResponse(data, content_type='application/json', status=201)
    
    def post(self, request, pk, username):
        &quot;&quot;&quot;
        可以使用request.POST方法，获取application/x-www-urlencoded类型的参数
        可以使用request.body方法，获取application/json类型的参数
        可以使用request.META方法，获取请求头参数，key为HTTP_请求头key的大写
        &quot;&quot;&quot;
        data_dict = json.loads(request.body, encoding='utf-8')
        return HttpResponse(f'&lt;h2&gt;post请求{data_dict[&quot;name&quot;]}&lt;/h2&gt;')
</code></pre>
<h2 id="五-请求与响应">五、请求与响应</h2>
<h4 id="1-请求参数类型">1. 请求参数类型</h4>
<p>利用HTTP协议向服务器传参的几种途径</p>
<h6 id="1查询字符串传参">1）查询字符串传参</h6>
<pre><code>如：ip:port/index/?name=ergui&amp;age=18

url后面的?参数，可以使用request.GET获取，返回QueryDict对象，可通过request.GET[key]、request.GET.get(key)、request.GET.getlist()获取参数值
</code></pre>
<h6 id="2请求体参数">2）请求体参数</h6>
<pre><code>form表单传参

		使用request.POST方法，获取application/x-www-form-urlencoded类型的参数

json格式参数

		使用request.body方法，获取application/json类型的参数

上传文件

		使用request.body方法，获取到文件的二进制格式数据
</code></pre>
<h6 id="3路径参数">3）路径参数</h6>
<pre><code>如：ip:port/index/10/

把参数伪装成路径，传递到后端

在路由中配置路径：&lt; url类型转换器:路径参数名 &gt;；请求函数中配置请求参数：def post(self, request, n)
</code></pre>
<pre><code>path('index04/&lt;int:pk&gt;/&lt;username&gt;/', views.IndexPage.as_view())
</code></pre>
<h4 id="2-响应">2. 响应</h4>
<p>视图中必须返回HTTPResponse对象或子对象</p>
<p>HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)</p>
<p>jsonResponse</p>
<pre><code class="language-python">class IndexPage(View):
    def get(self, request):
        data = [
            {
                'project_name': '王者项目',
                'leader': 'ergui',
                'app_name': '王者农药'
            },
            {
                'project_name': '活到最后项目',
                'leader': 'star',
                'app_name': '吃鸡'
            }
        ]
        
        # render()主要用于渲染模板，生成一个html页面，第一个参数为request，第二个参数为在templates目录下的模板名，第三个参数为context，只能传字典
        # return render(request, 'demo.html')
        # locals()，获取当前命名空间中的所有变量值，存放在一个字典中
        # return render(request, 'demo.html', locals())
        
        # JsonResponse是HttpResponse的子类，第一个参数为字典或者嵌套字典的列表，如果使用非字典格式，需设置safe为False
        return JsonResponse(data, safe=False)
</code></pre>
<h2 id="六-mvt模式和两种开发模式">六、MVT模式和两种开发模式</h2>
<h3 id="1mvt">1.MVT</h3>
<p>M：Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理</p>
<p>V：View，与MVC中的C功能相同，接收请求，进行业务处理，返回响应</p>
<p>T：Template，与MVC中的V功能相同，负责构造要返回的html页面</p>
<h3 id="2-两种开发模型">2. 两种开发模型</h3>
<h4 id="1前后不分离">1）前后不分离</h4>
<pre><code>前端数据的展示由后端来控制，后端渲染或重定向页面

耦合严重

返回的为html页面，实用性差，拓展性差，只能用于浏览器，与其他终端不适配
</code></pre>
<h4 id="2前后分离">2）前后分离</h4>
<pre><code>前后端独立，后端只需对数据进行处理，向前端提供数据，由前端负责页面的展示

解耦合

前后端可同时进行开发，缩小业务上线周期

大部分情况下，前端发送json格式参数，后端同样以json格式数据返回

扩展性、适应性好，可多终端运行同一套接口，如PC、APP、小程序等
</code></pre>
<h2 id="七-orm">七、ORM</h2>
<h4 id="1-概念">1. 概念</h4>
<p>· 将类和数据表进行映射</p>
<p>· 通过类和对象就能操作它所对应表格中的数据（CRUD）</p>
<p>· ORM中可以创建模型类，通过模型类，自动创建数据库表</p>
<h4 id="2-步骤">2. 步骤</h4>
<p>①在全局settings.py -- DATABASES中，配置数据库连接信息</p>
<p>②在子应用的models.py中，定义数据模型</p>
<pre><code>一个数据模型类对应一个数据表

数据模型类，需要继承Model父类或者Model子类

在数据模型类中，添加的类属性（Field对象）来对应数据表中的字段

在模型类下定义子类，子类名称固定为Meta，可使用db_table属性，指定表名
</code></pre>
<pre><code class="language-python">class Projects(models.Model):
    project_id = models.AutoField(primary_key=True)
    
    # 约束项目名称 name 字段，最大长度为200，值唯一
    name = models.CharField(max_length=200, verbose_name='项目名称', help_text='项目名称', unique=True)
	
    # 项目简介 desc 字段，参数可以为空，为空时使用 default 默认值
	desc = models.TextField(verbose_name='项目简介', help_text='项目简介', blank=True, default='项目简介', null=True)
	
    # 数据创建时，添加当前时间
	create_time = models.DateTimeField(auto_now_add=True, verbose_name='创建时间', help_text='创建时间')

	# 数据更新时，update_time更新，update_time只有在调用save方法的时候才会自动更新
	update_time = models.DateTimeField(auto_now=True, verbose_name='更新时间', help_text='更新时间')
    
    class Meta:
   		 db_table = 'tb_projects'
   		 verbose_name = '项目表'
</code></pre>
<p>③创建完数据库模型类后，需要迁移才能生成数据表</p>
<pre><code>生成迁移脚本，放在projects/migrations目录中：python manage.py makemigrations (子应用名)（如果不加子应用名，则会将所有子应用进行迁移）

执行迁移脚本：python manage.py migrate

会自动创建一个自增id，若存在一个自动primary_key=True，则不会自动创建id
</code></pre>
<p>在执行迁移脚本后，生成的数据表名默认为子应用名_模型类名</p>
<h6 id="模型类字段的定义">模型类字段的定义</h6>
<table>
<thead>
<tr>
<th>verbose_name</th>
<th>个性化信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>help_text</td>
<td>帮助文本信息，在api接口文档平台和admin后端站点中会用于提示，一般和verbose_name一致</td>
</tr>
<tr>
<td>unique</td>
<td>字段值唯一</td>
</tr>
<tr>
<td>null</td>
<td>指定数据在保存时是否可以为空，默认必填，如果null为True，则可以为空</td>
</tr>
<tr>
<td>blank</td>
<td>指定前端用户在创建数据时，是否需要传递，默认需要，如不传递，则blank为True</td>
</tr>
<tr>
<td>defalut</td>
<td>为某一个字段指定默认值，往往会和blank一起使用</td>
</tr>
<tr>
<td>auto_now_add</td>
<td>自动添加记录创建的时间（数据的create_time）</td>
</tr>
<tr>
<td>auto_now</td>
<td>记录更新的时间（数据的update_time）</td>
</tr>
</tbody>
</table>
<p>只有使用form表单时，blank和null才会起作用</p>
<h4 id="3curd">3.CURD</h4>
<p>直接使用sql语句：objects.raw('sql')</p>
<h5 id="1c-创建create">1）C-创建create</h5>
<p>方法一：使用模型类对象创建</p>
<pre><code>①创建一个projects模型类对象

②调用模型对象的save()，提交
</code></pre>
<pre><code class="language-python">proj_obj = Projects(name='飞向月球计划', leader='ergui', tester='测试1', programmer='研发1')
proj_obj.save()
</code></pre>
<p>方法二：使用查询集的create方法</p>
<pre><code>objects是manager对象，用于对数据进行操作

使用模型类.objects.create()方法，无需再save
</code></pre>
<pre><code class="language-python">Projects.objects.create(name='占领火星计划', leader='ergui', tester='测试2', programmer='研发2')
</code></pre>
<h5 id="2u-更新update">2）U-更新update</h5>
<p>方法一：先获取模型类对象，然后修改某些字段，再调用save</p>
<pre><code class="language-python">proj_obj = Projects.objects.get(name='飞向月球计划')
proj_obj.name = '驻扎广寒宫计划'
proj_obj.save()
</code></pre>
<p>方法二：使用模型类.objects.filter(字段名=值).update(字段名=修改的值)</p>
<p>ps: 只有调用了save()，记录的updatetime才会更新</p>
<pre><code class="language-python">Projects.objects.filter(name='Django学习计划').update(name='Django从入门到放弃')
</code></pre>
<h5 id="3r-查询retrieve">3）R-查询retrieve</h5>
<p>使用objects管理器来查询</p>
<h6 id="获取一条记录get">获取一条记录：get()</h6>
<p>一般只能使用主键或唯一键作为查询条件，如果返回结果为空或多条记录，则会抛出异常</p>
<p>返回的模型类对象，会自动提交</p>
<pre><code class="language-python">res = Projects.objects.get(project_id=17)
</code></pre>
<h6 id="获取表中的所有记录all">获取表中的所有记录：all()</h6>
<p>返回QuertSet查询集对象，类似列表，支持列表中的某些操作</p>
<pre><code>· 支持数字索引取值（负索引不支持，返回模型类对象，一条记录）、切片（返回查询集对象）

· 支持for循环迭代，每次迭代取出一个模型类对象

· QuertSet查询集对象.first()获取第一个记录、last()获取最后一条记录

· count()获取查询集中的记录条数

· 惰性查询，只有真正使用数据时，才会去数据库中执行sql语句，为了性能要求

· 链式调用
</code></pre>
<pre><code class="language-python">res = Projects.objects.all()
</code></pre>
<h6 id="过滤出部分记录filter">过滤出部分记录：filter()</h6>
<p>支持多个过滤表达式，字段名__过滤表达式，如果查询结果为空，则返回 一个空查询集</p>
<pre><code>· ** startswith=' '、 ** isstartswith（忽略大小写）：过滤以xxx开头的字符串

· ** endswith=' '、 ** iendswith（忽略大小写）：过滤以xxx结尾的字符串

· __ in=[]：过滤出在条件列表中的数据

· ** gt=' '：大于、** gte=' '：大于等于、** lt=' '：小于、** lte=' '：小于等于、__ exact=' '：等于（等同于 字段名=值 ）

. __ isnull=True：查询字段为空/不为空的数据

. ** contains=‘ ’、 ** icontains=‘ ’：过滤包含xxx的数据

. __ regex=‘ ’：正则过滤
</code></pre>
<p>在ORM中有一个内置的变量pk，为数据库模型类的主键别名</p>
<pre><code class="language-python">Projects.objects.filter()   # 等同于all()
Projects.objects.filter(name='占领火星计划')
Projects.objects.filter(name__startswith='占领')
Projects.objects.filter(id__in=[1, 20])
</code></pre>
<h6 id="反向查询exclude">反向查询：exclude()</h6>
<p>使用方法等同于filter()，查询结果相反</p>
<pre><code class="language-python">Projects.objects.exclude(name='Django学习计划')
</code></pre>
<h6 id="关联查询">关联查询</h6>
<p>通过从表的信息获取父表的记录，从表模型类名(小写)** 从表字段名 **查询表达式</p>
<p>惰性：查询集对象，只有去使用的时候，才会执行sql语句</p>
<pre><code class="language-python">qs = Projects.objects.filter(interfaces__name__regex='^[0-9]]')
</code></pre>
<h6 id="逻辑关系查询">逻辑关系查询</h6>
<p>查询集支持链式调用，可以使用filter方法过滤。</p>
<p>· “与”查询：filter(查询条件1, 查询条件2)</p>
<pre><code>qs = Projects.objects.filter(name__startswith='x').filter(programmer__contains='4')

qs = Projects.objects.filter(name__startswith='x', programmer__contains='4')
</code></pre>
<p>· “或”查询： filter(Q(查询条件1) | Q(查询条件2))</p>
<pre><code>qs = Projects.objects.filter(Q(leader__contains='1') | Q(programmer__contains='4'))
</code></pre>
<p>· 聚合查询</p>
<pre><code>qs = Projects.objects.annotate(Count('name'))
</code></pre>
<h6 id="特殊操作">特殊操作</h6>
<p>使用order_by排序，默认升序。使用 ' - '标识降序</p>
<pre><code>Projects.objects.all().order_by('-id', 'name')
</code></pre>
<p>表与表之间的关系：</p>
<pre><code>一对一：models.OneToOneField

一对多：models.ForeignKey，“一”：父表；“多”：子表

	如：项目表、接口表，一个接口属于一个项目，一个项目拥有多个接口，因此，项目表（一） -- &gt; 接口表（多）

多对多：models.ManyToManyField
</code></pre>
<h5 id="4d-删除delete">4）D-删除delete</h5>
<p>使用模型对象.delete()</p>
<pre><code class="language-python">proj_obj = Projects.objects.get(name='占领火星计划')
proj_obj.delete()
</code></pre>
<h4 id="4-痛点">4. 痛点</h4>
<pre><code>代码冗余大

数据校验麻烦

获取列表数据，没有分页、过滤、排序操作

不支持以表单提交参数

无法自动生成接口文档
</code></pre>
<h2 id="八-restful">八、RESTful</h2>
<h3 id="1-基本概念">1. 基本概念</h3>
<p>1）restful是一种开发风格而非标准</p>
<p>2）Representational State Transfer，具象状态传输</p>
<p>3）每一个url代表一种资源：json格式数据、text文本、图片视频等</p>
<p>4）客户端与服务器之间，传递这种资源的某种表现形式</p>
<pre><code>· 通过请求头中Content-Type来指明传给服务端的参数类型
</code></pre>
<p>&quot;text/plain&quot;、&quot;application/xml&quot;、&quot;text/html&quot;、&quot;application/json&quot;、&quot;image/gif&quot;、&quot;image/jpeg&quot;、&quot;application/x-www-form-urlencoded&quot;</p>
<pre><code>· 通过请求头中Accept来指明希望接受服务端的数据类型
</code></pre>
<p>Accept: application/json,application/xml;q=0.9,_/ _;q=0.8</p>
<p>5）客户端通过HTTP动词，指明对服务器端资源要进行的操作</p>
<table>
<thead>
<tr>
<th>HTTP METHOD</th>
<th>CRUD</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>Create</td>
</tr>
<tr>
<td>GET</td>
<td>Search</td>
</tr>
<tr>
<td>PUT</td>
<td>Update/Replace</td>
</tr>
<tr>
<td>PATCH</td>
<td>Partial Update/Modify</td>
</tr>
<tr>
<td>DELETE</td>
<td>Delete</td>
</tr>
</tbody>
</table>
<h3 id="2-rest常用设计规则">2. REST常用设计规则</h3>
<h4 id="协议">协议</h4>
<p>一般使用Https协议</p>
<h4 id="路径命名">路径命名</h4>
<pre><code>尽量用名词复数形式

往往与数据库表明对应

如：/getProjects、/users、/testcaseById?Id=6
</code></pre>
<h4 id="过滤信息">过滤信息</h4>
<p>若记录数量很多，服务器不可能将所有数据都返回给前端</p>
<p>?limit=10：指定返回记录的数量</p>
<p>?offset=10：指定返回记录的开始位置</p>
<p>?page=2&amp;size=10：指定第几页和每页的数据条数</p>
<p>?sort=name：指定返回结果按照哪个属性排序，以及排序顺序</p>
<h4 id="域名">域名</h4>
<pre><code>尽量使用专用域名：[http://api.ergui.site](http://api.ergui.site)
</code></pre>
<h4 id="版本">版本</h4>
<pre><code>在URL中呈现版本号：[http://api.ergui.site/app/0.1/](http://api.ergui.site/app/0.1/)

在请求头中呈现版本号：Accept：application/vnd.example+json;version=1.1
</code></pre>
<h4 id="http请求动词">Http请求动词</h4>
<p>含义</p>
<table>
<thead>
<tr>
<th>GET</th>
<th>从服务器获取资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>服务器中新建资源</td>
</tr>
<tr>
<td>PUT</td>
<td>在服务器更新资源</td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器删除资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>在服务器部分更新资源</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取资源的元数据</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>获取关于资源的哪些属性是客户端可以改变的信息</td>
</tr>
</tbody>
</table>
<p>例</p>
<table>
<thead>
<tr>
<th>GET　/projects</th>
<th>获取所有项目信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST　/projects</td>
<td>创建一个新项目</td>
</tr>
<tr>
<td>GET　/projects/6</td>
<td>获取ID为6的项目信息</td>
</tr>
<tr>
<td>PUT　/projects/6</td>
<td>更新ID为6的项目信息（全更新）</td>
</tr>
<tr>
<td>PATCH　/projects/6</td>
<td>更新ID为6的项目信息（部分更新）</td>
</tr>
<tr>
<td>DELETE　/projects/6</td>
<td>删除ID为６的项目</td>
</tr>
<tr>
<td>GET　/projects/6/interfaces</td>
<td>获取ID为6的项目信息中所有的接口信息</td>
</tr>
<tr>
<td>GET　/projects/6/interfaces/1</td>
<td>获取ID为6的所有项目信息中ID为1的接口信息</td>
</tr>
</tbody>
</table>
<h4 id="状态码">状态码</h4>
<p>200	ok - [GET]：服务器返回用户请求的数据</p>
<p>201	CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功</p>
<p>204	No Content - [DELETE]：用户删除数据成功</p>
<p>400	INVAILD REQUEST - [POST/PUT/PATCH]：用户请求有误（请求参数有误）</p>
<p>401	Unauthorized - [*]：表示用户没有权限</p>
<p>403	Forbidden - [*]：表示用户得到授权，但是访问被禁止</p>
<p>404	Not Found - [*]：用户请求的路径不存在</p>
<p>406	用户请求的格式错误</p>
<p>500	Internal Server Error - [*]：服务器发生错误</p>
<h4 id="返回结果">返回结果</h4>
<table>
<thead>
<tr>
<th>GET　/projects</th>
<th>返回所有项目列表（json数组</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST　/projects</td>
<td>返回新创建的项目信息（单个json</td>
</tr>
<tr>
<td>GET　/projects/6</td>
<td>返回单个项目信息 (单个json</td>
</tr>
<tr>
<td>PUT　/projects/6</td>
<td>返回更新之后，完整的项目信息（单个json</td>
</tr>
<tr>
<td>PATCH　/projects/6</td>
<td>返回更新之后，完整的项目信息（单个json</td>
</tr>
<tr>
<td>DELETE　/projects/6</td>
<td>返回空</td>
</tr>
<tr>
<td>GET　/projects/6/interfaces/1</td>
<td>返回单个接口信息（单个json</td>
</tr>
</tbody>
</table>
<h4 id="错误处理">错误处理</h4>
<p>当请求有误时，需将错误信息以json格式返回</p>
<p>{&quot;error&quot;:&quot;xxx错误&quot;,&quot;status_code&quot;:401}</p>
<h4 id="hypermedia-api">Hypermedia API</h4>
<p>超链接API，返回结果中提供链接</p>
<pre><code class="language-javascript">{&quot;link&quot;: {
  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,
  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,
  &quot;title&quot;: &quot;List of zoos&quot;,
  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;
}}
</code></pre>
<h2 id="九-rest-framework框架">九、REST framework框架</h2>
<p>在Django框架基础上，进行二次开发，用于构建Restful API，简称DRF框架或REST framework框架</p>
<h3 id="特性">特性</h3>
<p>提供了强大的Serializer序列化器，可以高效地进行序列化与反序列化操作</p>
<p>提供了丰富的类视图、Mixin扩展类、ViewSet视图集</p>
<p>提供了直观的Web API界面</p>
<p>实现了多种身份认证和权限认证</p>
<p>实现了排序、过滤、分页、搜索、限流等功能</p>
<p>可扩展性强，插件丰富</p>
<h3 id="安装与配置">安装与配置</h3>
<h6 id="安装">安装</h6>
<pre><code class="language-python">pip install djangorestframework
pip install markdown
</code></pre>
<h6 id="配置">配置</h6>
<p>在全局settings.py中添加子应用，'rest_framework'</p>
<pre><code class="language-python">INSTALLED_APPS = [
    'rest_framework',
]
</code></pre>
<h3 id="序列化器">序列化器</h3>
<p>将变量从内存中取出变成可存储或传输的过程称之为序列化</p>
<p>将变量内容从序列化的对象写到内存里的过程为反序列化</p>
<h4 id="一作用">（一）作用</h4>
<h5 id="1-数据校验">1. 数据校验</h5>
<pre><code>	判断用户输入的数据是否合法
</code></pre>
<h5 id="2-数据转换">2. 数据转换</h5>
<pre><code>	反序列化输入 —— 前端字段请求入库

				数据格式(json、xml、text)  =&gt; 程序中的数据类型（保存、更新数据）

	序列化输出 —— 数据库字段返回给前端

				程序中的数据类型  =&gt; 数据格式（前端可处理的数据，如json）
</code></pre>
<h4 id="二使用">（二）使用</h4>
<h5 id="1-定义序列化器类">1. 定义序列化器类</h5>
<ul>
<li></li>
</ul>
<p>继承Serializer</p>
<ul>
<li></li>
</ul>
<p>序列化器类字段名要与模型类中的字段名相同</p>
<ul>
<li></li>
</ul>
<p>序列化器类中定义的字段，如无特殊约束，必须传参，同时也都会返回</p>
<ul>
<li></li>
</ul>
<p>序列化器类的字段类型：CharField、BooleanField、IntegerField等要与模型类中的字段对应</p>
<pre><code class="language-python">from rest_framework import serializers

class ProjectModelSerializer(serializers.Serializer):
    name = serializers.CharField(max_length=200, label='项目名称', help_text='项目名称', read_only=True)
	desc = serializers.CharField(max_length=200, label='项目简介', help_text='项目简介', allow_null=True, allow_blank=True, default='项目简介')
  update_time = serializers.DateTimeField(label='更新时间', help_text='更新时间', required=False)
</code></pre>
<p>字段参数设置：</p>
<p>选项参数</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">max_length</td>
<td>最大长度</td>
</tr>
<tr>
<td style="text-align:left">min_length</td>
<td>最小长度</td>
</tr>
<tr>
<td style="text-align:left">allow_blank</td>
<td>是否允许为空（字段不传）</td>
</tr>
<tr>
<td style="text-align:left">trim_whitespace</td>
<td>是否截断空白字符</td>
</tr>
<tr>
<td style="text-align:left">max_value</td>
<td>最大值</td>
</tr>
<tr>
<td style="text-align:left">min_value</td>
<td>最小值</td>
</tr>
</tbody>
</table>
<pre><code>	通用参数
</code></pre>
<table>
<thead>
<tr>
<th>参数名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>required</td>
<td style="text-align:left">默认为None，指定前端必须传该字段，如果为False，则参数可以为空（与read_only不可同时设置）</td>
</tr>
<tr>
<td>read_only</td>
<td style="text-align:left">仅用于序列化输出，默认为False，若为True，则该字段在反序列化输入时可不用传，若传入字段也不做校验</td>
</tr>
<tr>
<td>write_only</td>
<td style="text-align:left">仅用于反序列化输入，默认为False，若为True，则该字段必传，但不会输出（与read_only不可同时设置）</td>
</tr>
<tr>
<td>default</td>
<td style="text-align:left">前端不传参，则使用默认值</td>
</tr>
<tr>
<td>allow_null</td>
<td style="text-align:left">指定传参时参数可以为空值，默认为False</td>
</tr>
<tr>
<td>validators</td>
<td style="text-align:left">字段指定校验器</td>
</tr>
<tr>
<td>error_messages</td>
<td style="text-align:left">设置错误信息，key为校验的参数名，value为校验失败后的返回信息，如：error_messages={&quot;required&quot;: &quot;该字段必填&quot;}</td>
</tr>
<tr>
<td>label</td>
<td style="text-align:left">与模型类中的verbose_name作用相同，HTML展示API页面时显示的字段名称</td>
</tr>
<tr>
<td>help_text</td>
<td style="text-align:left">与模型类中的help_text作用相同，HTML展示API页面时显示的字段帮助提示信息</td>
</tr>
</tbody>
</table>
<h5 id="2-序列化器操作">2. 序列化器操作</h5>
<h6 id="创建序列化器对象">· 创建序列化器对象</h6>
<pre><code>	①传递数据：序列化器类(dict_data)

				传入字典，将模型类对象转化为python中的数据类型，进行数据校验，生成数据模型，作用是反序列化输入
</code></pre>
<pre><code class="language-python">serializer_obj = InterfacesModelSerializer(data=request.data)
</code></pre>
<pre><code>	②获取数据：序列化器类(instance=模型类对象/查询集, many=True)

				传入模型类对象或查询集，作用是序列化输出
</code></pre>
<pre><code class="language-python">serializer_obj = InterfacesModelSerializer(instance=inter_obj, data=request.data, partial=True)
</code></pre>
<pre><code>				如果未传递many=True，则序列化器对象返回字典，否则返回嵌套字典的列表
</code></pre>
<pre><code class="language-python">serializer_obj = InterfacesModelSerializer(instance=qs, many=True)
</code></pre>
<h6 id="数据校验">· 数据校验</h6>
<pre><code>1）校验器的使用

		在定义序列化器字段时，使用参数validators=[ ]，添加一个或多个校验器，指定校验规则

		validators列表中的校验规则会全部执行，即使其中有校验失败项

2）校验器的种类

    ① 定义在filed中的参数，如：max_length,、min_length、required...

    ② drf自带校验规则，如：UniqueValidator(查询集, message='xxx不能重复')

    ```python
    from rest_framework import validators

    # 校验名称是否已存在
    name = serializers.CharField(max_length=10, label='接口名称', help_text='接口名称', validators=[
        validators.UniqueValidator(queryset=Interfaces.objects.all(), message='接口名称已存在')])
    ```

    ③ 自定义校验器

    在序列化器类外部定义校验器
</code></pre>
<pre><code class="language-python"># 校验名称中是否包含‘x’
# 如果校验失败，一定要抛出ValidationError，并给出报错信息
def is_name_contain_x(value):
    if 'x' in value:
        raise serializers.ValidationError(&quot;接口名称中不能包含'X'&quot;)
</code></pre>
<pre><code>		④ 单字段校验

		在序列化器类中对单字段进行校验
</code></pre>
<pre><code class="language-python"># 校验器名称必须为validate_字段名
# 必须返回校验后的值
def validate_name(self, value):
    if '-' in value:
        raise serializers.ValidationError(&quot;接口名称中不能包含'-'&quot;)
    return value
</code></pre>
<pre><code>    ⑤ 多字段联合校验

    在序列化器类中对多字段进行校验
</code></pre>
<pre><code class="language-python"># 函数名固定为
# 必须返回attrs
def validate(self, attrs):
    if attrs['password'] != attrs['confirm_password']:
        raise serializers.ValidationError('输入密码与确认密码不一致')
    return attrs
</code></pre>
<pre><code>			联合校验失败时，默认会将 &quot;non_field_error&quot;作为key，返回报错信息

			可在全局settings.py中的REST_FRAMEWORK修改DRF的配置
</code></pre>
<pre><code class="language-python"># 校验失败时，以'error_message'作为key
REST_FRAMEWORK = {
    # 'NON_FIELD_ERRORS_KEY': 'non_field_errors',
    'NON_FIELD_ERRORS_KEY': 'error_message',
}
</code></pre>
<pre><code>	3）序列化器的校验顺序

		字段定义时的校验（校验参数 —&gt; validators参数校验列表） —&gt; 单字段校验 —&gt; 多字段校验

		检验不通过，则不会继续之后的校验

	4）数据的校验

	开始校验：serializer_obj.is_valid()

	.is_valid(raise_exception=True)：若验证错误，则抛出 serializers.ValidationError

	.data：最原始的没有经过验证的数据（通常校验通过后，返回该数据）

	必须先执行is_valid()之后才能访问：

			.errors：校验失败的信息

			.vaildated_data：校验通过后的数据
</code></pre>
<pre><code class="language-python"># 校验失败，返回校验失败的信息，否则返回校验通过的数据
try:
    serializer_obj.is_valid(raise_exception=True)
except Exception as e:
    res.update(serializer_obj.errors)
    return JsonResponse(res, status=400)
</code></pre>
<h6 id="数据的增-查-改">· 数据的增、查、改</h6>
<p>1）只涉及到数据的校验，无需对模型进行修改（create）</p>
<pre><code>		创建序列化器对象：序列化器类(dict_data)

		开始校验数据：序列化对象.is_valid()

		获取错误信息：序列化对象.errors

		校验成功后，对数据进行修改：序列化对象.save()

				执行save()时，传递的关键字参数，会自动添加到create()的validated_data中，如：创建数据时，同时给出创建者的姓名：序列化对象.save(user='xxx')

		获取校验成功后的数据：序列化对象.data / 序列化对象.validated_data
</code></pre>
<p>2）只获取数据库中的数据（search）</p>
<pre><code>		创建序列化器对象：

				序列化器类(instance=模型类对象)

				序列化器类(instance=查询集, many=True)

				序列化器类(instance=普通对象)

		序列化输出：序列化对象.data
</code></pre>
<pre><code class="language-python">    # 查询接口信息：id默认为空
    def get(self, request, pk=None):
        res = {}
        try:
            if pk:
                # 查询接口详情以及所属项目信息
                inter_obj = Interfaces.objects.get(id=pk)
                serializer_obj = InterfacesSerializer(instance=inter_obj)
                projects_info = self.get_project_info(serializer_obj.data['projects'])
                res['data'] = serializer_obj.data
                res['data']['projects'] = projects_info
            else:
                # 查询接口列表
                inter_obj = Interfaces.objects.all()
                serializer_obj = InterfacesSerializer(instance=inter_obj, many=True)
                res['data'] = serializer_obj.data
            res['code'] = 0
            res['message'] = '查询接口信息成功'
        except Exception as e:
            res['code'] = 1
            res['message'] = f'查询接口信息失败：{e}'
        return JsonResponse(data)
</code></pre>
<p>3）既需要做数据校验，也需要修改数据库中的数据（update）</p>
<pre><code>		创建序列化器对象：

				序列化器类(instance=模型类对象, data=dict_data)

		开始校验数据：序列化对象.is_valid()

		获取错误信息：序列化对象.errors

		校验成功后，对数据进行修改：序列化对象.save()（根据是否有instance传参，判断是更新还是创建操作）

		获取校验成功后的数据：序列化对象.data / 序列化对象.validated_data
</code></pre>
<h4 id="三modelserializer">（三）ModelSerializer</h4>
<pre><code>1. 目的：为了简化序列化器类的定义

2. 功能：

		基于模型类自动生成一系列字段

		基于模型类自动为Serializer生成validators，如：unique_together

		包含默认的create()和update()的实现
</code></pre>
<ol start="3">
<li></li>
</ol>
<p>ModelSerializer定义的字段若与模型类字段同名，会覆盖原有的模型类字段</p>
<ol start="4">
<li></li>
</ol>
<p>ModelSerializer可以基于模型类自动生成validators，如：unique_together</p>
<ol start="5">
<li></li>
</ol>
<p>模型序列化器类中的Meta类</p>
<pre><code class="language-python">class Meta:
    # model类属性：在Meta内部类中指定具体的模型类
    # fields类属性 指定模型类中需要输入或输出的字段
    # 默认id主键会自动添加read_only=True
    # create_time、update_time自动添加read_only=True
    model = Interfaces
    # 将模型类的所有字段都声明到模型序列化器中
    # fields = '__all__'
    # 可以将需要/输出的字段放在fields元组中，在序列化器中定义的所有字段必须添加到fields中
    fields = ('id', 'name', 'tester', 'desc', 'email', 'projects')
    # 把需要排除的字段放在exclude中，既不参与输入，也不参与输出
    # exclude = ('desc',)
    # 可以在read_only_fields中指定只输出，不输入的字段
    read_only_fields = ('id',)
    # 可以在extra_kwargs属性中定制某些字段，可以覆盖，也可以新增，序列化器中定义的字段优先级最高
    extra_kwargs = {
        'tester': {
            'label': '测试负责人',
            'write_only': False,
            'max_length': 10,
            'min_length': 1
        },
        'name': {
            'max_length': 10,
            'min_length': 2,
            'label': '接口名称',
            'help_text': '接口名称',
            'validators': [validators.UniqueValidator(queryset=Interfaces.objects.all(), message='接口名称已存在')]
        }
    }
</code></pre>
<ol start="6">
<li></li>
</ol>
<p>ModelSerializer和Serializer的区别</p>
<p>①字段的定义</p>
<pre><code>Serializer：需手动定义序列化器字段，与模型类字段匹配

ModelSerializer：基于模型类自动生成一系列字段
</code></pre>
<p>②数据的创建或更新</p>
<pre><code>Serializer：需重写create/update方法，完成数据的创建/更新

ModelSerializer：包含create/update方法，无需重写
</code></pre>
<p>③字段校验</p>
<pre><code>Serializer：需手动指定校验器，如：validators=[validators.UniqueValidator()]

ModelSerializer：可基于模型类自动生成某些validators，如：unique_together
</code></pre>
<pre><code class="language-python"># 使用模型序列化器
def get(self, request, pk=None):
    qs = Interfaces.objects.all()
    serializer_obj = InterfacesModelSerializer(instance=qs, many=True)
    return JsonResponse(serializer_obj.data, safe=False)
</code></pre>
<h4 id="四关联字段序列化">（四）关联字段序列化</h4>
<pre><code>1. 子表关联父表

	PrimaryKeyRelatedField：将父表的主键id返回

	StringRelatedField：将父表中对应对象的**str**方法结果返回

	SlugRelatedField：指定序列化输出时返回的父表某个字段值

	关联对象的序列化器：xxxModelSerializer，可以将某个序列化器对象定义为字段，支持Field中的所有参数
</code></pre>
<pre><code># PrimaryKeyRelatedField：将父表的主键id返回
# 此处的字段名一定要与模型中的字段名一致
projects = serializers.PrimaryKeyRelatedField(read_only=True)

# StringRelatedField：将父表中对应对象的__str__方法结果返回
# projects = serializers.StringRelatedField()

# serializers.SlugRelatedField：指定序列化输出时返回的父表某个字段值
# projects = serializers.SlugRelatedField(slug_field='tester', read_only=True)

# ProjectModelSerializer：将某个序列化器对象定义为字段，字典形式返回父序列化器所有字段
projects = ProjectModelSerializer(label='所属项目信息', help_text='所属项目信息', read_only=True)
</code></pre>
<ol start="2">
<li></li>
</ol>
<p>父表关联子表</p>
<p>父表中默认不会生成关联字段(从表字段)，可手动指定</p>
<pre><code># 默认可以使用子表名模型类名小写_set
# interfaces_set = InterfacesModelSerializer(label='拥有的接口', many=True)
# 如果某个字段返回的结果有多条，需要添加many=True
# interfaces_set = serializers.PrimaryKeyRelatedField(many=True)
# 如果模型类中外键字段定义了related_name，则会使用该名称作为字段名
# interface = serializers.StringRelatedField(many=True)
</code></pre>
<h3 id="痛点">痛点</h3>
<pre><code>· 仅支持json格式传参，不支持form表单传参

· 仅能返回json格式数据，其他类型不支持

· 对于模型类的获取，仍然有冗余
</code></pre>
<h3 id="类视图">类视图</h3>
<h4 id="一apiview">（一）APIView</h4>
<h5 id="1-特性">1. 特性</h5>
<pre><code>继承了Django中的View，进行了拓展，是可浏览的API页面

具备认证、授权、限流、不同请求数据的解析
</code></pre>
<h5 id="2-apiview与view的不同">2. APIView与View的不同</h5>
<pre><code>1）传入到视图方法中的是Request对象，而不是Django中的HttpRequest对象

2）视图方法可以返回Response对象，会为响应数据处理（render）为符合前端要求的格式

3）任何APIException异常都会被捕获到，并且处理成合适的响应信息

4）在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制
</code></pre>
<h5 id="3-常用类属性">3. 常用类属性</h5>
<pre><code>authentication_classes	列表或元组，身份认证类

permission_classes	列表或元组，权限检查类

throttle_classes	列表或元组，流量控制类
</code></pre>
<h5 id="4-request">4. Request</h5>
<pre><code>1）对Django中的HttpRequest进行了拓展
</code></pre>
<p>接收到请求后会根据请求头中的Content-Type，自动进行解析，解析为字典形式保存到Request对象</p>
<p>无论前端发送哪种格式的数据，都可以以统一的方式读取</p>
<pre><code>2）.data —— 获取json格式的参数、form表单的参数、files（类似于.body 、.POST、.FILES ）
</code></pre>
<p>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</p>
<p>可以对POST、PUT、PATCH的请求体参数进行解析</p>
<p>Render类	Parse解析类</p>
<pre><code>3）.query_params —— 获取查询字符串参数（类似于.GET ）

4）支持Django HttpRequest中所有的对象和方法
</code></pre>
<h5 id="5-response">5. Response</h5>
<pre><code>1）对Django中的HTTPResponse进行了拓展

2）请求头中的Accept默认为：application/json，浏览器访问时自动设置为：text/html，返回html页面

3）指定响应默认渲染类
</code></pre>
<pre><code class="language-python"># 在全局settings中的REST_FRAMEWORK修改DRF的配置
# DRF框架所有的全局配置都放在REST_FRAMEWORK字典中

REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        # 按列表中的元素顺序排优先级
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
}
</code></pre>
<pre><code>4）Response参数
</code></pre>
<pre><code class="language-python">Response(data, status=None, template_name=None, headers=None, content_type=None)
</code></pre>
<ul>
<li></li>
</ul>
<p>data</p>
<pre><code>序列化处理后的数据

一般为serializer.data（python基本数据类型、字典、嵌套字典的列表）
</code></pre>
<ul>
<li></li>
</ul>
<p>status</p>
<pre><code>状态码，默认为200
</code></pre>
<ul>
<li></li>
</ul>
<p>template_name</p>
<pre><code>模板名称，使用HTMLRenderer渲染时需指明
</code></pre>
<ul>
<li></li>
</ul>
<p>headers</p>
<pre><code>请求头
</code></pre>
<ul>
<li></li>
</ul>
<p>content_type</p>
<pre><code>响应头中的content_type

通常该参数无需设置，会自动根据前端所需类型数据来设置参数
</code></pre>
<h4 id="二genericapiview">（二）GenericAPIView</h4>
<p>GenericAPIView为APIView的子类，拓展了过滤、查询、分页的功能</p>
<h5 id="1-前提">1. 前提</h5>
<pre><code>1）安装过滤引擎 pip install django-filter

2）必须指定的属性（继承APIView所用）

		queryset：定义查询集

		serializer_class：声明模型序列化器类
</code></pre>
<h5 id="2-过滤">2. 过滤</h5>
<pre><code>指定过滤引擎：filter_backends

指定过滤字段：filterset_fields
</code></pre>
<p>· settings.py</p>
<pre><code class="language-python"># 在全局settings.py中指定过滤引擎
# 添加应用
INSTALLED_APPS = [
    'django_filters',
]
# 配置DRF
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BANKENDS': [
   'django_filters.rest_framework.backends.DjangoFilterBackend'
    ],
}
</code></pre>
<p>· views.py</p>
<pre><code class="language-python">from django_filters.rest_framework import DjangoFilterBackend

# 在filter_backends指定过滤引擎
filter_backends = [DjangoFilterBackend]
# 指定需要过滤的字段
filter_fields = ['name', 'tester', 'id']
</code></pre>
<p>URL访问：</p>
<pre><code>name=test1：/?name=test1
</code></pre>
<h5 id="3-排序">3. 排序</h5>
<pre><code>指定过滤引擎：filter_backends

指定排序字段：ordering_fields
</code></pre>
<p>· settings.py</p>
<pre><code class="language-python"># 在全局settings.py中指定排序引擎
# 配置DRF
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BANKENDS': [
        'rest_framework.filters.OrderingFilter'
    ],
}
</code></pre>
<p>· views.py</p>
<pre><code class="language-python">from rest_framework.filters import OrderingFilter

# 在filter_backends指定排序引擎
filter_backends = [OrderingFilter]
# 指定排序字段
ordering_fields = ['name', 'id', 'create_time']
</code></pre>
<p>URL访问：</p>
<pre><code>升序：/?ordering=name&amp;id

降序：/?ordering=-name
</code></pre>
<h5 id="4-分页">4. 分页</h5>
<pre><code>指定分页引擎：pagination_class
</code></pre>
<p>· settings.py</p>
<pre><code class="language-python"># 在全局settings.py中指定分页引擎
# 配置DRF
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': [
        # 使用默认的分页引擎
        'rest_framework.pagination.PageNumberPagination',
        # 指定每页展示数据的条数
        'PAGE_SIZE': 5
    ],
}
</code></pre>
<p>重新定义分页引擎</p>
<pre><code>创建一个新目录utils，用于存放自定义模块，继承PageNumberPagination，重新定义分页引擎

当自定义分页引擎与settings.py中分页引擎同时存在时，自定义的优先级更高
</code></pre>
<pre><code class="language-python">from rest_framework.pagination import PageNumberPagination


class MyPagination(PageNumberPagination):
	# 指定默认每一页的数据条数
	page_size = 4
	# 设置当前页码的查询字符串key名称，不设置则默认key值为page
	page_query_param = 'p'
	# 设置每页显示的数据条数的查询字符串key名称，不设置则无法指定每页显示的数据量
	page_size_query_param = 's'
    # 指定每一页数据条数的最大限制
	max_page_size = 50
</code></pre>
<h5 id="示例">示例</h5>
<h6 id="1过滤分页排序查询">1）过滤+分页+排序查询</h6>
<p>get_queryset()：获取查询集</p>
<p>filter_queryset()：对查询集进行过滤，并返回一个查询集</p>
<p>paginate_queryset()：对查询集进行分页</p>
<pre><code class="language-python">from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import OrderingFilter
# 导入自定义的分页引擎
from utils.pagination import MyPagination

class InterfacesInfo(GenericAPIView):
	# 指定过滤引擎
	filter_backends = [DjangoFilterBackend, OrderingFilter]
	# 指定需要过滤的字段
	filter_fields = ['name', 'tester', 'id']
	# 指定排序字段
	ordering_fields = ['name', 'id']
	# 在特定视图中指定分页引擎类（有些视图需要分页，有些不需要）
	pagination_class = MyPagination

	queryset = Interfaces.objects.all()
	serializer_class = InterfacesModelSerializer

    # 查询接口
    def get(self, request, *args, **kwargs):
        # 传递查询集对象给filter_queryset()
        qs = self.filter_queryset(self.get_queryset())
        page = self.paginate_queryset(qs)
        # 判断是否指定分页引擎
        if page is not None:
            # 调用序列化器，获取数据
            serializer_obj = self.get_serializer(instance=page, many=True)
            # 将数据进行分页
            return self.get_paginated_response(serializer_obj.data)
        serializer_obj = self.get_serializer(instance=qs, many=True)
        return Response(serializer_obj.data, status=status.HTTP_200_OK)
</code></pre>
<h6 id="2查询详情数据">2）查询详情数据</h6>
<p>get_object()：获取url中的id，返回模型类对象</p>
<p>get_serializer()：返回序列化器类</p>
<pre><code class="language-python">class ProjectsDetail(GenericAPIView):
    queryset = Projects.objects.all()
    serializer_class = ProjectModelSerializer

    # 查询项目：id默认为空，id为空时，查询所有项目，否则查询指定项目详情
    def get(self, request, pk):
        obj = self.get_object()
        serializer_obj = self.get_serializer(instance=obj)
        return Response(serializer_obj.data, status=status.HTTP_200_OK)

    # 创建项目：数据以json格式传入
    def post(self, request):
        serializer_obj = self.get_serializer(data=request.data)
        serializer_obj.is_valid(raise_exception=True)
        serializer_obj.save()
        return Response(serializer_obj.data, status=status.HTTP_200_OK)

    # 更新项目：传入需更新记录的id，修改数据以json形式传入
    def put(self, request, pk):
        obj = self.get_object()
        serializer_obj = self.get_serializer(instance=obj, data=request.data)
        # 在视图中抛出的异常，DRF会自动处理，报错信息以json格式返回
        serializer_obj.is_valid(raise_exception=True)
        serializer_obj.save()
        return Response(serializer_obj.data, status=status.HTTP_201_CREATED)

    # 删除项目：传入需删除记录的id
    def delete(self, requset, pk):
        obj = self.get_object()
        obj.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
</code></pre>
<ul>
<li></li>
</ul>
<h6 id="genericapiview的特性">GenericAPIView的特性</h6>
<pre><code>1）GenericAPIView继承了APIView，实现了过滤、排序、分页的功能

2）增加了对于列表视图和详情视图可能用到的通用支持方法， 每个具体通用视图都是一个GenericAPIView搭配一个或多个Mixin扩展类

3）支持的属性
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>queryset</td>
<td>指定列表视图的查询集</td>
</tr>
<tr>
<td>serializer_class</td>
<td>指定视图使用的序列化器</td>
</tr>
<tr>
<td>pagination_class</td>
<td>指定分页引擎</td>
</tr>
<tr>
<td>filter_backends</td>
<td>指定过滤引擎</td>
</tr>
<tr>
<td>lookup_field</td>
<td>查询单一数据库对象时使用的条件字段，默认为'pk'，可以指定为'id'</td>
</tr>
<tr>
<td>lookup_url_kwarg</td>
<td>查询单一数据时URL中的参数关键字名称，默认与look_field相同</td>
</tr>
</tbody>
</table>
<pre><code>4）提供的方法
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>get_object</td>
<td>返回模型类数据对象（单条详情数据）</td>
</tr>
<tr>
<td>get_queryset(qs)</td>
<td>返回查询集</td>
</tr>
<tr>
<td>get_serializer</td>
<td>返回序列化器对象</td>
</tr>
<tr>
<td>filter_queryset</td>
<td>对查询集进行过滤</td>
</tr>
<tr>
<td>paginate_queryset</td>
<td>对查询集进行分页</td>
</tr>
</tbody>
</table>
<ul>
<li></li>
</ul>
<h6 id="痛点-2">痛点</h6>
<p>GenericAPIView和APIView只支持对get、post、put、delete、patch等请求方法</p>
<p>如果要支持action：list、create、update、delete等，需继承视图集：ViewSet</p>
<h4 id="三mixin">（三）Mixin</h4>
<h5 id="拓展类">拓展类</h5>
<ul>
<li></li>
</ul>
<p>RetrieveModelMixin</p>
<p>提供 retrieve(request, *args, **kwargs) 方法，获取详情数据</p>
<p>获取成功，返回 200 OK，否则返回 404 Not Found</p>
<ul>
<li></li>
</ul>
<p>ListModelMixin</p>
<p>提供 list(request, *args, **kwargs) 方法，获取列表数据</p>
<p>获取成功，返回 200 OK，否则返回 404 Not Found</p>
<ul>
<li></li>
</ul>
<p>CreateModelMixin</p>
<p>提供 create(request, *args, **kwargs) 方法，创建数据</p>
<p>获取成功，返回 200 OK；请求参数有误，返回 400 Bad Request</p>
<ul>
<li></li>
</ul>
<p>UpdateModelMixin</p>
<p>提供 update(request, *args, **kwargs) 方法，全更新</p>
<p>提供 partial_update(request, *args, **kwargs) 方法，部分更新，支持PATCH方法</p>
<p>更新成功，返回 200 OK</p>
<p>请求参数有误，返回 400 Bad Request；不存在，返回 404 Not Found</p>
<ul>
<li></li>
</ul>
<p>DestoryModelMixin</p>
<p>提供 destory(request, *args, **kwargs) 方法，删除数据</p>
<p>删除成功，返回 204 No Content，不存在，返回 404 Not Found</p>
<p>示例</p>
<pre><code class="language-python"># 先继承DRF中的Mixin拓展类，最后继承GenericAPIView
class ProjectInfo(mixins.ListModelMixin, mixins.CreateModelMixin, 
                  mixins.UpdateModelMixin, mixins.DestroyModelMixin, GenericAPIView):
    
    queryset = Projects.objects.all()
    serializer_class = ProjectModelSerializer

    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filter_fields = ['name', 'tester', 'id']
    ordering_fields = ['name', 'id']

    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
</code></pre>
<h4 id="四concrete-generic-views">（四）Concrete Generic Views</h4>
<h5 id="拓展类-2">拓展类</h5>
<ul>
<li></li>
</ul>
<p>RetrieveApIView</p>
<p>提供：get方法</p>
<p>继承：RetrieveModelMixin、GenericAPIView</p>
<ul>
<li></li>
</ul>
<p>UpdateApIView</p>
<pre><code>	提供：put、patch方法

	继承：UpdateModelMixin、GenericAPIView
</code></pre>
<ul>
<li>
<p>DestoryApIView</p>
<pre><code>  提供：delete方法

  继承：DestoryModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>ListAPIView</p>
<pre><code>  提供：get方法

  继承：ListModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>CreateAPIView</p>
<pre><code>  提供：post方法

  继承：CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>ListCreateApIView</p>
<pre><code>  提供：post、get方法

  继承：ListModelMixin、CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveUpdateApIView</p>
<pre><code>  提供：get、put、patch方法

  继承：ListModelMixin、CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>ListCreateApIView</p>
<pre><code>  提供：ge、createt方法

  继承：ListModelMixin、CreateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveUpdateApIView</p>
<pre><code>  提供get、put、patch方法

  继承：RetrieveModelMixin、UpdateModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveDestoryApIView</p>
<pre><code>  提供get、delete方法

  继承：RetrieveModelMixin、DestoryModelMixin、GenericAPIView
</code></pre>
</li>
<li>
<p>RetrieveUpdateDestoryApIView</p>
<pre><code>  提供get、put、patch、delete方法

  继承：RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin、GenericAPIView
</code></pre>
</li>
</ul>
<h5 id="痛点-3">痛点</h5>
<pre><code>列表视图和详情视图无法合并

两个类视图中，有相同的get方法，会冲突

两个类视图所对应的url地址不一致
</code></pre>
<h4 id="五viewset">（五）ViewSet</h4>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>动作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>retrieve</td>
<td>获取详情数据（单条）</td>
</tr>
<tr>
<td>GET</td>
<td>list</td>
<td>获取列表数据（多条）</td>
</tr>
<tr>
<td>POST</td>
<td>create</td>
<td>创建数据</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
<td>更新数据</td>
</tr>
<tr>
<td>PATCH</td>
<td>partial_update</td>
<td>部分更新</td>
</tr>
<tr>
<td>DELTE</td>
<td>destory</td>
<td>删除数据</td>
</tr>
</tbody>
</table>
<h5 id="viewset">ViewSet</h5>
<pre><code>继承ViewSetMixin和Views.APIView

ViewSetMixin支持action动作

未提供get_object()、get_serializer()、queryset、serializer_class等
</code></pre>
<h5 id="genericviewset">GenericViewSet</h5>
<pre><code>继承ViewSetMixin和generics.GenericAPIView

提供get_object()、get_serializer()、queryset、serializer_class等

在定义路由时，需将请求方法与action动作进行绑定

使用Mixins类简化程序
</code></pre>
<ul>
<li></li>
</ul>
<h6 id="viewset与genericviewset的区别">ViewSet与GenericViewSet的区别</h6>
<table>
<thead>
<tr>
<th>ViewSet</th>
<th>GenericViewSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承：(ViewSetMixin, Views.APIView)</td>
<td>继承：(ViewSetMixin, generics.GenericAPIView)</td>
</tr>
<tr>
<td>未提供通用View的方法集：get_object()、get_serializer()、queryset、serializer_class等</td>
<td>包含基本的通用View的方法集：get_object()、get_serializer()、queryset、serializer_class等</td>
</tr>
<tr>
<td>支持action动作</td>
<td>在定义路由时，需将请求方法与action动作进行映射</td>
</tr>
</tbody>
</table>
<h5 id="modelviewset">ModelViewSet</h5>
<p>继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin</p>
<p>支持的Action</p>
<pre><code>列表视图：list、create

详情视图： retrieve、 update、destory
</code></pre>
<p>urls.py</p>
<pre><code class="language-python"># 继承ViewSet后，支持在路由表中指定请求方法与action的映射
# as_view接收一个字典，key为请求方法，value为请求动作
urlpatterns = [
	path('projects/', views.ProjectViewSet.as_view({
		'get': 'list', 'post': 'create'
	})),
	path('projects/&lt;int:pk&gt;', views.ProjectViewSet.as_view({
		'get': 'retrieve', 'put': 'update', 'delete': 'destory'
	})),
]
</code></pre>
<p>views.py</p>
<pre><code class="language-python">from rest_framework.filters import OrderingFilter
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import viewsets
from .models import Projects
from .serializers import ProjectModelSerializer


class ProjectViewSet(viewsets.ModelViewSet):
    queryset = Projects.objects.all()
    serializer_class = ProjectModelSerializer

    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filter_fields = ['name', 'tester', 'id']
    ordering_fields = ['name', 'id']
</code></pre>
<h5 id="readonlymodelviewset">ReadOnlyModelViewSet</h5>
<pre><code>继承ListModelMixin、RetrieveModelMixin、GenericAPIView
</code></pre>
<h4 id="action">action</h4>
<p>使用action装饰器：@action(methods, detail)</p>
<pre><code>methods：支持的请求方式

					默认值为['get']，可定义多个请求方式['get', 'post', 'put']

detail：声明要处理的是否是详情资源对象（通过url路径获取主键）

	True 表示使用通过URL获取的主键对应的数据对象

	False 表示不使用URL获取主键
</code></pre>
<pre><code class="language-python">from rest_framework.decorators import action

# 可以使用action装饰器自定义动作
# 默认methods参数为['get']，可定义多个请求方式['get', 'post', 'put']
# detail为必填参数，指定是否为详情数据，如需要传递主键ID，则detail=True，否则为列表数据，detail=False
# url_path指定url路径部分，默认为action名称
# url_name指定url的名称，默认为action名称(当前为names，完整的路由名称为/names-list)
@action(methods=['get'], detail=False, url_path='test')
def names(self, requset, *args, **kwargs):
   qs = self.filter_queryset(self.get_queryset())
   serializer_obj = self.get_serializer(instance=qs, many=True)
   return Response(serializer_obj.data)
</code></pre>
<h4 id="router">router</h4>
<pre><code class="language-python">from rest_framework.routers import DefaultRouter, SimpleRouter

# 1. 定义路由对象
router = SimpleRouter()
router = DefaultRouter()
# 2. 使用路由对象，调用register()，进行注册
# 第一个参数指定路由前缀，子应用名称；第二个参数，指定视图集类，无需调用.as_view()
router.register(r'projects', views.ProjectViewSet)
# 使用路由对象.urls属性来获取自动生成的路由条目，往往为列表
# 需要将列表添加到urlpatterns
urlpatterns = [
   # name可以指定路由名称
   path('projects', views.ProjectViewSet.as_view(), name='')
]
urlpatterns += router.urls
</code></pre>
<h3 id="生成api文档">生成API文档</h3>
<h4 id="简介">简介</h4>
<pre><code>生成API文档平台

自动生成测试代码

支持接口测试
</code></pre>
<h4 id="安装-2">安装</h4>
<p>django-rest-swagger、coreapi</p>
<p>可选：Pygments、Markdown</p>
<h4 id="实现">实现</h4>
<h5 id="1-drf-yasg">1. drf-yasg</h5>
<pre><code>安装：pip install drf-yasg

添加到子应用：INSTALLED_APPS = [ 'drf_yasg', ]
</code></pre>
<p>配置urls.py</p>
<pre><code class="language-python">from drf_yasg import openapi 
from drf_yasg.views import get_schema_view 

# 声明schema_view
schema_view = get_schema_view( 
    openapi.Info( 
        title=&quot;Lemon API接口文档平台&quot;, # 必传 
        default_version='v1', # 必传 
        description=&quot;这是一个美轮美奂的接口文档&quot;, 
        terms_of_service=&quot;http://api.keyou.site&quot;, 
contact=openapi.Contact(email=&quot;keyou100@qq.com&quot;),
        license=openapi.License(name=&quot;BSD License&quot;), 
),
    public=True, 
)

# 设置urlpatterns
urlpatterns = [ 
    re_path(r'^swagger(?P&lt;format&gt;\.json|\.yaml)$', 
schema_view.without_ui(cache_timeout=0), name='schema-json'), 
    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'), 
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema- redoc'), ]
</code></pre>
<h5 id="2-coreapi">2. coreapi</h5>
<p>配置全局settings.py</p>
<pre><code class="language-python">REST_FRAMEWORK = {
	'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.coreapi.AutoSchema',
}
</code></pre>
<pre><code class="language-python">from rest_framework.documentation import include_docs_urls
from django.urls import path, include
urlpatterns = [
	path('docs/', include_docs_urls(title='接口测试文档')),
]
</code></pre>
<p>添加注释</p>
<pre><code>单一方法的视图
</code></pre>
<pre><code class="language-python"># 直接在视图类中添加注释
class ProjectsListView(ListAPIView): 
&quot;&quot;&quot; 返回所有项目信息 &quot;&quot;&quot;
</code></pre>
<pre><code>多个方法的视图
</code></pre>
<pre><code class="language-python">class ProjectsListCreateView(ListCreateAPIView): 
&quot;&quot;&quot; 
get: 返回所有项目信息 
post: 新建项目 
&quot;&quot;&quot;
</code></pre>
<pre><code>视图集
</code></pre>
<pre><code class="language-python"> class ProjectsViewset(viewsets.ModelViewSet):
  &quot;&quot;&quot; 
 create: 创建项目 
 retrieve: 获取项目详情数据 
 update: 完整更新项目 
 partial_update: 部分更新项目 
 destroy: 删除项目 
 list: 获取项目列表数据 
 names: 获取所有项目名称 
 interfaces: 获取指定项目的所有接口数据
  &quot;&quot;&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8S 单集群部署]]></title>
        <id>https://grassroadsz.github.io/VkMGKzvHG/</id>
        <link href="https://grassroadsz.github.io/VkMGKzvHG/">
        </link>
        <updated>2022-05-29T09:21:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用kubeadm安装的步骤">使用kubeadm安装的步骤：</h2>
<pre><code class="language-text">

1. master：安装kubelet，kubeadm，docker，kubeclt客户端，然后初始化，生成令牌，供node端加入
2. node01：安装kubelet，kubeadm，docker后，join 直接加入集群即可
3. node02：安装kubelet，kubeadm，docker后，join 直接加入集群即可

</code></pre>
<p>PS：在CentOS中安装K8S只能在Centos7的系统上进行安装，原因是Linux 内核的版本必须是 3.10 以上</p>
<h2 id="master-node机器初始化">master、node机器初始化</h2>
<h3 id="关防火墙关swap">关防火墙，关swap</h3>
<pre><code class="language-shell"># 关闭selinux
setenforce  0
sed -i &quot;s/^SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/sysconfig/selinux

# 关闭防火墙
systemctl stop firewalld
systemctl disable firewalld

# 关闭swap
swapoff -a
# 修改/etc/fstab文件，注释掉SWAP的自动挂载，使用free -m确认swap已经关闭
sed -i 's/.*swap.*/#&amp;/' /etc/fstab
</code></pre>
<h3 id="改ip改hostname改hosts关机">改IP，改hostname，改hosts，关机</h3>
<pre><code class="language-shell">##### -----------------master:-------------------

echo &quot;master&quot; &gt; /etc/hostname
cat &lt;&lt;EOF &gt;&gt;  /etc/hosts
192.168.1.151 master
192.168.1.152 node01
192.168.1.153 node02
EOF
sed -i s#IPADDR=192.168.3.206#IPADDR=192.168.3.207#g /etc/sysconfig/network-scripts/ifcfg-ens33
sed -i s/UUID/#UUID/g /etc/sysconfig/network-scripts/ifcfg-ens33
reboot


##### -----------------node01:-------------------

echo &quot;node01&quot; &gt; /etc/hostname
cat &lt;&lt;EOF &gt;&gt;  /etc/hosts
192.168.1.151 master
192.168.1.152 node01
192.168.1.153 node02
EOF
sed -i s#IPADDR=192.168.3.206#IPADDR=192.168.3.208#g /etc/sysconfig/network-scripts/ifcfg-ens33
sed -i s/UUID/#UUID/g  /etc/sysconfig/network-scripts/ifcfg-ens33
reboot


##### -----------------node02:-------------------

echo &quot;node02&quot; &gt; /etc/hostname
cat &lt;&lt;EOF &gt;&gt;  /etc/hosts
192.168.1.151 master
192.168.1.152 node01
192.168.1.153 node02
EOF
sed -i s#IPADDR=192.168.3.206#IPADDR=192.168.3.209#g /etc/sysconfig/network-scripts/ifcfg-ens33
sed -i s/UUID/#UUID/g /etc/sysconfig/network-scripts/ifcfg-ens33
reboot


master节点
# 下载yum源
cd /etc/yum.repos.d/
wget  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
yum -y install docker-ce-18.06.1.ce-3.el7
systemctl enable docker&amp;&amp; systemctl start docker

# kubernetes的yum源
cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF


# kubelet是k8s的管理工具
# kubeadm是k8s的安装工具
# kubectl是k8s的客户端
# ----V1.13.3版本----
yum install -y kubelet-1.13.3 kubeadm-1.13.3 kubectl-1.13.3 kubernetes-cni-0.6.0 
# ----V1.15版本------
yum install -y kubelet kubeadm kubectl

# 忽略swap报错
cat &lt;&lt;EOF &gt; /etc/sysconfig/kubelet
KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;
EOF

# 更加转发等功能
cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF
# 让配置生效
sysctl --system

# 开机自启动kubelet
systemctl enable kubelet


# -----------------1.13.3版本----------------
kubeadm init \
  --apiserver-advertise-address=192.168.1.151 \
  --image-repository registry.aliyuncs.com/google_containers \
  --kubernetes-version v1.13.3 \
  --service-cidr=10.1.0.0/16 \
  --pod-network-cidr=10.2.0.0/16 \
  --service-dns-domain=cluster.local \
  --ignore-preflight-errors=Swap \
  --ignore-preflight-errors=NumCPU

# ----------------1.15.0版本---------------
kubeadm init \
  --apiserver-advertise-address=192.168.1.151 \
  --image-repository registry.aliyuncs.com/google_containers \
  --kubernetes-version v1.15.0 \
  --service-cidr=10.1.0.0/16 \
  --pod-network-cidr=10.2.0.0/16 \
  --service-dns-domain=cluster.local \
  --ignore-preflight-errors=Swap \
  --ignore-preflight-errors=NumCPU



# ----------------------参数说明-------------------------
--apiserver-advertise-address：指定用 Master 的哪个IP地址与 Cluster的其他节点通信。

--service-cidr：指定Service网络的范围，即负载均衡VIP使用的IP地址段。

--pod-network-cidr：指定Pod网络的范围，即Pod的IP地址段。

--image-repository：Kubenetes默认Registries地址是k8s.gcr.io，在国内并不能访问 gcr.io，在1.13版本中我们可以增加-image-repository参数，默认值是k8s.gcr.io，将其指定为阿里云镜像地址：registry.aliyuncs.com/google_containers。

--kubernetes-version=v1.13.3：指定要安装的版本号。

--ignore-preflight-errors=：忽略运行时的错误，例如上面目前存在[ERROR NumCPU]和[ERROR Swap]，忽略这两个报错就是增加--ignore-preflight-errors=NumCPU 和--ignore-preflight-errors=Swap的配置即可


------------------------------kubeadm init干了什么？--------------------
[init]：指定版本进行初始化操作

[preflight] ：初始化前的检查和下载所需要的Docker镜像文件

[kubelet-start] ：生成kubelet的配置文件”/var/lib/kubelet/config.yaml”，没有这个文件kubelet无法启动，所以初始化之前的kubelet实际上启动失败。

[certificates]：生成Kubernetes使用的证书，存放在/etc/kubernetes/pki目录中。

[kubeconfig] ：生成 KubeConfig 文件，存放在/etc/kubernetes目录中，组件之间通信需要使用对应文件。

[control-plane]：使用/etc/kubernetes/manifest目录下的YAML文件，安装 Master 组件。

[etcd]：使用/etc/kubernetes/manifest/etcd.yaml安装Etcd服务。

[wait-control-plane]：等待control-plan部署的Master组件启动。

[apiclient]：检查Master组件服务状态。

[uploadconfig]：更新配置

[kubelet]：使用configMap配置kubelet。

[patchnode]：更新CNI信息到Node上，通过注释的方式记录。

[mark-control-plane]：为当前节点打标签，打了角色Master，和不可调度标签，这样默认就不会使用Master节点来运行Pod。

[bootstrap-token]：生成token记录下来，后边使用kubeadm join往集群中添加节点时会用到

[addons]：安装附加组件CoreDNS和kube-proxy



# 系统提示步骤
mkdir -p $HOME/.kube
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
chown $(id -u):$(id -g) $HOME/.kube/config

# 打通网络
cd ~
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

[github地址](https://github.com/coreos/flannel),直接新建这个文件也可以，镜像可能有墙比较慢

# 创建密钥
kubeadm token create --print-join-command
</code></pre>
<h3 id="node节点">node节点</h3>
<pre><code class="language-shell"># 安装docker的yum源
cd /etc/yum.repos.d/
wget  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
yum -y install docker-ce-18.06.1.ce-3.el7
systemctl enable docker&amp;&amp; systemctl start docker

# 写入k8s的yum源
cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF

# 下载k8s的组件
----V1.13.3版本----
yum install -y kubelet-1.13.3 kubeadm-1.13.3 kubectl-1.13.3 kubernetes-cni-0.6.0 
----V1.15版本------
yum install -y kubelet kubeadm kubectl

# 忽略swap错误
cat &lt;&lt;EOF &gt; /etc/sysconfig/kubelet
KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;
EOF

# 开启系统转发
cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF

# 让配置生效
sysctl --system

# 设置服务开机自启动
systemctl enable kubelet


# 加入集群（令牌过期作废）
kubeadm join 192.168.3.207:6443 --token a4645k.pq7e5e34y9sl9g53 --discovery-token-ca-cert-hash sha256:abd02c82cdefbcc2d17a2f53ec9b376e31d123ef33af880608d97f64b12a65f5  --ignore-preflight-errors=Swap
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker搭建私有仓库]]></title>
        <id>https://grassroadsz.github.io/SYEUK_VDx/</id>
        <link href="https://grassroadsz.github.io/SYEUK_VDx/">
        </link>
        <updated>2022-05-29T09:02:38.000Z</updated>
        <content type="html"><![CDATA[<p>前提条件</p>
<p>node01对应ip：192.168.1.152<br>
node02对应ip：192.168.1.153</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/grassroadsZ/picture@master/image.4dq8l2g2dmw0.webp" alt="image" loading="lazy"></figure>
<h2 id="服务端操作node01节点">服务端操作(node01节点)</h2>
<p>在ROOT下执行，把证书保存在/root/certs目录下</p>
<pre><code class="language-shell">mkdir certs
</code></pre>
<p>进入certs目录，创建文件domain.key</p>
<pre><code class="language-shell">touch domain.key

openssl req -newkey rsa:2048 -nodes -sha256 -keyout /root/certs/domain.key -x509 -days 365 -out /root/certs/domain.crt
</code></pre>
<p>然后根据提示数据一些信息，如下图，倒数第二行输入节点名称node5</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/grassroadsZ/picture@master/image.2ruqn8ewj080.webp" alt="image" loading="lazy"></figure>
<p>将domain.crt拷贝到 /etc/docker/certs.d/node5:5000/ca.crt，</p>
<pre><code class="language-shell">mkdir -p /etc/docker/certs.d/node5:5000

cp certs/domain.crt /etc/docker/certs.d/node5:5000/ca.crt
</code></pre>
<p>将domain.crt内容放入系统的CA bundle文件当中，使操作系统信任我们的自签名证书。</p>
<pre><code class="language-shell">cat certs/domain.crt &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt
</code></pre>
<p>修改docker的daemon.json文件，添加如下内容</p>
<pre><code class="language-shell">vi /etc/docker/daemon.json
</code></pre>
<pre><code class="language-shell">{   

&quot;insecure-registries&quot;: [ &quot;node01:5000&quot;]

}
</code></pre>
<p>重启docker</p>
<pre><code class="language-shell">systemctl daemon-reload &amp;&amp; systemctl restart docker
</code></pre>
<p>下载registry镜像（本次用node5节点作为私有镜像库服务器）</p>
<pre><code class="language-shell"># 拉取registry

docker pull registry

# 创建容器并运行

docker run -itd -v /data/registry:/var/lib/registry -v ~/certs/:/root/certs -e REGISTRY_HTTP_TLS_CERTIFICATE=/root/certs/domain.crt -e REGISTRY_HTTP_TLS_KEY=/root/certs/domain.key -p 5000:5000 --restart=always --name registry registry:latest

# 上面命令执行了此步骤可以不做
docker run -itd -p 192.168.3.195:5000:5000 -v /data/docker/registry:/var/lib/registry --restart=always --name registry registry:latest

# 把服务端的证书拷贝到客户端机器：

cd certs/
scp domain.crt root@172.16.11.3:/root/certs/
</code></pre>
<h2 id="客户端操作node02节点">客户端操作（node02节点）</h2>
<p>先把服务端的证书拷贝到本机的/root/certs/下面，然后执行</p>
<pre><code class="language-shell">mkdir -p /etc/docker/certs.d/node5:5000

cp certs/domain.crt /etc/docker/certs.d/node5:5000/ca.crt
</code></pre>
<p>将domain.crt内容放入系统的CA bundle文件当中，使操作系统信任我们的自签名证书。</p>
<pre><code class="language-shell">cat certs/domain.crt &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt
</code></pre>
<p>修改docker的daemon.json文件，添加如下内容</p>
<pre><code class="language-shell">vi /etc/docker/daemon.json
</code></pre>
<pre><code class="language-shell">{   

&quot;insecure-registries&quot;: [ &quot;node01:5000&quot;]

}
</code></pre>
<p>重启docker</p>
<pre><code class="language-shell">systemctl daemon-reload &amp;&amp; systemctl restart docker
</code></pre>
<p>测试上传镜像</p>
<pre><code class="language-shell">docker pull ubuntu

docker tag ubuntu:latest  node01:5000/ubuntu:v1

docker push node01:5000/ubuntu:v1
</code></pre>
<p>测试是否可以拉取镜像</p>
<pre><code class="language-shell">docker pull node01:5000/ubuntu:v1
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/grassroadsZ/picture@master/image.3o2qsz9gmcs0.webp" alt="image" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker安装与卸载]]></title>
        <id>https://grassroadsz.github.io/qK-SfR0HM/</id>
        <link href="https://grassroadsz.github.io/qK-SfR0HM/">
        </link>
        <updated>2022-05-29T08:54:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装方式一推荐">安装方式一（推荐）</h2>
<pre><code class="language-shell"># 卸载旧版本
$ sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
  
# 安装依赖                  
sudo yum install -y yum-utils device-mapper-persistent-data lvm2

# 换源
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

# 换源后更新yum缓存
sudo yum makecache fast

# 安装docker
yum install docker -y

# 启动并测试是否安装成功
sudo systemctl start docker
docker run hello-world

</code></pre>
<h2 id="方式二使用脚本快捷安装docker-ce版不推荐">方式二：使用脚本快捷安装docker CE版(不推荐)</h2>
<pre><code class="language-shell">$ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh --mirror Aliyun

# 安装后启动docker CE

$ sudo systemctl enable docker
$ sudo systemctl start docker

# 安装镜像加速
vim /etc/docker/daemon.json

{
  &quot;registry-mirrors&quot;: [
    &quot;https://registry.docker-cn.com&quot;
  ]
}
# 之后重新启动

$ sudo systemctl daemon-reload
$ sudo systemctl restart docker
</code></pre>
<p>解决CE版的如下警告</p>
<pre><code class="language-shell">WARNING: bridge-nf-call-iptables is disabled
WARNING: bridge-nf-call-ip6tables is disabled
</code></pre>
<pre><code class="language-shell">$ sudo tee -a /etc/sysctl.conf &lt;&lt;-EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF

</code></pre>
<p>然后重新加载</p>
<p>$ sudo sysctl -p</p>
<h2 id="卸载">卸载</h2>
<p>先停止镜像的container，然后删除container，再删除镜像(删除的时候镜像名写全)</p>
<pre><code class="language-shell">docker image ls
docker stop container_name
docker rm container_name 
docker image rm &lt;image_name&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 常用命令]]></title>
        <id>https://grassroadsz.github.io/ANGbPIaE6/</id>
        <link href="https://grassroadsz.github.io/ANGbPIaE6/">
        </link>
        <updated>2022-05-29T08:44:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文件">文件</h1>
<h2 id="查找目录下mp4格式的文件">查找目录下.mp4格式的文件</h2>
<pre><code class="language-shell">find 目录 -name &quot;*.mp4&quot;
</code></pre>
<h2 id="查找home目录下name包含mp4的60分钟前的文件">查找home目录下name包含mp4的60分钟前的文件</h2>
<pre><code class="language-shell">find /home -name &quot;*.mp4&quot; -type f -mmin +60 -exec ls {} \;
</code></pre>
<h2 id="查找home目录下name包含mp4的60分钟前的文件并删除">查找home目录下name包含mp4的60分钟前的文件并删除</h2>
<pre><code class="language-shell">find /home -name &quot;*.mp4&quot; -type f -mmin +60 -exec rm {} \;
</code></pre>
<h2 id="查找当前目录下大于10m的文件">查找当前目录下大于10m的文件</h2>
<pre><code class="language-shell">find . -size +10M
</code></pre>
<h1 id="网络与进程">网络与进程</h1>
<h2 id="查看端口占用">查看端口占用</h2>
<pre><code class="language-shell">netstat -anp|grep port
</code></pre>
<h2 id="获取进程名-进程号以及用户-id">获取进程名、进程号以及用户 ID</h2>
<pre><code class="language-shell">netstat -tlnp
</code></pre>
<h2 id="统计当前机器连接数">统计当前机器连接数</h2>
<pre><code class="language-shell">netstat -tnp|wc -l

</code></pre>
<h2 id="实时监控阿里云盾的cpu与内存使用情况">实时监控阿里云盾的cpu与内存使用情况</h2>
<pre><code class="language-shell">#top -b 指定为非交互模式下-p 指定pid -n指定行号
 while true;do sleep 1 ;top -b -p 10960 -n 1|tail -n 1|awk '{print $9,$10}';done
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/grassroadsZ/picture@master/image.6c88vnqbv7c0.webp" alt="image" loading="lazy"></figure>
<h2 id="统计nginx日志中访问量前三的ip">统计nginx日志中访问量前三的ip</h2>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/grassroadsZ/picture@master/image.56g0fmlkevk0.webp" alt="image" loading="lazy"></figure>
<pre><code class="language-shell"># awk取第一列的ip：awk '{print $1}' /var/log/nginx/access.log,排序后去重统计：sort|uniq -c,排序去重统计结果再排序取前三：sort -rn|head -n 3

awk '{print $1}' /var/log/nginx/access.log|sort|uniq -c|sort -rn|head -n 3
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/grassroadsZ/picture@master/image.2aftii7iqbk0.webp" alt="image" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工作中使用的shell脚本]]></title>
        <id>https://grassroadsz.github.io/0pbx98OrS/</id>
        <link href="https://grassroadsz.github.io/0pbx98OrS/">
        </link>
        <updated>2022-05-29T08:35:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="网卡监控">网卡监控</h2>
<pre><code class="language-shell">while true;
do
rx_before=$(cat /proc/net/dev | grep 'ens' | tr : &quot; &quot; | awk '{print $2}')
tx_before=$(cat /proc/net/dev | grep 'ens' | tr : &quot; &quot; | awk '{print $10}')
sleep 1
#rx_after=`ifconfig ens0|sed -n &quot;7p&quot;|awk '{print $2}'|cut -c7-`
#tx_after=`ifconfig ens0|sed -n &quot;7p&quot;|awk '{print $6}'|cut -c7-`
rx_after=$(cat /proc/net/dev | grep 'ens' | tr : &quot; &quot; | awk '{print $2}')
tx_after=$(cat /proc/net/dev | grep 'ens' | tr : &quot; &quot; | awk '{print $10}')

rx_result=$[(rx_after-rx_before)/1024/1024/2*8]
tx_result=$[(tx_after-tx_before)/1024/1024/2*8]
echo  &quot;$time Now_In_Speed: $rx_result Mbps Now_OUt_Speed: $tx_result Mbps&quot;

done
</code></pre>
<h2 id="内存cpu监控">内存CPU监控</h2>
<pre><code class="language-shell">#! /bin/bash
# description: 大文件上传下载服务器性能监控脚本
# author：grassroadsZ
# Date: 2020-4-21 17:30:04

# 服务器CPU使用情况，每1s输出一次
while true;
do sleep 1 ;


echo -n &quot;服务器总内存为：$(free -m|grep Mem|awk '{printf $2}')MB,剩余内存为：$(free -m|grep Mem|awk '{printf $4}')MB&quot;

u=$(top -b -n 1|grep Cpu|awk '{print $2}')
s=$(top -b -n 1|grep Cpu|awk '{print $4}')
cpu_count=$(awk -v a=$u -v b=$s 'BEGIN{print a+b}')

echo -e &quot;\nCPU使用率为用户使用率：${u} % + 系统使用率 ${s} % = ${cpu_count} %\n&quot;

done
</code></pre>
<h2 id="批量新建用户">批量新建用户</h2>
<pre><code class="language-shell">#!/bin/bash
# 批量创建用户
read -p &quot;input nu &lt;1-99&gt;:&quot; nu

read -p &quot;input name:&quot; name

read -p &quot;input date &lt;YYYY-MM-DD&gt;:&quot; date

read -p &quot;input password:&quot; password

a=1

if [ $nu -lt 100 ];
then

while [ $a -le $nu ]

do

if [ $a -lt 10 ]

then

useradd -e $date &quot;$name&quot;0&quot;$a&quot;

echo &quot;$passwd&quot; | --stdin &quot;$name&quot;0&quot;$a&quot;&amp;&gt; /dev/null

else

useradd -e $date &quot;$name&quot;&quot;$a&quot;

echo &quot;password&quot; | passwd --stdin &quot;$name&quot;&quot;$a&quot;&amp;&gt; /dev/null

fi

a=`expr $a + 1`

done

fi
</code></pre>
<h2 id="批量删除用户">批量删除用户</h2>
<pre><code class="language-shell">#!/bin/bash
# 用法 bash file.sh 批量用户名前缀
if [ $# -le 0 ]

then

 echo &quot; Error:The prefix of users has not be specified. &quot;

 echo &quot; usage:$0nameprefix &quot;

exit1

fi

tar jcvf /root/usrs.cnf.tar.gz /etc/passwd /etc/shadow /etc/group &amp;&gt; /dev/null

usersdel=`grep &quot;$1&quot; /etc/passwd | cut -d &quot;:&quot; -f 1 | grep -v &quot;root&quot;`

for u in $usersdel

do

userdel -r $u &amp;&gt; /dev/null

done
</code></pre>
<h2 id="文件上传监控">文件上传监控</h2>
<pre><code class="language-shell">#!/bin/bash
filename=test_file1.bag.filepart
filesize=`ls -l $filename | awk '{ print $5 }'`
# 100GB
maxsize=$((1024*100*1024*1024))
while true;
do
if [ $filesize -eq $maxsize ]
then
    echo &quot;文件上传完毕&quot;
    echo &quot;${date}&quot;
    
else 
    echo &quot;文件没传完，继续....&quot;
    echo “当前耗时 $(expr $(date +%s) - $(date -d &quot;2020-05-07 09:41:48&quot; +%s))s
    echo 当前文件大小 $(ls -l ${filename} | awk '{ print $5 }') 字节
fi

sleep 3
done
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 挂载磁盘]]></title>
        <id>https://grassroadsz.github.io/dBGV0cXXS/</id>
        <link href="https://grassroadsz.github.io/dBGV0cXXS/">
        </link>
        <updated>2022-05-29T08:30:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="查看未挂载磁盘">查看未挂载磁盘</h2>
<p>fdisk -l</p>
<pre><code class="language-shell">[root@debug010000002015 ~]# fdisk -l

Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0000efd2

   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *        2048   104855551    52426752   83  Linux

Disk /dev/vdb: 536.9 GB, 536870912000 bytes, 1048576000 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
</code></pre>
<h2 id="分区">分区</h2>
<p>fdisk /dev/vdb</p>
<pre><code class="language-shell">[root@debug010000002015 ~]# fdisk /dev/vdb 
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xa36ad56b.

Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)

Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-1048575999, default 2048): 
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-1048575999, default 1048575999): 
Using default value 1048575999
Partition 1 of type Linux and of size 500 GiB is set

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
</code></pre>
<p>fdisk -l</p>
<pre><code class="language-shell">[root@debug010000002015 ~]# fdisk -l

Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0000efd2

   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *        2048   104855551    52426752   83  Linux

Disk /dev/vdb: 536.9 GB, 536870912000 bytes, 1048576000 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xa36ad56b

   Device Boot      Start         End      Blocks   Id  System
/dev/vdb1            2048  1048575999   524286976   83  Linux
</code></pre>
<h2 id="格式化">格式化</h2>
<p>mkfs -t ext4 -c /dev/vdb1</p>
<pre><code class="language-shell">[root@debug010000002015 ~]# mkfs -t ext4 -c /dev/vdb1 
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
32768000 inodes, 131071744 blocks
6553587 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=2279604224
4000 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
	4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, 
	102400000

Checking for bad blocks (read-only test):  33.57% done, 9:34 elapsed. (0/0/0 errors)
</code></pre>
<h2 id="挂载">挂载</h2>
<p>mount /dev/vdb1 /data/</p>
<pre><code>[root@debug010000002015 ~]# mount /dev/vdb1 /data/

查看
df -hl

[root@debug010000002015 ~]# df -hl
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda1        50G  2.1G   45G   5% /
devtmpfs        3.9G     0  3.9G   0% /dev
tmpfs           3.9G     0  3.9G   0% /dev/shm
tmpfs           3.9G  316K  3.9G   1% /run
tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup
tmpfs           783M     0  783M   0% /run/user/0
/dev/vdb1       493G   73M  467G   1% /data
</code></pre>
<p>开机自启动<br>
设置开机自动挂载，修改/etc/fstab文件，在最后一行添加如下内容：</p>
<p>/dev/sdb       /data         ext4    defaults        1 1<br>
<img src="https://cdn.jsdelivr.net/gh/grassroadsZ/picture@master/image.25d635uowo0w.webp" alt="image" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shell 基础]]></title>
        <id>https://grassroadsz.github.io/uZq7nEUWR/</id>
        <link href="https://grassroadsz.github.io/uZq7nEUWR/">
        </link>
        <updated>2022-05-28T08:12:07.000Z</updated>
        <content type="html"><![CDATA[<p>一、简介</p>
<p>shell是什么</p>
<ul>
<li>命令解释器</li>
<li>shell就是在操作系统和应用程序之间的一个命令翻译工具</li>
</ul>
<p>shell分类</p>
<ul>
<li>
<p>Windows</p>
</li>
<li>
<ul>
<li>cmd命令行</li>
</ul>
</li>
<li>
<p>Linux</p>
</li>
<li>
<ul>
<li>Sh / bash / zsh /</li>
</ul>
</li>
</ul>
<p>二、常用命令</p>
<p>1.head</p>
<ul>
<li>默认获取文件的前10 行</li>
</ul>
<p>2.tail</p>
<ul>
<li>默认获取最后10行</li>
<li>取文件第6到第9行：head -9 file |tail -n 4</li>
</ul>
<p>3.cut</p>
<ul>
<li>取出文本指定的列</li>
<li>-d 指定分隔符</li>
<li>-f 指定行</li>
</ul>
<p>4.uniq</p>
<ul>
<li>去重（需先排序）</li>
<li>-d 打印重复行</li>
<li>-c 统计出现的次数</li>
</ul>
<p>5.sort</p>
<ul>
<li>将文件排序，默认以ASCII 码从小到大排序</li>
<li>-r 反序</li>
<li>-n 以数字类型排序</li>
<li>-t 指定分隔符</li>
<li>-k 指定排序的列号</li>
</ul>
<p>将文件最后一列取出进行排序去重cut -d 分隔符 -f 行号 file|sort|uniq</p>
<p>6.wc(word count)</p>
<p>统计文件</p>
<ul>
<li>-l 行号</li>
<li>-w 单词数</li>
<li>-c 字节数</li>
<li>-L 最长行的字节数</li>
</ul>
<p>三、变量</p>
<p>定义变量</p>
<p>本地变量</p>
<p>只在当前bash生效</p>
<p>username='grassroadsZ'<br>
username=&quot;grassdoadsZ&quot;</p>
<p>单引号和双引号的区别：单引号里面是什么就会输出什么，双引号可以做变量替换</p>
<p>输出:</p>
<p>echo $username</p>
<p>等号两侧不能有空格</p>
<ul>
<li>将linux 命令赋值给变量<br>
one_var=$(pwd)<br>
echo $one_var</li>
</ul>
<p>全局变量</p>
<p>所有的bash都能用（临时全局变量）</p>
<ul>
<li>方法一：<br>
变量=值<br>
export 变量</li>
<li>方法二:<br>
export 变量=值</li>
</ul>
<p>env ：查看当前的环境变量（永久变量）</p>
<ul>
<li>新建全局变量</li>
</ul>
<p>vim ~/.bashrc<br>
export username=&quot;grassroadsZ&quot;</p>
<p>查看变量</p>
<p>echo $变量名</p>
<p>echo &quot;$变量名&quot;</p>
<p>echo &quot;${变量名}&quot;（shell脚本中较常用）</p>
<p>内置变量</p>
<ul>
<li>$0:   获取当前执行shell的文件名</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>:</mo><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">的</mi><mi>s</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">脚</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">第</mi><mi>n</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi>n</mi><mo>=</mo><mn>1..9</mn><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mn>9</mn><mi mathvariant="normal">就</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">括</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">括</mi><mi mathvariant="normal">起</mi><mi mathvariant="normal">来</mi></mrow><annotation encoding="application/x-tex">n:   获取当前执行的shell脚本的第n个参数值，n=1..9如果大于9就要用大括号括起来</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">脚</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">第</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">9</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span><span class="mord">9</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">括</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">括</span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">来</span></span></span></span>{10}</li>
<li>$#:   获取当前shell命令中的参数总个数</li>
<li>$?:    获取上一条命令的执行结果，echo $?为0的话代表上一条命令执行成功，非0为失败</li>
<li>$*: 获取所有参数</li>
</ul>
<p>示例：</p>
<pre><code class="language-shell">#! /bin/bash

echo &quot;当前脚本名为：$0&quot;
echo &quot;第一个参数为：$1&quot;
# ...
echo &quot;第十一个参数为：${11}&quot;

echo &quot;参数总数为：$#&quot;
echo &quot;一次性获取所有的参数：$*&quot;
</code></pre>
<p>四、数值运算</p>
<p>方式一</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mi mathvariant="normal">算</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">达</mi><mi mathvariant="normal">式</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">加</mi></mrow><annotation encoding="application/x-tex">((算数表达式))，变量可以不加</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">式</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">加</span></span></span></span></p>
<p>方式二</p>
<p>expr 表达式,此处变量的$不可以省略</p>
<p>实例:</p>
<pre><code class="language-shell">one=10
two=20
# 求和
$(($one + $two)) # 或者写为$((one + two))
# 乘法
result=$(expr $one * $two)
# 比较大小,需转义,两个括号时不需要转义，如果大于不成立返回0，大于成立返回1
result=$(expr $one \&gt; $two) # 或者写为$(($one &gt; $two))
</code></pre>
<p>五、条件表达式</p>
<p>返回值</p>
<ul>
<li>条件成立，返回0</li>
<li>条件不成立，返回1</li>
</ul>
<p>逻辑表达式</p>
<p>&amp;&amp; 和||和！</p>
<p>one_word=1</p>
<h1 id="如果one_word1输出one_word是1否则输出one_word不是1">如果one_word=1输出one_word是1否则输出one_word不是1</h1>
<h1 id="写法一空格-表达式-空格">写法一：[空格 表达式 空格]</h1>
<p>[ &quot;${one_word}&quot;==1 ] &amp;&amp; echo 'one_word是1'|| echo &quot;one_word不是1&quot;</p>
<h1 id="写法二">写法二：</h1>
<p>test &quot;${one_word}&quot; == 1 &amp;&amp; echo &quot;one_word是1&quot;|| echo &quot;one_word不是1&quot;</p>
<p>文件表达式</p>
<ul>
<li>-f 判断输入的内容是否是一个文件</li>
<li>-d 是否是目录</li>
<li>-x 是否可执行</li>
<li>-e 是否存在</li>
</ul>
<p>实例</p>
<p>[ -f anaconda-ks.cfg ] &amp;&amp; echo '是文件'|| echo &quot;不是文件&quot;<br>
[ -d anaconda-ks.cfg ] &amp;&amp; echo '是目录'|| echo &quot;不是目录&quot;<br>
[ -x anaconda-ks.cfg ] &amp;&amp; echo '可执行'|| echo &quot;不可执行&quot;<br>
[ -e anaconda-ks.cfg ] &amp;&amp; echo '存在'|| echo &quot;不存在&quot;</p>
<p>数值操作符</p>
<ul>
<li>n1 -eq n2 相等</li>
<li>n1 -gt n2 大于</li>
<li>n1 -lt n2 小于</li>
<li>n1 -ne n2 不等于</li>
<li>n1 -ge  n2 大于等于</li>
</ul>
<p>字符串比较</p>
<ul>
<li>str1 == str2 是否相等</li>
<li>str1 != str2 是否不相等</li>
</ul>
<p>六、shell脚本格式</p>
<p>shell脚本调试: bash -x file.sh</p>
<p>格式要求</p>
<ul>
<li>首行指定执行shell的程序<br>
#! /bin/bash<br>
echo &quot;你好, ${USER}&quot;</li>
<li>命名见名知意</li>
</ul>
<p>注释</p>
<h1 id="单行注释">单行注释</h1>
<p>:&lt;&lt;!<br>
这是多行注释<br>
!</p>
<p>七、函数</p>
<p>格式</p>
<h1 id="格式一">格式一:</h1>
<p>函数名()</p>
<p>{</p>
<p>命令1</p>
<p>命令2</p>
<p>}</p>
<h1 id="格式二">格式二:</h1>
<p>function 函数名</p>
<p>{</p>
<p>命令1</p>
<p>}</p>
<p>#!/bin/bash</p>
<h1 id="description定义函数两种方法demo">Description:定义函数两种方法demo</h1>
<h1 id="方式一">方式一：</h1>
<p>hello()<br>
{<br>
echo &quot;你好! <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>U</mi><mi>S</mi><mi>E</mi><mi>R</mi></mrow><mo separator="true">,</mo><mi mathvariant="normal">今</mi><mi mathvariant="normal">天</mi><mi mathvariant="normal">是</mi></mrow><annotation encoding="application/x-tex">{USER},今天是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">今</span><span class="mord cjk_fallback">天</span><span class="mord cjk_fallback">是</span></span></span></span>(date)&quot;<br>
}</p>
<h1 id="方式二">方式二:</h1>
<p>function hello<br>
{<br>
echo &quot;你好!&quot;<br>
}</p>
<h1 id="调用函数">调用函数</h1>
<h1 id="直接使用函数名进行调用">直接使用函数名进行调用</h1>
<p>hello</p>
<p>参数</p>
<pre><code class="language-shell">#! /bin/bash
echo &quot;$1 $2&quot;
function your_info()
{
	echo &quot;你的姓名：$1, age为：$2&quot;
}
your_info grassroadsZ 18
</code></pre>
<h1 id="参数为一一对应your_info-2-1-对应的2-对应的为11对应的为2">参数为一一对应your_info $2 $1 --&gt; 对应的$2 对应的为$1,$1对应的为$2</h1>
<h1 id="执行结果">执行结果</h1>
<p>[root@Centos7 bin]# bash file.sh 10 20<br>
10,20<br>
你的姓名是：grassroadsZ，你的年龄为18</p>
<p>接受用户参数</p>
<pre><code class="language-shell">#! /bin/bash
read -p &quot;请输入姓名: &quot;空格name
read -p &quot;请输入年龄: &quot; age
# 如果不使用变量接收，默认变量为REPLY
read -p &quot;请输入年龄: &quot;

function your_info
{
	echo &quot;你的姓名：${name}, age为：${age}&quot;
	# 换行
	echo -e &quot;你的姓名：${name}, \n你的age为：${age}&quot;
	echo &quot;你的姓名：${name}, age为：${REPLY}&quot;
}
</code></pre>
<p>八、流程控制</p>
<pre><code class="language-shell">if

if [条件]
then
	指令1
elif [条件2]
then
	指令2
else
	指令3
fi
</code></pre>
<p>实例1</p>
<pre><code class="language-shell">#! /bin/bash
#Description:判断是否可以上网
read -p &quot;姓名&quot; name
read -p &quot;年龄&quot; age
if [ &quot;${age}&quot; -ge 70 ]
then
	echo &quot;${name},大于等于70岁&quot;
elif [ &quot;${age}&quot; -ge 18 ]
then
	echo &quot;${name}大于18&quot;
else
	echo &quot;${name}小于18岁&quot;
fi
</code></pre>
<p>实例2</p>
<pre><code class="language-shell">#! /bin/bash
#Description:根据命令启动停止服务
if [! &quot;$1&quot; -eq 1]; then
	echo &quot;Usage: $0 [start | stop |restart]&quot;
	exit 1
fi

if [ &quot;$1&quot;==&quot;start&quot; ]; then
	echo &quot;服务启动中。。。。&quot;
elif [ &quot;$1&quot;==&quot;restart&quot; ]; then
	echo &quot;服务重启中。。。&quot;
else
	echo &quot;服务暂停中。。。&quot;
fi

exit 0
</code></pre>
<p>for</p>
<h1 id="格式一-2">格式一</h1>
<pre><code>for v in 列表
do
    执行语句
done
</code></pre>
<h1 id="格式二-2">格式二</h1>
<pre><code>max=10
for ((i=1;i&lt;=max;i++))
do
    echo &quot;$i&quot;
done
</code></pre>
<p>实例</p>
<pre><code class="language-shell">#! /bin/bash
#Description:for循环
dirs=$(ls /)
for dir in ${dirs}
do
	echo &quot;${dir}&quot;
done
</code></pre>
<p>while</p>
<pre><code class="language-shell">#! /bin/bash
#Description:while循环
i=1
max=10
while [ &quot;${i}&quot; -lt &quot;${max}&quot; ]
do
 echo &quot;${i}&quot;
 i=$((i+1))
done
</code></pre>
<p>case</p>
<p>case 变量名 in<br>
值1）<br>
指令1<br>
;;<br>
值2)<br>
指令2<br>
;;<br>
值3）<br>
指令3<br>
;;</p>
<p>实例</p>
<pre><code class="language-shell">#! /bin/bash
#Description:case计算器

function shwo_error
{
	echo &quot;Usage: $0 num 1[+ | - |\*|/] num2&quot;
}


if [! &quot;$1&quot; -eq 1]; then
	show_error
	exit 1
fi

case &quot;$2&quot; in
	+)
		echo &quot;$1 + $3 = $(($1 + $3))&quot;
		;;
	-)
		echo &quot;$1 - $3 = $(($1 - $3))&quot;
		;;
	\*)
		echo &quot;$1 * $3 = $(($1 * $3))&quot;
		;;
	-)
		echo &quot;$1 / $3 = $(($1 / $3))&quot;
		;;
	*)
      echo &quot;非法输入&quot;
      show_error
      ;;
esac
exit 0
</code></pre>
<p>九、文本处理三剑客</p>
<p>grep</p>
<ul>
<li>两种形式
<ul>
<li>grep [option] pattern [file1,file2....]</li>
<li>Some command | grep [option]</li>
</ul>
</li>
</ul>
<p>[root@Centos7 ~]# grep root /etc/passwd<br>
root❌0:0:root:/root:/bin/bash<br>
operator❌11:0:operator:/root:/sbin/nologin</p>
<p>sed</p>
<ul>
<li>流文件编辑器</li>
<li>两种形式</li>
<li>不加任何参数数时，默认会将匹配到的内容打印两次
<ul>
<li>sed [option] &quot;partten command&quot; file</li>
<li>Some conmmand |sed [option] &quot;parttern command&quot;</li>
</ul>
</li>
</ul>
<h1 id="只打印password中的oo">只打印password中的oo</h1>
<p>sed -n &quot;/oo/ p&quot; /etc/password</p>
<h1 id="只打印第6行">只打印第6行</h1>
<p>sed -n '6 p' /etc/password</p>
<h1 id="打印38行">打印3,8行</h1>
<p>sed -n &quot;3,8 p&quot; /etc/password</p>
<h1 id="打印以h开头到o开头">打印以h开头到o开头</h1>
<p>sed -n &quot;/<sup>h/,/</sup>o/ p&quot; /etc/password</p>
<p>command命令</p>
<ul>
<li>p打印</li>
<li>新增
<ul>
<li>a （after）在匹配行后新增</li>
<li>i （insert）在匹配行前新增</li>
<li>r （read）外部文件读入，行后新增</li>
<li>w （write）匹配行写入外部文件</li>
</ul>
</li>
<li>删除
<ul>
<li>d 删除</li>
</ul>
</li>
<li>修改
<ul>
<li>s/old/new/	(只修改匹配中的一个old)</li>
<li>s/old/new/g  （修改匹配行中所有的old）</li>
<li>s/old/new/ig   （修改忽略大小写）</li>
</ul>
</li>
</ul>
<p>实例</p>
<h1 id="在password的第9行前面新增hello-word">在password的第9行前面新增hello word</h1>
<p>sed '9 i &quot;hello world&quot;' password（# 内存修改，未提交）<br>
sed -i '9 i &quot;hello world&quot;' password（# 真实修改文件）</p>
<h1 id="在password的中以mail开头的后面前面新增hello-word">在password的中以mail开头的后面前面新增hello word</h1>
<p>sed -i '/^mail/ a 新增的hello word' password</p>
<h1 id="在sbinnologin后新增hello">在/sbin/nologin后新增hello</h1>
<p>sed -i '//sbin/nologin a 新增 hello' password</p>
<h1 id="将filetxt的内容新增到password中出现两个o的行">将file.txt的内容新增到password中出现两个o的行</h1>
<p>sed -ir '/o{2}/ r file.txt' password</p>
<h1 id="将69行的内容写入到-twotxt">将6,9行的内容写入到 two.txt</h1>
<p>sed  '6,9 w two.txt' password</p>
<h1 id="以s开头的行进行删除">以s开头的行进行删除</h1>
<p>sed -i '/^s/ d' password</p>
<h1 id="将含有bin的行改写为bin">将含有bin的行改写为BIN</h1>
<p>sed -i 's/bin/BIN/' password	# (一行中多个只修改一次)<br>
sed -i 's/bin/BIN/g' password	# （修改所有）<br>
sed -i 's/bin/BIN/ig' password	# （修改所有）</p>
<h1 id="第1到10行的修改为">第1到10行的：修改为？</h1>
<p>sed -i '1,10 s/😕?/g' password</p>
<h1 id="删除-开头的注释">删除# 开头的注释</h1>
<p>sed -i '/^#/d' file</p>
<h1 id="删除空行">删除空行</h1>
<p>sed -i '/^$/d' file</p>
<p>awk</p>
<ul>
<li>文本处理，处理数据并生成结果报告</li>
<li>两种形式
<ul>
<li>awk 'BEGIN{} pattern {commands} END{}' file</li>
<li>Some command | awk 'BEGIN{} pattern {commands} END{}</li>
</ul>
</li>
</ul>
<h1 id="默认分隔符为空格">默认分隔符为空格</h1>
<h1 id="打印整行">打印整行</h1>
<p>awk '{print $0}' file</p>
<h1 id="打印第一列">打印第一列</h1>
<p>awk '{print $1}' file</p>
<h1 id="打印最后一列无论规则与否">打印最后一列，无论规则与否</h1>
<p>awk '{print $NF}' file</p>
<h1 id="如果当前行号大于1则打印当前行">如果当前行号大于1则打印当前行</h1>
<p>awk ' NR &gt; 1 {print $0}' file</p>
<h1 id="指定分隔符">指定分隔符</h1>
<p>awk 'BEGIN {FS=&quot;:&quot;} {print $1}' file</p>
<h1 id="指定为分隔符将第3列数值大于100的行的第一列打印">指定:为分隔符将第3列数值大于100的行的第一列打印</h1>
<p>awk 'BEGIN{FS=&quot;:&quot;} $3&gt;100 {print $1}' password</p>
<h1 id="指定为分隔符将第3列数值大于100的行的第一列及总处理的行数">指定:为分隔符将第3列数值大于100的行的第一列及总处理的行数</h1>
<p>awk 'BEGIN{FS=&quot;:&quot;} $3&gt;100 {i++; print $1} END{print i}' password</p>
<h1 id="填充格式与python中的字符串输出一样">填充格式与python中的字符串输出一样</h1>
<p>awk 'BEGIN{FS=&quot;:&quot;} $3&gt;100 {printf &quot;%s\n&quot; $1}' pwd</p>
<h1 id="输出带表头的内容">输出带表头的内容</h1>
<p>awk 'BEGIN{FS=&quot;:&quot;;printf &quot;%-18s%-6s%-18s\n&quot;,&quot;user&quot;,&quot;uid&quot;,&quot;shell&quot;} $3&gt;100 {printf &quot;%-18s%-6s%-18s\n&quot; $1, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">3,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span></span></span></span>NF}' pwd</p>
<h1 id="输出带表头的内容-2">输出带表头的内容</h1>
<p>awk 'BEGIN{FS=&quot;:&quot;;printf &quot;%-18s%-6s%-18s\n&quot;,&quot;user&quot;,&quot;uid&quot;,&quot;shell&quot;} $3&gt;100 {count++; printf &quot;%-18s%-6s%-18s\n&quot; $1, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">3,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span></span></span></span>NF} END{printf &quot;%-18s%-6s\n&quot; &quot;Toal&quot;, count}' pwd</p>
<p>awk长命令脚本化</p>
<h1 id="begin-块">BEGIN 块</h1>
<p>BEGIN{<br>
FS=&quot;:&quot;;<br>
printf &quot;%-18s%-6s%-18s\n&quot;,&quot;user&quot;,&quot;uid&quot;,&quot;shell&quot;<br>
}</p>
<h1 id="command块">command块</h1>
<p>{<br>
if ($3&gt;100){<br>
count++;<br>
printf &quot;%-18s%-6s%-18s\n&quot; $1, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">3,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span></span></span></span>NF<br>
}<br>
}</p>
<h1 id="end块">END块</h1>
<p>END{<br>
printf &quot;%-18s%-6s\n&quot; &quot;Toal&quot;, count}</p>
<p>调用：awk -f file.awk file</p>
<p>实例</p>
<p>Linux 系统截图</p>
<p>描述如下基础命令的作用</p>
<ul>
<li>ls: 列出当前目录所有文件(不包含隐藏文件，指定参数-a可显示隐藏文件)</li>
<li>pwd:当前所在路径</li>
<li>cd:进入到某一个目录</li>
<li>touch:新建文件</li>
<li>mkdir：创建目录</li>
<li>rm：删除文件或目录</li>
<li>mv:移动文件</li>
<li>cp：复制文件</li>
<li>cat:查看文件</li>
<li>more: 分段查看文件</li>
<li>tar：tar格式的文件解压缩</li>
<li>which：输出命令的位置</li>
</ul>
<p>获取/etc/passwd文件的第4~7行</p>
<p>head -n 7 /etc/passwd|tail -n 4</p>
<p>在必做题第3题的基础上，以第4列的数字大小进行排序</p>
<p>root@Centos7 bin]# head -n 7 /etc/passwd|tail -n 4 |sort -t&quot;:&quot; -k4 -n -r<br>
lp❌4:7:lp:/var/spool/lpd:/sbin/nologin<br>
adm❌3:4:adm:/var/adm:/sbin/nologin<br>
sync❌5:0:sync:/sbin:/bin/sync<br>
shutdown❌6:0:shutdown:/sbin:/sbin/shutdown</p>
<p>linux中“$?”标记有什么作用?</p>
<p>可以用来判断上一条命令是否执行成功</p>
<p>如何调试shell脚本 ?</p>
<p>脚本调试使用bash -x file.sh</p>
<p>查看系统当前进程连接数？</p>
<p>判断当前linux系统的发布版，是Ubuntu、Centos、Fedora、SUSE等</p>
<p>echo &quot;$(grep -i &quot;^name&quot; /etc/os-release)&quot;</p>
<h1 id="将namecentos-linux-双引号中的内容取出更佳">将NAME=&quot;CentOS Linux&quot; 双引号中的内容取出更佳</h1>
<p>从命令行接收两个数，以及逻辑运算符（&gt;、&gt;=、&lt;、&lt;=、==、!=），打印判断结果，例如: bash 脚本名  数字1 &lt;= 数字2</p>
<pre><code class="language-shell">#! /bin/bash

function check_num()
{
    read -p &quot;请输入数字1:&quot; num1
    read -p &quot;请输入比较符号:&quot; check
    read -p &quot;请输入数字2:&quot; num2

    if [ $check = '&gt;=' ]    
    then    
        check='-ge'

    elif [ $check = '&lt;=' ]  
    then
        check='-le'

    elif [ $check = '!=' ]  
    then    
        check='-ne'
    else
        echo &quot;输入的比较符号${check}错误&quot;
        exit 1
    fi
    if [ ${num1} ${check} ${num2} ]
    then    
        echo &quot;当前文件名：$0 ${num1} ${check} ${num2} 正确&quot;
    else    
        echo &quot;当前文件名：$0 ${num1} ${check} ${num2} 错误&quot;
    fi

}

check_num
</code></pre>
<p>输入4个大于0小于等于20的数字，统计它们的和、最小的数字和最大的数字 b.要求有异常数字校验</p>
<pre><code class="language-shell">#! /bin/bash
# 四个数字求和

function num_sum
{
    num=0
    while [ $num -lt 4 ]
    do
        echo &quot;please input a num &gt;0 and &lt;=20:&quot;
        read line
        if [ $line -le 20 -a $line -gt 0 ];then
                num_list[$num]=$line
                let num=$num+1
        else
            echo &quot;输入的不符合要求&quot;
                
        fi
    done

    arr=(${num_list[*]})

    let min=${arr[0]}
    let max=${min}
    sum=0
    # #来获取数组元素的个数
    for (( i=0;i&lt;${#arr[*]};i++))
    do
            [[ ${min} -gt ${arr[$i]} ]] &amp;&amp; min=${arr[$i]}
            [[ ${max} -lt ${arr[$i]} ]] &amp;&amp; max=${arr[$i]}
            let sum=sum+${arr[$i]}
    done
    echo &quot;最小值：$min&quot;
    echo &quot;最大值：$max&quot;
    echo &quot;求和：$sum&quot;
    
}

num_sum
</code></pre>
<p>日志分析</p>
<p>使用shell脚本分析执行用例的日志：</p>
<p>a.统计每位测试人员执行用例的总数</p>
<h1 id="日志模板">日志模板</h1>
<h1 id="2019-08-17-161951025-info-keke-pass-手机号为空-generate_logspy-42">2019-08-17 16:19:51,025 INFO keke Pass 手机号为空 generate_logs.py 42</h1>
<h1 id="2019-08-17-161951026-critical-lemon-pass-密码-多于18位-generate_logspy-42">2019-08-17 16:19:51,026 CRITICAL lemon Pass 密码-多于18位 generate_logs.py 42</h1>
<pre><code class="language-shell"># 统计每位测试人员执行用例的总数

BEGIN{
    # 格式化输入表头，左对齐
    printf &quot;%-10s%-10s\n&quot;,&quot;Tester&quot;,&quot;TotalTestcases&quot;
}

{   # 定义用户类字典
    USERS[$4] += 1
}

END{
    # for循环用户列表类字典及总数
    for (u in USERS){
        printf &quot;%-10s%-10s\n&quot;, u, USERS[u]
    }
}
</code></pre>
<p>b.分别统计每位测试人员执行用例成功和失败的总数</p>
<pre><code class="language-shell"># 分别统计每位测试人员执行用例成功和失败的总数 

BEGIN{
    # 格式化输入表头，左对齐
    printf &quot;%-15s%-15s%-15s\n&quot;,&quot;Tester&quot;,&quot;Passtotal&quot;,&quot;FAIL&quot;
}

{   # 定义用户为key的字典
    if($5 ~ &quot;Pass&quot;){
        SUCCESS[$4] += 1
    } else if($5 ~ &quot;Fail&quot;){
        FAIL[$4] +=1
    }
    USERS[$4] += 1
    
}

END{
    for (u in USERS){
        printf &quot;%-15s%-15s%-15s\n&quot;, u , SUCCESS[u], FAIL[u]
    }
}
</code></pre>
<p>c.将1、2合并，同时分别统计每位测试人员执行用例CRITICAL、ERROR日志等级数以及所有测试人员每项总数</p>
<h1 id="日志模板-2">日志模板</h1>
<h1 id="2019-08-17-161951025-info-keke-pass-手机号为空-generate_logspy-42-2">2019-08-17 16:19:51,025 INFO keke Pass 手机号为空 generate_logs.py 42</h1>
<h1 id="2019-08-17-161951026-critical-lemon-pass-密码-多于18位-generate_logspy-42-2">2019-08-17 16:19:51,026 CRITICAL lemon Pass 密码-多于18位 generate_logs.py 42</h1>
<pre><code class="language-shell">BEGIN{
    # 格式化输入表头，左对齐
    printf &quot;%-15s%-15s%-15s%-15s\n&quot;,&quot;Tester&quot;,&quot;ERROR&quot;,&quot;CRITICAL&quot;,&quot;TOTAL&quot;
}

{
    # 定义用户为key的字典
    if($3 ~ &quot;CRITICAL&quot;){
        CRITICAL[$4] +=1
        CRITICALTotal +=1
    } else if($3 ~ &quot;ERROR&quot;){
        ERROR[$4] +=1
        ErrorTotal +=1
    }

    USERS[$4] += 1
}

END{
    for (u in USERS){
        printf &quot;%-15s%-15s%-15s%-15s\n&quot;, u ,ERROR[u],CRITICAL[u], CRITICAL[u] + ERROR[u]
    }
    print &quot;\n&quot;
    printf &quot;%-15s&quot;, &quot;ErrorTotal&quot;
    printf &quot;%-15s\n&quot;,ErrorTotal
    printf &quot;%-30s&quot;,&quot;CRITICALTotal&quot;
    printf &quot;%-15s\n&quot;,CRITICALTotal
    
}
</code></pre>
<p>d.使用shell脚本来实现，并显示菜单，选择不同的选项则打印不同的内容</p>
<pre><code class="language-shell">#!/bin/bash

# 定义待处理的日志文件路径
# 指定每个选项需要的awk表达式文件路径
# 显示菜单
# 用户输入执行不同的函数，输入0时，退出。exit 1
# 显示帮助信息


function show_error
{   
    echo &quot;输入错误&quot;
	echo &quot;Usage: $0 1 | 2 | 3&quot;
}


logfile_path=&quot;/root/shell_05/&quot;
total=&quot;${logfile_path}awk/user_total.awk&quot;
pass_fail=&quot;${logfile_path}awk/pass_fail.awk&quot;
critical_error=&quot;${logfile_path}/awk/critical_error.awk&quot;

logfile=&quot;${logfile_path}testcases.log&quot;

echo -e &quot;1.统计每位测试人员执行用例的总数\n2.统计每位测试人员执行用例成功和失败的总数\n3.统计详情\n0.退出&quot;
echo &quot;请输入操作选项：&quot;

read num
if [[ $num -ge 0 &amp;&amp; $num -le 3 ]];then 
    case &quot;$num&quot; in
	1)
        echo &quot;你输入的是$num,开始统计每位测试人员执行用例的总数 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;
		awk -f $total $logfile
        
		;;
	2)
		echo &quot;你输入的是$num,开始统计每位测试人员执行用例成功和失败的总数 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;
        awk -f $pass_fail $logfile
		;;
	3)
		echo &quot;你输入的是$num,统计每位测试人员执行用例CRITICAL、ERROR日志等级数以及所有测试人员每项总数&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;
		awk -f $critical_error $logfile
        ;;
	0)
		echo &quot;你输入的是$num,正在退出&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;
        exit 1
		;;
	*)
      echo &quot;非法输入&quot;
      show_error
      ;;
    esac
    exit 0
else 
    show_error
    exit 1
fi 
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[客户端自动化]]></title>
        <id>https://grassroadsz.github.io/Mbkh7VQ2l/</id>
        <link href="https://grassroadsz.github.io/Mbkh7VQ2l/">
        </link>
        <updated>2022-05-28T08:09:33.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-shell"> pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pywinauto
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
from pywinauto.application import Application
# 打开指定的应用程序

# 1. 打开windows自带的应用
# app = Application(backend='uia').start(&quot;chrome.exe --force-renderer-accessibility --incognito &quot;)

# 2. 打开任意一个应用程序
app = Application(backend='uia').start(r&quot;C:\\Users\grassroadsZ\AppData\Local\Google\Chrome\Application\chrome.exe&quot;)
# 选择指定窗口
# 1.通过窗口类型来选择
dlg = app[&quot;TNavicatMainForm&quot;]

# 2.通过窗口标题来选择
dlg = app[&quot;Navicat for MySQL&quot;]


# 方式二：app.类名
dlg =app.TNavicatMainForm

dlg.print_control_identifiers()


# 操作窗口
# 窗口最大化
dlg.maximize()

# 窗口最小化
dlg.minimize()

# 窗口恢复正常大小
dlg.restore()

# 查找窗口显示状态，最大化为1，正常为0
status = dlg.get_show_state()

# 获取当前窗口的坐标位置
rect = dlg.rectangle()
print(rect)# （L548,T194,R1768,B1043）

# 关闭窗口
dlg.close()

# 选择控件
# 选择控件

# menu = dlg.Menu
menu = dlg[&quot;Menu&quot;]
print(menu.print_control_identifiers()) # 查看Menu上的控件


file = menu.child_window(title=&quot;文件&quot;, control_type=&quot;MenuItem&quot;)
file.print_control_identifiers()
控件的分类

状态栏 StatusBar
按钮 Button
单选框 RadioButton
组合框 ComboBox
编辑栏 Edit
列表框 ListBox
弹出菜单 PopupMenu
工具栏 Toolbar
树状视图 Tree View
菜单项 MenuItem
静态内容 Static
复选框 CheckBox
组框 GroupBox
对话框 Dialog
头部内容 Header
列表显示控件 ListView
选项卡控件 TabControl
工具提示 ToolTips
菜单 Menu
窗格 Pane
&quot;&quot;&quot;

import pywinauto
from pywinauto import mouse
from pywinauto.keyboard import send_keys


class NavicatTest:

    def __init__(self, path=None, precess=None):
        # 初始化一个应用程序对象
        if path:
            self.app = pywinauto.Application(backend=&quot;uia&quot;).start(path)
        else:
            self.app = pywinauto.Application(backend=&quot;uia&quot;).connect(process=precess)
        # 选择主窗口
        self.dlg = self.app[&quot;Navicat for MySQL&quot;]

    def new_connect(self, title, host, port, user, password):
        &quot;&quot;&quot;
            新建连接
        &quot;&quot;&quot;
        # 选择菜单栏
        menu = self.dlg[&quot;Menu&quot;]
        # 点击文件
        menu.child_window(title=&quot;文件&quot;, control_type=&quot;MenuItem&quot;).click_input()
        # 点击新建连接
        menu.item_by_path(&quot;文件-&gt;新建连接...&quot;).click_input()
        # 选择新建连接窗口
        new_dlg = self.app[&quot;新建连接&quot;]
        # 连接名称输入框
        new_dlg[&quot;常规&quot;].Edit5.type_keys(title)
        # ip输入框
        new_dlg[&quot;常规&quot;].Edit1.type_keys(host)
        # 端口输入框
        new_dlg[&quot;常规&quot;].Edit4.type_keys(port)
        # 用户名输入框
        new_dlg[&quot;常规&quot;].Edit3.type_keys(user)
        # 密码输入框
        new_dlg[&quot;常规&quot;].Edit2.type_keys(password)
        # 点击确定按钮
        new_dlg[&quot;确定&quot;].click()

    def open_connect(self, title):
        &quot;&quot;&quot;
        打开连接或者数据库
        :param title: 连接名或者数据库名
        :return:
        &quot;&quot;&quot;
        # 获取控制坐标中心点，进行点击，打开连接
        db_name = self.dlg[&quot;TTreeView&quot;].child_window(title=title, control_type=&quot;TreeItem&quot;)
        rect = db_name.rectangle().mid_point()
        print(rect.x, rect.y)
        mouse.double_click(coords=(rect.x, rect.y))

    def del_connect(self, title):
        &quot;&quot;&quot;删除连接&quot;&quot;&quot;
        # 获取控件中心点位置
        db_name = self.dlg[&quot;TTreeView&quot;].child_window(title=title, control_type=&quot;TreeItem&quot;)
        rect = db_name.rectangle().mid_point()
        # 鼠标在控件中心点，右击
        mouse.right_click(coords=(rect.x, rect.y))
        # 删除连接
        self.app[&quot;上下文&quot;][&quot;MenuItem5&quot;].click_input()
        # 选择删除窗口
        self.app[&quot;确认删除&quot;][&quot;删除&quot;].click()

    def close_coonnect(self, title):
        &quot;&quot;&quot;
        关闭连接或者数据库
        :param title: 连接名或者数据库名
        :return:
        &quot;&quot;&quot;
        # 获取控件中心点位置
        db_name = self.dlg[&quot;TTreeView&quot;].child_window(title=title, control_type=&quot;TreeItem&quot;)
        rect = db_name.rectangle().mid_point()
        # 鼠标在控件中心点，右击
        mouse.right_click(coords=(rect.x, rect.y))
        # 删除连接
        self.app[&quot;上下文&quot;][&quot;MenuItem2&quot;].click_input()

    def del_database(self, database):
        db_name = self.dlg[&quot;TTreeView&quot;].child_window(title=database, control_type=&quot;TreeItem&quot;)
        rect = db_name.rectangle().mid_point()
        mouse.right_click(coords=(rect.x, rect.y))
        self.app[&quot;上下文&quot;][&quot;MenuItem4&quot;].click_input()
        # 选择删除窗口
        self.app[&quot;确认删除&quot;][&quot;删除&quot;].click()

    def new_database(self, title, database, charset=&quot;utf8 -- UTF-8 Unicode&quot;):
        &quot;&quot;&quot;新建数据库&quot;&quot;&quot;
        db_name = self.dlg[&quot;TTreeView&quot;].child_window(title=title, control_type=&quot;TreeItem&quot;)
        rect = db_name.rectangle().mid_point()
        mouse.right_click(coords=(rect.x, rect.y))

        dlg = self.app[&quot;上下文&quot;]
        # 点击新建连接
        dlg.MenuItem8.click_input()
        # 获取新建连接的窗口
        # self.app[&quot;新建数据库&quot;].print_control_identifiers()
        # 数据数据库名
        self.app[&quot;新建数据库&quot;][&quot;常规&quot;].Edit3.type_keys(database)
        self.app[&quot;新建数据库&quot;][&quot;常规&quot;].Edit2.type_keys(charset)
        # 键盘回车键，点击确定
        send_keys(&quot;{VK_RETURN}&quot;)

    def new_find_dlg(self):
        &quot;&quot;&quot;新建查询窗口&quot;&quot;&quot;
        find = self.dlg[&quot;TTreeView&quot;].child_window(title=&quot;查询&quot;, control_type=&quot;TreeItem&quot;)
        # 获取查询的左边
        rect = find.rectangle().mid_point()
        # 鼠标右击
        mouse.right_click(coords=(rect.x, rect.y))
        # 选择出现的小窗口
        dlg = self.app[&quot;上下文&quot;]
        # 点击新建连接
        dlg.MenuItem1.click_input()

    def find_sql(self, database, title, sql):
        &quot;&quot;&quot;查询sql&quot;&quot;&quot;
        title = &quot;无标题 @{} ({}) - 查询&quot;.format(database, title)
        find_dlg = self.app[title]
        find_dlg[&quot;TabControl&quot;].print_control_identifiers()
        # 获取编辑框
        edit = find_dlg[&quot;TabControl&quot;].Pane4
        # 获取编辑窗口控件位置
        rect = edit.rectangle().mid_point()
        mouse.click(coords=(rect.x, rect.y))
        sql = &quot;^a{}&quot;.format(sql.replace(&quot; &quot;, &quot;{VK_SPACE}&quot;)) + &quot;;&quot;
        send_keys(sql)
        # 使用运行快捷键
        send_keys(&quot;^r&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 命令]]></title>
        <id>https://grassroadsz.github.io/kHeewF6F8/</id>
        <link href="https://grassroadsz.github.io/kHeewF6F8/">
        </link>
        <updated>2022-05-28T08:06:00.000Z</updated>
        <content type="html"><![CDATA[<p>名词</p>
<p>master：默认开发分支</p>
<p>origin：默认远程版本库</p>
<p>Index/stage:暂缓区</p>
<p>Workspace：工作区</p>
<p>Repository：仓库区（本地仓库）</p>
<p>Remote：远程仓库</p>
<p>一. 新建代码库</p>
<h1 id="在当前目录新建一个代码仓库">在当前目录新建一个代码仓库</h1>
<pre><code>git init
</code></pre>
<h1 id="新建一个目录将其初始化为-git仓库">新建一个目录，将其初始化为    git仓库</h1>
<pre><code>git init [project-name]
</code></pre>
<h1 id="下载一个项目和它的整个代码历史">下载一个项目和它的整个代码历史</h1>
<pre><code>git clone[url]
</code></pre>
<p>二.配置</p>
<pre><code>git的设置文件为.    gitconfig,它可以在用户主目录下（全局配置）
</code></pre>
<h1 id="显示当前的-git配置">显示当前的    git配置</h1>
<pre><code>git config --list
</code></pre>
<h1 id="编辑-git配置文件">编辑    git配置文件</h1>
<pre><code>git config -e [--global]
</code></pre>
<h1 id="设置提交代码时的用户信息">设置提交代码时的用户信息</h1>
<pre><code>git config [--global]
</code></pre>
<h1 id="设置提交代码时的用户信息-2">设置提交代码时的用户信息</h1>
<pre><code>git config [--global] user.name &quot;[name]&quot;

git config [--global] user.email &quot;email address&quot;
</code></pre>
<p>三.增加/删除/修改文件</p>
<h1 id="查看状态">查看状态</h1>
<pre><code>git status
</code></pre>
<h1 id="查看变更内容">查看变更内容</h1>
<pre><code>git diff
</code></pre>
<h1 id="添加指定文件到暂存区">添加指定文件到暂存区</h1>
<pre><code>git add [file1] [file2]
</code></pre>
<h1 id="添加指定目录到暂缓区包括子目录">添加指定目录到暂缓区，包括子目录</h1>
<pre><code>git add .
</code></pre>
<h1 id="添加每个变化前都会要求确认">添加每个变化前，都会要求确认</h1>
<p>#对于同一个文件的多处变化，可以实现分次提交</p>
<pre><code>git add -p
</code></pre>
<h1 id="删除工作区文件并且将这次删除放入暂缓区">删除工作区文件，并且将这次删除放入=暂缓区</h1>
<pre><code>git rm[file1] [file2]...
</code></pre>
<h1 id="停止追踪指定文件但该文件会保留在工作区">停止追踪指定文件，但该文件会保留在工作区</h1>
<pre><code>git rm --cached [file]
</code></pre>
<h1 id="改名文件并且将这个改名放入暂存区">改名文件，并且将这个改名放入暂存区</h1>
<pre><code>git mv [file-oigin] [file-renamed]
</code></pre>
<p>代码提交</p>
<h1 id="提交暂缓区至仓库区">提交暂缓区至仓库区</h1>
<pre><code>git commit -m [message]
</code></pre>
<h1 id="提交暂缓区的指定文件到仓库区">提交暂缓区的指定文件到仓库区</h1>
<pre><code>git commit [file1] [file2]...m [message]
</code></pre>
<h1 id="提交工作区自上次commit之后的变化直接到仓库区">提交工作区自上次commit之后的变化，直接到仓库区</h1>
<pre><code>git commit -a
</code></pre>
<h1 id="使用一次新的commit替代上一次提交">使用一次新的commit，替代上一次提交</h1>
<h1 id="如果代码没有任何新变化则用来改写上一次commit的提交信息">如果代码没有任何新变化，则用来改写上一次commit的提交信息</h1>
<pre><code>git commit --amend -m [message]
</code></pre>
<h1 id="重做上一次commit并包括指定文件的新变化">重做上一次commit，并包括指定文件的新变化</h1>
<pre><code>git commit --amend [file1] [file2]...
</code></pre>
<p>五.分支</p>
<h1 id="显示所有的本地分支">显示所有的本地分支</h1>
<pre><code>git branch
</code></pre>
<h1 id="列出所有的远程分支">列出所有的远程分支</h1>
<pre><code>git branch -r
</code></pre>
<h1 id="列出所有的本地分支和远程分支">列出所有的本地分支和远程分支</h1>
<pre><code>git branch -a
</code></pre>
<h1 id="新建一个分支但是依然停留在当前分支">新建一个分支，但是依然停留在当前分支</h1>
<pre><code>git branch [branch-name]
</code></pre>
<h1 id="新建一个分支并与指定的远程分支建立追踪关系">新建一个分支，并与指定的远程分支建立追踪关系</h1>
<pre><code>git branch --track [branck] [remote-name]
</code></pre>
<h1 id="删除远程分支">删除远程分支</h1>
<pre><code>git push origin --delete [branch-name]

git branch -dr [remote/branch]
</code></pre>
<h1 id="新建一个分支并切换到该分支">新建一个分支，并切换到该分支</h1>
<pre><code>git checkout -b [branch]
</code></pre>
<h1 id="切换到指定分支并更新工作区">切换到指定分支，并更新工作区</h1>
<pre><code>git checkout [branch-name]
</code></pre>
<h1 id="切换到上一个分支">切换到上一个分支</h1>
<pre><code>git checkout -
</code></pre>
<h1 id="建立追踪关系在现有分支与指定的远程分支之间">建立追踪关系，在现有分支与指定的远程分支之间</h1>
<pre><code>git branch --set-upstream [branch] [remote-branch]
</code></pre>
<h1 id="合并指定分支到当前分支">合并指定分支到当前分支</h1>
<pre><code>git merge [branch]
</code></pre>
<h1 id="衍合指定分支到当前分支">衍合指定分支到当前分支</h1>
<pre><code>git rebase &lt;branch&gt;
</code></pre>
<h1 id="选择一个commit合并到当前分支">选择一个commit，合并到当前分支</h1>
<pre><code>git cherry-pick [commit]
</code></pre>
<p>六. 标签</p>
<h1 id="列出所有本地标签">列出所有本地标签</h1>
<pre><code>git tag
</code></pre>
<h1 id="基于最新提交创建的标签">基于最新提交创建的标签</h1>
<pre><code>git tag &lt;tagname&gt;
</code></pre>
<h1 id="删除标签">删除标签</h1>
<pre><code>git tag -d &lt;tagname&gt;
</code></pre>
<h1 id="删除远程tag">删除远程tag</h1>
<pre><code>git push origin ：refs/tages/[tagename]
</code></pre>
<h1 id="查看tag信息">查看tag信息</h1>
<pre><code>git show [tag]
</code></pre>
<h1 id="提交指定tag">提交指定tag</h1>
<pre><code>git  push [remote] [tag]
</code></pre>
<h1 id="提交所有tag">提交所有tag</h1>
<pre><code>git push [remote] --[tag]
</code></pre>
<h1 id="新建一个分支指向某个tag">新建一个分支，指向某个tag</h1>
<pre><code>git checkout -b [branch] [tag]
</code></pre>
<p>七.查看信息</p>
<h1 id="显示有变更的文件">显示有变更的文件</h1>
<pre><code>git status 
</code></pre>
<h1 id="显示当前分支的版本历史">显示当前分支的版本历史</h1>
<pre><code>git log
</code></pre>
<h1 id="显示commit历史以及每次commit发生变更的文件">显示commit历史，以及每次commit发生变更的文件</h1>
<pre><code>git log --stat
</code></pre>
<h1 id="搜索提交历史根据关键词">搜索提交历史，根据关键词</h1>
<pre><code>git log -s [keyword]
</code></pre>
<h1 id="显示某个commit之后的所有变动每个commit占据一行">显示某个commit之后的所有变动，每个commit占据一行</h1>
<pre><code>git log [tag] HEAD --pretty=format:%s
</code></pre>
<h1 id="显示某个commit之后的所有变动其提交说明必须符合搜索条件">显示某个commit之后的所有变动，其“提交说明”必须符合搜索条件</h1>
<pre><code>git log [tag] HEAD --grep feature
</code></pre>
<h1 id="显示某个文件的版本历史包括文件改名">显示某个文件的版本历史，包括文件改名</h1>
<pre><code>git log --follow [file]
git whatchanged [file]
</code></pre>
<h1 id="显示指定文件相关的每一次diff">显示指定文件相关的每一次diff</h1>
<pre><code>git log -p [file]
</code></pre>
<h1 id="显示过去的5次提交">显示过去的5次提交</h1>
<pre><code>git log -5 --pretty --oneline
</code></pre>
<h1 id="显示所有提交过的用户按提交次数排序">显示所有提交过的用户，按提交次数排序</h1>
<pre><code>git shortlog -sn
</code></pre>
<h1 id="显示指定文件是什么人在什么时间修改过">显示指定文件是什么人在什么时间修改过</h1>
<pre><code>git blame [file]
</code></pre>
<h1 id="显示暂缓区和工作区的差异">显示暂缓区和工作区的差异</h1>
<pre><code>git diff
</code></pre>
<h1 id="显示暂缓区和上一个commit的差异">显示暂缓区和上一个commit的差异</h1>
<pre><code>git diff HEAD
</code></pre>
<h1 id="显示两次提交之间的差异">显示两次提交之间的差异</h1>
<pre><code>git diff [first-branch]...[second-branch]
</code></pre>
<h1 id="显示某次提交发生变化的文件">显示某次提交发生变化的文件</h1>
<pre><code>git show --name-only [commit]
</code></pre>
<p>远程操作</p>
<h1 id="下载远程仓库的所有变动">下载远程仓库的所有变动</h1>
<pre><code>git fetch [remote]
</code></pre>
<h1 id="取回远程仓库的变化并与本地分支合并">取回远程仓库的变化，并与本地分支合并</h1>
<pre><code>git pull [remote] [branch]
</code></pre>
<h1 id="显示所有的远程仓库">显示所有的远程仓库</h1>
<pre><code>git remote -v 
</code></pre>
<h1 id="显示某个远程仓库的信息">显示某个远程仓库的信息</h1>
<pre><code>git remote show [remote]
</code></pre>
<h1 id="增加一个新的远程仓库并命名">增加一个新的远程仓库，并命名</h1>
<pre><code>git remote add [shortname] [url]
</code></pre>
<h1 id="上传本地指定分支到远程仓库">上传本地指定分支到远程仓库</h1>
<pre><code>git push [remote] [branch]
</code></pre>
<h1 id="强行推送当前分支到远程仓库即使有冲突">强行推送当前分支到远程仓库，即使有冲突</h1>
<pre><code>git push [remote] --force
</code></pre>
<h1 id="推送所有的分支到远程仓库">推送所有的分支到远程仓库</h1>
<pre><code>git push [remote] --all
</code></pre>
<p>九.撤销</p>
<h1 id="撤销工作目录中所有未提交文件的修改内容">撤销工作目录中所有未提交文件的修改内容</h1>
<pre><code>git reset --hard HEAD
</code></pre>
<h1 id="撤销指定的未提交文件的修改内容">撤销指定的未提交文件的修改内容</h1>
<pre><code>git  checkout HEAD [file]
</code></pre>
<h1 id="撤销指定的提交">撤销指定的提交</h1>
<pre><code>git revert &lt;commit&gt;</code></pre>
]]></content>
    </entry>
</feed>